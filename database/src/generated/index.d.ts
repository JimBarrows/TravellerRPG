
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model CampaignMember
 * 
 */
export type CampaignMember = $Result.DefaultSelection<Prisma.$CampaignMemberPayload>
/**
 * Model Character
 * 
 */
export type Character = $Result.DefaultSelection<Prisma.$CharacterPayload>
/**
 * Model Characteristics
 * 
 */
export type Characteristics = $Result.DefaultSelection<Prisma.$CharacteristicsPayload>
/**
 * Model CharacterSkill
 * 
 */
export type CharacterSkill = $Result.DefaultSelection<Prisma.$CharacterSkillPayload>
/**
 * Model CharacterEquipment
 * 
 */
export type CharacterEquipment = $Result.DefaultSelection<Prisma.$CharacterEquipmentPayload>
/**
 * Model LifeEvent
 * 
 */
export type LifeEvent = $Result.DefaultSelection<Prisma.$LifeEventPayload>
/**
 * Model StarSystem
 * 
 */
export type StarSystem = $Result.DefaultSelection<Prisma.$StarSystemPayload>
/**
 * Model Planet
 * 
 */
export type Planet = $Result.DefaultSelection<Prisma.$PlanetPayload>
/**
 * Model Starship
 * 
 */
export type Starship = $Result.DefaultSelection<Prisma.$StarshipPayload>
/**
 * Model TradeGood
 * 
 */
export type TradeGood = $Result.DefaultSelection<Prisma.$TradeGoodPayload>
/**
 * Model TradeRoute
 * 
 */
export type TradeRoute = $Result.DefaultSelection<Prisma.$TradeRoutePayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Encounter
 * 
 */
export type Encounter = $Result.DefaultSelection<Prisma.$EncounterPayload>
/**
 * Model CombatSession
 * 
 */
export type CombatSession = $Result.DefaultSelection<Prisma.$CombatSessionPayload>
/**
 * Model CombatAction
 * 
 */
export type CombatAction = $Result.DefaultSelection<Prisma.$CombatActionPayload>
/**
 * Model DiceRoll
 * 
 */
export type DiceRoll = $Result.DefaultSelection<Prisma.$DiceRollPayload>
/**
 * Model CustomContent
 * 
 */
export type CustomContent = $Result.DefaultSelection<Prisma.$CustomContentPayload>
/**
 * Model HouseRule
 * 
 */
export type HouseRule = $Result.DefaultSelection<Prisma.$HouseRulePayload>
/**
 * Model Handout
 * 
 */
export type Handout = $Result.DefaultSelection<Prisma.$HandoutPayload>
/**
 * Model SessionNote
 * 
 */
export type SessionNote = $Result.DefaultSelection<Prisma.$SessionNotePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SubscriptionTier: {
  FREE: 'FREE',
  STANDARD: 'STANDARD',
  PREMIUM: 'PREMIUM'
};

export type SubscriptionTier = (typeof SubscriptionTier)[keyof typeof SubscriptionTier]


export const CampaignRole: {
  GAMEMASTER: 'GAMEMASTER',
  PLAYER: 'PLAYER',
  OBSERVER: 'OBSERVER'
};

export type CampaignRole = (typeof CampaignRole)[keyof typeof CampaignRole]


export const SessionStatus: {
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type SessionStatus = (typeof SessionStatus)[keyof typeof SessionStatus]

}

export type SubscriptionTier = $Enums.SubscriptionTier

export const SubscriptionTier: typeof $Enums.SubscriptionTier

export type CampaignRole = $Enums.CampaignRole

export const CampaignRole: typeof $Enums.CampaignRole

export type SessionStatus = $Enums.SessionStatus

export const SessionStatus: typeof $Enums.SessionStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs>;

  /**
   * `prisma.campaignMember`: Exposes CRUD operations for the **CampaignMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignMembers
    * const campaignMembers = await prisma.campaignMember.findMany()
    * ```
    */
  get campaignMember(): Prisma.CampaignMemberDelegate<ExtArgs>;

  /**
   * `prisma.character`: Exposes CRUD operations for the **Character** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characters
    * const characters = await prisma.character.findMany()
    * ```
    */
  get character(): Prisma.CharacterDelegate<ExtArgs>;

  /**
   * `prisma.characteristics`: Exposes CRUD operations for the **Characteristics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characteristics
    * const characteristics = await prisma.characteristics.findMany()
    * ```
    */
  get characteristics(): Prisma.CharacteristicsDelegate<ExtArgs>;

  /**
   * `prisma.characterSkill`: Exposes CRUD operations for the **CharacterSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterSkills
    * const characterSkills = await prisma.characterSkill.findMany()
    * ```
    */
  get characterSkill(): Prisma.CharacterSkillDelegate<ExtArgs>;

  /**
   * `prisma.characterEquipment`: Exposes CRUD operations for the **CharacterEquipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterEquipments
    * const characterEquipments = await prisma.characterEquipment.findMany()
    * ```
    */
  get characterEquipment(): Prisma.CharacterEquipmentDelegate<ExtArgs>;

  /**
   * `prisma.lifeEvent`: Exposes CRUD operations for the **LifeEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LifeEvents
    * const lifeEvents = await prisma.lifeEvent.findMany()
    * ```
    */
  get lifeEvent(): Prisma.LifeEventDelegate<ExtArgs>;

  /**
   * `prisma.starSystem`: Exposes CRUD operations for the **StarSystem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StarSystems
    * const starSystems = await prisma.starSystem.findMany()
    * ```
    */
  get starSystem(): Prisma.StarSystemDelegate<ExtArgs>;

  /**
   * `prisma.planet`: Exposes CRUD operations for the **Planet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Planets
    * const planets = await prisma.planet.findMany()
    * ```
    */
  get planet(): Prisma.PlanetDelegate<ExtArgs>;

  /**
   * `prisma.starship`: Exposes CRUD operations for the **Starship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Starships
    * const starships = await prisma.starship.findMany()
    * ```
    */
  get starship(): Prisma.StarshipDelegate<ExtArgs>;

  /**
   * `prisma.tradeGood`: Exposes CRUD operations for the **TradeGood** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TradeGoods
    * const tradeGoods = await prisma.tradeGood.findMany()
    * ```
    */
  get tradeGood(): Prisma.TradeGoodDelegate<ExtArgs>;

  /**
   * `prisma.tradeRoute`: Exposes CRUD operations for the **TradeRoute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TradeRoutes
    * const tradeRoutes = await prisma.tradeRoute.findMany()
    * ```
    */
  get tradeRoute(): Prisma.TradeRouteDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.encounter`: Exposes CRUD operations for the **Encounter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Encounters
    * const encounters = await prisma.encounter.findMany()
    * ```
    */
  get encounter(): Prisma.EncounterDelegate<ExtArgs>;

  /**
   * `prisma.combatSession`: Exposes CRUD operations for the **CombatSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CombatSessions
    * const combatSessions = await prisma.combatSession.findMany()
    * ```
    */
  get combatSession(): Prisma.CombatSessionDelegate<ExtArgs>;

  /**
   * `prisma.combatAction`: Exposes CRUD operations for the **CombatAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CombatActions
    * const combatActions = await prisma.combatAction.findMany()
    * ```
    */
  get combatAction(): Prisma.CombatActionDelegate<ExtArgs>;

  /**
   * `prisma.diceRoll`: Exposes CRUD operations for the **DiceRoll** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiceRolls
    * const diceRolls = await prisma.diceRoll.findMany()
    * ```
    */
  get diceRoll(): Prisma.DiceRollDelegate<ExtArgs>;

  /**
   * `prisma.customContent`: Exposes CRUD operations for the **CustomContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomContents
    * const customContents = await prisma.customContent.findMany()
    * ```
    */
  get customContent(): Prisma.CustomContentDelegate<ExtArgs>;

  /**
   * `prisma.houseRule`: Exposes CRUD operations for the **HouseRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HouseRules
    * const houseRules = await prisma.houseRule.findMany()
    * ```
    */
  get houseRule(): Prisma.HouseRuleDelegate<ExtArgs>;

  /**
   * `prisma.handout`: Exposes CRUD operations for the **Handout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Handouts
    * const handouts = await prisma.handout.findMany()
    * ```
    */
  get handout(): Prisma.HandoutDelegate<ExtArgs>;

  /**
   * `prisma.sessionNote`: Exposes CRUD operations for the **SessionNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionNotes
    * const sessionNotes = await prisma.sessionNote.findMany()
    * ```
    */
  get sessionNote(): Prisma.SessionNoteDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Campaign: 'Campaign',
    CampaignMember: 'CampaignMember',
    Character: 'Character',
    Characteristics: 'Characteristics',
    CharacterSkill: 'CharacterSkill',
    CharacterEquipment: 'CharacterEquipment',
    LifeEvent: 'LifeEvent',
    StarSystem: 'StarSystem',
    Planet: 'Planet',
    Starship: 'Starship',
    TradeGood: 'TradeGood',
    TradeRoute: 'TradeRoute',
    Session: 'Session',
    Encounter: 'Encounter',
    CombatSession: 'CombatSession',
    CombatAction: 'CombatAction',
    DiceRoll: 'DiceRoll',
    CustomContent: 'CustomContent',
    HouseRule: 'HouseRule',
    Handout: 'Handout',
    SessionNote: 'SessionNote'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "campaign" | "campaignMember" | "character" | "characteristics" | "characterSkill" | "characterEquipment" | "lifeEvent" | "starSystem" | "planet" | "starship" | "tradeGood" | "tradeRoute" | "session" | "encounter" | "combatSession" | "combatAction" | "diceRoll" | "customContent" | "houseRule" | "handout" | "sessionNote"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      CampaignMember: {
        payload: Prisma.$CampaignMemberPayload<ExtArgs>
        fields: Prisma.CampaignMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMemberPayload>
          }
          findFirst: {
            args: Prisma.CampaignMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMemberPayload>
          }
          findMany: {
            args: Prisma.CampaignMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMemberPayload>[]
          }
          create: {
            args: Prisma.CampaignMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMemberPayload>
          }
          createMany: {
            args: Prisma.CampaignMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMemberPayload>[]
          }
          delete: {
            args: Prisma.CampaignMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMemberPayload>
          }
          update: {
            args: Prisma.CampaignMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMemberPayload>
          }
          deleteMany: {
            args: Prisma.CampaignMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMemberPayload>
          }
          aggregate: {
            args: Prisma.CampaignMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignMember>
          }
          groupBy: {
            args: Prisma.CampaignMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignMemberCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignMemberCountAggregateOutputType> | number
          }
        }
      }
      Character: {
        payload: Prisma.$CharacterPayload<ExtArgs>
        fields: Prisma.CharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findFirst: {
            args: Prisma.CharacterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findMany: {
            args: Prisma.CharacterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          create: {
            args: Prisma.CharacterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          createMany: {
            args: Prisma.CharacterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          delete: {
            args: Prisma.CharacterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          update: {
            args: Prisma.CharacterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          deleteMany: {
            args: Prisma.CharacterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CharacterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          aggregate: {
            args: Prisma.CharacterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter>
          }
          groupBy: {
            args: Prisma.CharacterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterCountAggregateOutputType> | number
          }
        }
      }
      Characteristics: {
        payload: Prisma.$CharacteristicsPayload<ExtArgs>
        fields: Prisma.CharacteristicsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacteristicsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacteristicsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicsPayload>
          }
          findFirst: {
            args: Prisma.CharacteristicsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacteristicsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicsPayload>
          }
          findMany: {
            args: Prisma.CharacteristicsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicsPayload>[]
          }
          create: {
            args: Prisma.CharacteristicsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicsPayload>
          }
          createMany: {
            args: Prisma.CharacteristicsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacteristicsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicsPayload>[]
          }
          delete: {
            args: Prisma.CharacteristicsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicsPayload>
          }
          update: {
            args: Prisma.CharacteristicsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicsPayload>
          }
          deleteMany: {
            args: Prisma.CharacteristicsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacteristicsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CharacteristicsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicsPayload>
          }
          aggregate: {
            args: Prisma.CharacteristicsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacteristics>
          }
          groupBy: {
            args: Prisma.CharacteristicsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacteristicsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacteristicsCountArgs<ExtArgs>
            result: $Utils.Optional<CharacteristicsCountAggregateOutputType> | number
          }
        }
      }
      CharacterSkill: {
        payload: Prisma.$CharacterSkillPayload<ExtArgs>
        fields: Prisma.CharacterSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          findFirst: {
            args: Prisma.CharacterSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          findMany: {
            args: Prisma.CharacterSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>[]
          }
          create: {
            args: Prisma.CharacterSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          createMany: {
            args: Prisma.CharacterSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>[]
          }
          delete: {
            args: Prisma.CharacterSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          update: {
            args: Prisma.CharacterSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          deleteMany: {
            args: Prisma.CharacterSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CharacterSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterSkillPayload>
          }
          aggregate: {
            args: Prisma.CharacterSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacterSkill>
          }
          groupBy: {
            args: Prisma.CharacterSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterSkillCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterSkillCountAggregateOutputType> | number
          }
        }
      }
      CharacterEquipment: {
        payload: Prisma.$CharacterEquipmentPayload<ExtArgs>
        fields: Prisma.CharacterEquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterEquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterEquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterEquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterEquipmentPayload>
          }
          findFirst: {
            args: Prisma.CharacterEquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterEquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterEquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterEquipmentPayload>
          }
          findMany: {
            args: Prisma.CharacterEquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterEquipmentPayload>[]
          }
          create: {
            args: Prisma.CharacterEquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterEquipmentPayload>
          }
          createMany: {
            args: Prisma.CharacterEquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterEquipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterEquipmentPayload>[]
          }
          delete: {
            args: Prisma.CharacterEquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterEquipmentPayload>
          }
          update: {
            args: Prisma.CharacterEquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterEquipmentPayload>
          }
          deleteMany: {
            args: Prisma.CharacterEquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterEquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CharacterEquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterEquipmentPayload>
          }
          aggregate: {
            args: Prisma.CharacterEquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacterEquipment>
          }
          groupBy: {
            args: Prisma.CharacterEquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterEquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterEquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterEquipmentCountAggregateOutputType> | number
          }
        }
      }
      LifeEvent: {
        payload: Prisma.$LifeEventPayload<ExtArgs>
        fields: Prisma.LifeEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LifeEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LifeEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeEventPayload>
          }
          findFirst: {
            args: Prisma.LifeEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LifeEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeEventPayload>
          }
          findMany: {
            args: Prisma.LifeEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeEventPayload>[]
          }
          create: {
            args: Prisma.LifeEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeEventPayload>
          }
          createMany: {
            args: Prisma.LifeEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LifeEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeEventPayload>[]
          }
          delete: {
            args: Prisma.LifeEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeEventPayload>
          }
          update: {
            args: Prisma.LifeEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeEventPayload>
          }
          deleteMany: {
            args: Prisma.LifeEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LifeEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LifeEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LifeEventPayload>
          }
          aggregate: {
            args: Prisma.LifeEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLifeEvent>
          }
          groupBy: {
            args: Prisma.LifeEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<LifeEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.LifeEventCountArgs<ExtArgs>
            result: $Utils.Optional<LifeEventCountAggregateOutputType> | number
          }
        }
      }
      StarSystem: {
        payload: Prisma.$StarSystemPayload<ExtArgs>
        fields: Prisma.StarSystemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StarSystemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarSystemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StarSystemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarSystemPayload>
          }
          findFirst: {
            args: Prisma.StarSystemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarSystemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StarSystemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarSystemPayload>
          }
          findMany: {
            args: Prisma.StarSystemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarSystemPayload>[]
          }
          create: {
            args: Prisma.StarSystemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarSystemPayload>
          }
          createMany: {
            args: Prisma.StarSystemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StarSystemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarSystemPayload>[]
          }
          delete: {
            args: Prisma.StarSystemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarSystemPayload>
          }
          update: {
            args: Prisma.StarSystemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarSystemPayload>
          }
          deleteMany: {
            args: Prisma.StarSystemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StarSystemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StarSystemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarSystemPayload>
          }
          aggregate: {
            args: Prisma.StarSystemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStarSystem>
          }
          groupBy: {
            args: Prisma.StarSystemGroupByArgs<ExtArgs>
            result: $Utils.Optional<StarSystemGroupByOutputType>[]
          }
          count: {
            args: Prisma.StarSystemCountArgs<ExtArgs>
            result: $Utils.Optional<StarSystemCountAggregateOutputType> | number
          }
        }
      }
      Planet: {
        payload: Prisma.$PlanetPayload<ExtArgs>
        fields: Prisma.PlanetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanetPayload>
          }
          findFirst: {
            args: Prisma.PlanetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanetPayload>
          }
          findMany: {
            args: Prisma.PlanetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanetPayload>[]
          }
          create: {
            args: Prisma.PlanetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanetPayload>
          }
          createMany: {
            args: Prisma.PlanetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanetPayload>[]
          }
          delete: {
            args: Prisma.PlanetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanetPayload>
          }
          update: {
            args: Prisma.PlanetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanetPayload>
          }
          deleteMany: {
            args: Prisma.PlanetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanetPayload>
          }
          aggregate: {
            args: Prisma.PlanetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanet>
          }
          groupBy: {
            args: Prisma.PlanetGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanetGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanetCountArgs<ExtArgs>
            result: $Utils.Optional<PlanetCountAggregateOutputType> | number
          }
        }
      }
      Starship: {
        payload: Prisma.$StarshipPayload<ExtArgs>
        fields: Prisma.StarshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StarshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StarshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarshipPayload>
          }
          findFirst: {
            args: Prisma.StarshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StarshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarshipPayload>
          }
          findMany: {
            args: Prisma.StarshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarshipPayload>[]
          }
          create: {
            args: Prisma.StarshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarshipPayload>
          }
          createMany: {
            args: Prisma.StarshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StarshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarshipPayload>[]
          }
          delete: {
            args: Prisma.StarshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarshipPayload>
          }
          update: {
            args: Prisma.StarshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarshipPayload>
          }
          deleteMany: {
            args: Prisma.StarshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StarshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StarshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StarshipPayload>
          }
          aggregate: {
            args: Prisma.StarshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStarship>
          }
          groupBy: {
            args: Prisma.StarshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<StarshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.StarshipCountArgs<ExtArgs>
            result: $Utils.Optional<StarshipCountAggregateOutputType> | number
          }
        }
      }
      TradeGood: {
        payload: Prisma.$TradeGoodPayload<ExtArgs>
        fields: Prisma.TradeGoodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TradeGoodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeGoodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TradeGoodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeGoodPayload>
          }
          findFirst: {
            args: Prisma.TradeGoodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeGoodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TradeGoodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeGoodPayload>
          }
          findMany: {
            args: Prisma.TradeGoodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeGoodPayload>[]
          }
          create: {
            args: Prisma.TradeGoodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeGoodPayload>
          }
          createMany: {
            args: Prisma.TradeGoodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TradeGoodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeGoodPayload>[]
          }
          delete: {
            args: Prisma.TradeGoodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeGoodPayload>
          }
          update: {
            args: Prisma.TradeGoodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeGoodPayload>
          }
          deleteMany: {
            args: Prisma.TradeGoodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TradeGoodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TradeGoodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeGoodPayload>
          }
          aggregate: {
            args: Prisma.TradeGoodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTradeGood>
          }
          groupBy: {
            args: Prisma.TradeGoodGroupByArgs<ExtArgs>
            result: $Utils.Optional<TradeGoodGroupByOutputType>[]
          }
          count: {
            args: Prisma.TradeGoodCountArgs<ExtArgs>
            result: $Utils.Optional<TradeGoodCountAggregateOutputType> | number
          }
        }
      }
      TradeRoute: {
        payload: Prisma.$TradeRoutePayload<ExtArgs>
        fields: Prisma.TradeRouteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TradeRouteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeRoutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TradeRouteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeRoutePayload>
          }
          findFirst: {
            args: Prisma.TradeRouteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeRoutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TradeRouteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeRoutePayload>
          }
          findMany: {
            args: Prisma.TradeRouteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeRoutePayload>[]
          }
          create: {
            args: Prisma.TradeRouteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeRoutePayload>
          }
          createMany: {
            args: Prisma.TradeRouteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TradeRouteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeRoutePayload>[]
          }
          delete: {
            args: Prisma.TradeRouteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeRoutePayload>
          }
          update: {
            args: Prisma.TradeRouteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeRoutePayload>
          }
          deleteMany: {
            args: Prisma.TradeRouteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TradeRouteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TradeRouteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TradeRoutePayload>
          }
          aggregate: {
            args: Prisma.TradeRouteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTradeRoute>
          }
          groupBy: {
            args: Prisma.TradeRouteGroupByArgs<ExtArgs>
            result: $Utils.Optional<TradeRouteGroupByOutputType>[]
          }
          count: {
            args: Prisma.TradeRouteCountArgs<ExtArgs>
            result: $Utils.Optional<TradeRouteCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Encounter: {
        payload: Prisma.$EncounterPayload<ExtArgs>
        fields: Prisma.EncounterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findFirst: {
            args: Prisma.EncounterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findMany: {
            args: Prisma.EncounterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          create: {
            args: Prisma.EncounterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          createMany: {
            args: Prisma.EncounterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          delete: {
            args: Prisma.EncounterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          update: {
            args: Prisma.EncounterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          deleteMany: {
            args: Prisma.EncounterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EncounterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          aggregate: {
            args: Prisma.EncounterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounter>
          }
          groupBy: {
            args: Prisma.EncounterGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterCountAggregateOutputType> | number
          }
        }
      }
      CombatSession: {
        payload: Prisma.$CombatSessionPayload<ExtArgs>
        fields: Prisma.CombatSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CombatSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CombatSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatSessionPayload>
          }
          findFirst: {
            args: Prisma.CombatSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CombatSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatSessionPayload>
          }
          findMany: {
            args: Prisma.CombatSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatSessionPayload>[]
          }
          create: {
            args: Prisma.CombatSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatSessionPayload>
          }
          createMany: {
            args: Prisma.CombatSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CombatSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatSessionPayload>[]
          }
          delete: {
            args: Prisma.CombatSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatSessionPayload>
          }
          update: {
            args: Prisma.CombatSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatSessionPayload>
          }
          deleteMany: {
            args: Prisma.CombatSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CombatSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CombatSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatSessionPayload>
          }
          aggregate: {
            args: Prisma.CombatSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCombatSession>
          }
          groupBy: {
            args: Prisma.CombatSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CombatSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CombatSessionCountArgs<ExtArgs>
            result: $Utils.Optional<CombatSessionCountAggregateOutputType> | number
          }
        }
      }
      CombatAction: {
        payload: Prisma.$CombatActionPayload<ExtArgs>
        fields: Prisma.CombatActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CombatActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CombatActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatActionPayload>
          }
          findFirst: {
            args: Prisma.CombatActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CombatActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatActionPayload>
          }
          findMany: {
            args: Prisma.CombatActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatActionPayload>[]
          }
          create: {
            args: Prisma.CombatActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatActionPayload>
          }
          createMany: {
            args: Prisma.CombatActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CombatActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatActionPayload>[]
          }
          delete: {
            args: Prisma.CombatActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatActionPayload>
          }
          update: {
            args: Prisma.CombatActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatActionPayload>
          }
          deleteMany: {
            args: Prisma.CombatActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CombatActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CombatActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CombatActionPayload>
          }
          aggregate: {
            args: Prisma.CombatActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCombatAction>
          }
          groupBy: {
            args: Prisma.CombatActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CombatActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CombatActionCountArgs<ExtArgs>
            result: $Utils.Optional<CombatActionCountAggregateOutputType> | number
          }
        }
      }
      DiceRoll: {
        payload: Prisma.$DiceRollPayload<ExtArgs>
        fields: Prisma.DiceRollFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiceRollFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiceRollPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiceRollFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiceRollPayload>
          }
          findFirst: {
            args: Prisma.DiceRollFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiceRollPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiceRollFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiceRollPayload>
          }
          findMany: {
            args: Prisma.DiceRollFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiceRollPayload>[]
          }
          create: {
            args: Prisma.DiceRollCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiceRollPayload>
          }
          createMany: {
            args: Prisma.DiceRollCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiceRollCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiceRollPayload>[]
          }
          delete: {
            args: Prisma.DiceRollDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiceRollPayload>
          }
          update: {
            args: Prisma.DiceRollUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiceRollPayload>
          }
          deleteMany: {
            args: Prisma.DiceRollDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiceRollUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DiceRollUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiceRollPayload>
          }
          aggregate: {
            args: Prisma.DiceRollAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiceRoll>
          }
          groupBy: {
            args: Prisma.DiceRollGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiceRollGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiceRollCountArgs<ExtArgs>
            result: $Utils.Optional<DiceRollCountAggregateOutputType> | number
          }
        }
      }
      CustomContent: {
        payload: Prisma.$CustomContentPayload<ExtArgs>
        fields: Prisma.CustomContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomContentPayload>
          }
          findFirst: {
            args: Prisma.CustomContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomContentPayload>
          }
          findMany: {
            args: Prisma.CustomContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomContentPayload>[]
          }
          create: {
            args: Prisma.CustomContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomContentPayload>
          }
          createMany: {
            args: Prisma.CustomContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomContentPayload>[]
          }
          delete: {
            args: Prisma.CustomContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomContentPayload>
          }
          update: {
            args: Prisma.CustomContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomContentPayload>
          }
          deleteMany: {
            args: Prisma.CustomContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomContentPayload>
          }
          aggregate: {
            args: Prisma.CustomContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomContent>
          }
          groupBy: {
            args: Prisma.CustomContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomContentCountArgs<ExtArgs>
            result: $Utils.Optional<CustomContentCountAggregateOutputType> | number
          }
        }
      }
      HouseRule: {
        payload: Prisma.$HouseRulePayload<ExtArgs>
        fields: Prisma.HouseRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HouseRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HouseRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseRulePayload>
          }
          findFirst: {
            args: Prisma.HouseRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HouseRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseRulePayload>
          }
          findMany: {
            args: Prisma.HouseRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseRulePayload>[]
          }
          create: {
            args: Prisma.HouseRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseRulePayload>
          }
          createMany: {
            args: Prisma.HouseRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HouseRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseRulePayload>[]
          }
          delete: {
            args: Prisma.HouseRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseRulePayload>
          }
          update: {
            args: Prisma.HouseRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseRulePayload>
          }
          deleteMany: {
            args: Prisma.HouseRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HouseRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HouseRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HouseRulePayload>
          }
          aggregate: {
            args: Prisma.HouseRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHouseRule>
          }
          groupBy: {
            args: Prisma.HouseRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<HouseRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.HouseRuleCountArgs<ExtArgs>
            result: $Utils.Optional<HouseRuleCountAggregateOutputType> | number
          }
        }
      }
      Handout: {
        payload: Prisma.$HandoutPayload<ExtArgs>
        fields: Prisma.HandoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HandoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HandoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoutPayload>
          }
          findFirst: {
            args: Prisma.HandoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HandoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoutPayload>
          }
          findMany: {
            args: Prisma.HandoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoutPayload>[]
          }
          create: {
            args: Prisma.HandoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoutPayload>
          }
          createMany: {
            args: Prisma.HandoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HandoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoutPayload>[]
          }
          delete: {
            args: Prisma.HandoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoutPayload>
          }
          update: {
            args: Prisma.HandoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoutPayload>
          }
          deleteMany: {
            args: Prisma.HandoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HandoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HandoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HandoutPayload>
          }
          aggregate: {
            args: Prisma.HandoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHandout>
          }
          groupBy: {
            args: Prisma.HandoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<HandoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.HandoutCountArgs<ExtArgs>
            result: $Utils.Optional<HandoutCountAggregateOutputType> | number
          }
        }
      }
      SessionNote: {
        payload: Prisma.$SessionNotePayload<ExtArgs>
        fields: Prisma.SessionNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionNotePayload>
          }
          findFirst: {
            args: Prisma.SessionNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionNotePayload>
          }
          findMany: {
            args: Prisma.SessionNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionNotePayload>[]
          }
          create: {
            args: Prisma.SessionNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionNotePayload>
          }
          createMany: {
            args: Prisma.SessionNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionNotePayload>[]
          }
          delete: {
            args: Prisma.SessionNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionNotePayload>
          }
          update: {
            args: Prisma.SessionNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionNotePayload>
          }
          deleteMany: {
            args: Prisma.SessionNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionNotePayload>
          }
          aggregate: {
            args: Prisma.SessionNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionNote>
          }
          groupBy: {
            args: Prisma.SessionNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionNoteCountArgs<ExtArgs>
            result: $Utils.Optional<SessionNoteCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ownedCampaigns: number
    campaignMembers: number
    characters: number
    diceRolls: number
    customContent: number
    sessionNotes: number
    handouts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedCampaigns?: boolean | UserCountOutputTypeCountOwnedCampaignsArgs
    campaignMembers?: boolean | UserCountOutputTypeCountCampaignMembersArgs
    characters?: boolean | UserCountOutputTypeCountCharactersArgs
    diceRolls?: boolean | UserCountOutputTypeCountDiceRollsArgs
    customContent?: boolean | UserCountOutputTypeCountCustomContentArgs
    sessionNotes?: boolean | UserCountOutputTypeCountSessionNotesArgs
    handouts?: boolean | UserCountOutputTypeCountHandoutsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCampaignMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDiceRollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiceRollWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCustomContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomContentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHandoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HandoutWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    members: number
    characters: number
    sessions: number
    diceRolls: number
    encounters: number
    starSystems: number
    starships: number
    customContent: number
    houseRulesData: number
    handouts: number
    sessionNotes: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | CampaignCountOutputTypeCountMembersArgs
    characters?: boolean | CampaignCountOutputTypeCountCharactersArgs
    sessions?: boolean | CampaignCountOutputTypeCountSessionsArgs
    diceRolls?: boolean | CampaignCountOutputTypeCountDiceRollsArgs
    encounters?: boolean | CampaignCountOutputTypeCountEncountersArgs
    starSystems?: boolean | CampaignCountOutputTypeCountStarSystemsArgs
    starships?: boolean | CampaignCountOutputTypeCountStarshipsArgs
    customContent?: boolean | CampaignCountOutputTypeCountCustomContentArgs
    houseRulesData?: boolean | CampaignCountOutputTypeCountHouseRulesDataArgs
    handouts?: boolean | CampaignCountOutputTypeCountHandoutsArgs
    sessionNotes?: boolean | CampaignCountOutputTypeCountSessionNotesArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignMemberWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountDiceRollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiceRollWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountStarSystemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StarSystemWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountStarshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StarshipWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountCustomContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomContentWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountHouseRulesDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HouseRuleWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountHandoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HandoutWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountSessionNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionNoteWhereInput
  }


  /**
   * Count Type CharacterCountOutputType
   */

  export type CharacterCountOutputType = {
    skills: number
    equipment: number
    lifeEvents: number
    combatActions: number
  }

  export type CharacterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | CharacterCountOutputTypeCountSkillsArgs
    equipment?: boolean | CharacterCountOutputTypeCountEquipmentArgs
    lifeEvents?: boolean | CharacterCountOutputTypeCountLifeEventsArgs
    combatActions?: boolean | CharacterCountOutputTypeCountCombatActionsArgs
  }

  // Custom InputTypes
  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterCountOutputType
     */
    select?: CharacterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterSkillWhereInput
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterEquipmentWhereInput
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountLifeEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LifeEventWhereInput
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountCombatActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CombatActionWhereInput
  }


  /**
   * Count Type StarSystemCountOutputType
   */

  export type StarSystemCountOutputType = {
    planets: number
    tradeRoutes: number
    tradeRoutesDestination: number
  }

  export type StarSystemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planets?: boolean | StarSystemCountOutputTypeCountPlanetsArgs
    tradeRoutes?: boolean | StarSystemCountOutputTypeCountTradeRoutesArgs
    tradeRoutesDestination?: boolean | StarSystemCountOutputTypeCountTradeRoutesDestinationArgs
  }

  // Custom InputTypes
  /**
   * StarSystemCountOutputType without action
   */
  export type StarSystemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StarSystemCountOutputType
     */
    select?: StarSystemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StarSystemCountOutputType without action
   */
  export type StarSystemCountOutputTypeCountPlanetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanetWhereInput
  }

  /**
   * StarSystemCountOutputType without action
   */
  export type StarSystemCountOutputTypeCountTradeRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeRouteWhereInput
  }

  /**
   * StarSystemCountOutputType without action
   */
  export type StarSystemCountOutputTypeCountTradeRoutesDestinationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeRouteWhereInput
  }


  /**
   * Count Type PlanetCountOutputType
   */

  export type PlanetCountOutputType = {
    tradeGoods: number
  }

  export type PlanetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tradeGoods?: boolean | PlanetCountOutputTypeCountTradeGoodsArgs
  }

  // Custom InputTypes
  /**
   * PlanetCountOutputType without action
   */
  export type PlanetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanetCountOutputType
     */
    select?: PlanetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanetCountOutputType without action
   */
  export type PlanetCountOutputTypeCountTradeGoodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeGoodWhereInput
  }


  /**
   * Count Type SessionCountOutputType
   */

  export type SessionCountOutputType = {
    encounters: number
    combatSessions: number
    sessionNotes: number
  }

  export type SessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounters?: boolean | SessionCountOutputTypeCountEncountersArgs
    combatSessions?: boolean | SessionCountOutputTypeCountCombatSessionsArgs
    sessionNotes?: boolean | SessionCountOutputTypeCountSessionNotesArgs
  }

  // Custom InputTypes
  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionCountOutputType
     */
    select?: SessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountCombatSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CombatSessionWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountSessionNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionNoteWhereInput
  }


  /**
   * Count Type EncounterCountOutputType
   */

  export type EncounterCountOutputType = {
    combatSessions: number
  }

  export type EncounterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    combatSessions?: boolean | EncounterCountOutputTypeCountCombatSessionsArgs
  }

  // Custom InputTypes
  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCountOutputType
     */
    select?: EncounterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountCombatSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CombatSessionWhereInput
  }


  /**
   * Count Type CombatSessionCountOutputType
   */

  export type CombatSessionCountOutputType = {
    actions: number
  }

  export type CombatSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actions?: boolean | CombatSessionCountOutputTypeCountActionsArgs
  }

  // Custom InputTypes
  /**
   * CombatSessionCountOutputType without action
   */
  export type CombatSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatSessionCountOutputType
     */
    select?: CombatSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CombatSessionCountOutputType without action
   */
  export type CombatSessionCountOutputTypeCountActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CombatActionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    displayName: string | null
    avatar: string | null
    timezone: string | null
    subscriptionTier: $Enums.SubscriptionTier | null
    cognitoUserId: string | null
    emailVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    displayName: string | null
    avatar: string | null
    timezone: string | null
    subscriptionTier: $Enums.SubscriptionTier | null
    cognitoUserId: string | null
    emailVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    displayName: number
    avatar: number
    timezone: number
    subscriptionTier: number
    cognitoUserId: number
    emailVerified: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    displayName?: true
    avatar?: true
    timezone?: true
    subscriptionTier?: true
    cognitoUserId?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    displayName?: true
    avatar?: true
    timezone?: true
    subscriptionTier?: true
    cognitoUserId?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    displayName?: true
    avatar?: true
    timezone?: true
    subscriptionTier?: true
    cognitoUserId?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    displayName: string | null
    avatar: string | null
    timezone: string
    subscriptionTier: $Enums.SubscriptionTier
    cognitoUserId: string
    emailVerified: boolean
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    displayName?: boolean
    avatar?: boolean
    timezone?: boolean
    subscriptionTier?: boolean
    cognitoUserId?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    ownedCampaigns?: boolean | User$ownedCampaignsArgs<ExtArgs>
    campaignMembers?: boolean | User$campaignMembersArgs<ExtArgs>
    characters?: boolean | User$charactersArgs<ExtArgs>
    diceRolls?: boolean | User$diceRollsArgs<ExtArgs>
    customContent?: boolean | User$customContentArgs<ExtArgs>
    sessionNotes?: boolean | User$sessionNotesArgs<ExtArgs>
    handouts?: boolean | User$handoutsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    displayName?: boolean
    avatar?: boolean
    timezone?: boolean
    subscriptionTier?: boolean
    cognitoUserId?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    displayName?: boolean
    avatar?: boolean
    timezone?: boolean
    subscriptionTier?: boolean
    cognitoUserId?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedCampaigns?: boolean | User$ownedCampaignsArgs<ExtArgs>
    campaignMembers?: boolean | User$campaignMembersArgs<ExtArgs>
    characters?: boolean | User$charactersArgs<ExtArgs>
    diceRolls?: boolean | User$diceRollsArgs<ExtArgs>
    customContent?: boolean | User$customContentArgs<ExtArgs>
    sessionNotes?: boolean | User$sessionNotesArgs<ExtArgs>
    handouts?: boolean | User$handoutsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      ownedCampaigns: Prisma.$CampaignPayload<ExtArgs>[]
      campaignMembers: Prisma.$CampaignMemberPayload<ExtArgs>[]
      characters: Prisma.$CharacterPayload<ExtArgs>[]
      diceRolls: Prisma.$DiceRollPayload<ExtArgs>[]
      customContent: Prisma.$CustomContentPayload<ExtArgs>[]
      sessionNotes: Prisma.$SessionNotePayload<ExtArgs>[]
      handouts: Prisma.$HandoutPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      displayName: string | null
      avatar: string | null
      timezone: string
      subscriptionTier: $Enums.SubscriptionTier
      cognitoUserId: string
      emailVerified: boolean
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ownedCampaigns<T extends User$ownedCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany"> | Null>
    campaignMembers<T extends User$campaignMembersArgs<ExtArgs> = {}>(args?: Subset<T, User$campaignMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMemberPayload<ExtArgs>, T, "findMany"> | Null>
    characters<T extends User$charactersArgs<ExtArgs> = {}>(args?: Subset<T, User$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany"> | Null>
    diceRolls<T extends User$diceRollsArgs<ExtArgs> = {}>(args?: Subset<T, User$diceRollsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiceRollPayload<ExtArgs>, T, "findMany"> | Null>
    customContent<T extends User$customContentArgs<ExtArgs> = {}>(args?: Subset<T, User$customContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomContentPayload<ExtArgs>, T, "findMany"> | Null>
    sessionNotes<T extends User$sessionNotesArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionNotePayload<ExtArgs>, T, "findMany"> | Null>
    handouts<T extends User$handoutsArgs<ExtArgs> = {}>(args?: Subset<T, User$handoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HandoutPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly timezone: FieldRef<"User", 'String'>
    readonly subscriptionTier: FieldRef<"User", 'SubscriptionTier'>
    readonly cognitoUserId: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.ownedCampaigns
   */
  export type User$ownedCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * User.campaignMembers
   */
  export type User$campaignMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMember
     */
    select?: CampaignMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMemberInclude<ExtArgs> | null
    where?: CampaignMemberWhereInput
    orderBy?: CampaignMemberOrderByWithRelationInput | CampaignMemberOrderByWithRelationInput[]
    cursor?: CampaignMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignMemberScalarFieldEnum | CampaignMemberScalarFieldEnum[]
  }

  /**
   * User.characters
   */
  export type User$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * User.diceRolls
   */
  export type User$diceRollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiceRoll
     */
    select?: DiceRollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiceRollInclude<ExtArgs> | null
    where?: DiceRollWhereInput
    orderBy?: DiceRollOrderByWithRelationInput | DiceRollOrderByWithRelationInput[]
    cursor?: DiceRollWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiceRollScalarFieldEnum | DiceRollScalarFieldEnum[]
  }

  /**
   * User.customContent
   */
  export type User$customContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomContent
     */
    select?: CustomContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomContentInclude<ExtArgs> | null
    where?: CustomContentWhereInput
    orderBy?: CustomContentOrderByWithRelationInput | CustomContentOrderByWithRelationInput[]
    cursor?: CustomContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomContentScalarFieldEnum | CustomContentScalarFieldEnum[]
  }

  /**
   * User.sessionNotes
   */
  export type User$sessionNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionNote
     */
    select?: SessionNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionNoteInclude<ExtArgs> | null
    where?: SessionNoteWhereInput
    orderBy?: SessionNoteOrderByWithRelationInput | SessionNoteOrderByWithRelationInput[]
    cursor?: SessionNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionNoteScalarFieldEnum | SessionNoteScalarFieldEnum[]
  }

  /**
   * User.handouts
   */
  export type User$handoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Handout
     */
    select?: HandoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoutInclude<ExtArgs> | null
    where?: HandoutWhereInput
    orderBy?: HandoutOrderByWithRelationInput | HandoutOrderByWithRelationInput[]
    cursor?: HandoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HandoutScalarFieldEnum | HandoutScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    maxPlayers: number | null
  }

  export type CampaignSumAggregateOutputType = {
    maxPlayers: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    maxPlayers: number | null
    isPublic: boolean | null
    gamemasterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    maxPlayers: number | null
    isPublic: boolean | null
    gamemasterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    description: number
    maxPlayers: number
    isPublic: number
    allowedBooks: number
    houseRules: number
    gamemasterId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    maxPlayers?: true
  }

  export type CampaignSumAggregateInputType = {
    maxPlayers?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    maxPlayers?: true
    isPublic?: true
    gamemasterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    maxPlayers?: true
    isPublic?: true
    gamemasterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    maxPlayers?: true
    isPublic?: true
    allowedBooks?: true
    houseRules?: true
    gamemasterId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    name: string
    description: string | null
    maxPlayers: number | null
    isPublic: boolean
    allowedBooks: string[]
    houseRules: JsonValue | null
    gamemasterId: string
    createdAt: Date
    updatedAt: Date
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    maxPlayers?: boolean
    isPublic?: boolean
    allowedBooks?: boolean
    houseRules?: boolean
    gamemasterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gamemaster?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Campaign$membersArgs<ExtArgs>
    characters?: boolean | Campaign$charactersArgs<ExtArgs>
    sessions?: boolean | Campaign$sessionsArgs<ExtArgs>
    diceRolls?: boolean | Campaign$diceRollsArgs<ExtArgs>
    encounters?: boolean | Campaign$encountersArgs<ExtArgs>
    starSystems?: boolean | Campaign$starSystemsArgs<ExtArgs>
    starships?: boolean | Campaign$starshipsArgs<ExtArgs>
    customContent?: boolean | Campaign$customContentArgs<ExtArgs>
    houseRulesData?: boolean | Campaign$houseRulesDataArgs<ExtArgs>
    handouts?: boolean | Campaign$handoutsArgs<ExtArgs>
    sessionNotes?: boolean | Campaign$sessionNotesArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    maxPlayers?: boolean
    isPublic?: boolean
    allowedBooks?: boolean
    houseRules?: boolean
    gamemasterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    gamemaster?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    maxPlayers?: boolean
    isPublic?: boolean
    allowedBooks?: boolean
    houseRules?: boolean
    gamemasterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamemaster?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Campaign$membersArgs<ExtArgs>
    characters?: boolean | Campaign$charactersArgs<ExtArgs>
    sessions?: boolean | Campaign$sessionsArgs<ExtArgs>
    diceRolls?: boolean | Campaign$diceRollsArgs<ExtArgs>
    encounters?: boolean | Campaign$encountersArgs<ExtArgs>
    starSystems?: boolean | Campaign$starSystemsArgs<ExtArgs>
    starships?: boolean | Campaign$starshipsArgs<ExtArgs>
    customContent?: boolean | Campaign$customContentArgs<ExtArgs>
    houseRulesData?: boolean | Campaign$houseRulesDataArgs<ExtArgs>
    handouts?: boolean | Campaign$handoutsArgs<ExtArgs>
    sessionNotes?: boolean | Campaign$sessionNotesArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    gamemaster?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      gamemaster: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$CampaignMemberPayload<ExtArgs>[]
      characters: Prisma.$CharacterPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      diceRolls: Prisma.$DiceRollPayload<ExtArgs>[]
      encounters: Prisma.$EncounterPayload<ExtArgs>[]
      starSystems: Prisma.$StarSystemPayload<ExtArgs>[]
      starships: Prisma.$StarshipPayload<ExtArgs>[]
      customContent: Prisma.$CustomContentPayload<ExtArgs>[]
      houseRulesData: Prisma.$HouseRulePayload<ExtArgs>[]
      handouts: Prisma.$HandoutPayload<ExtArgs>[]
      sessionNotes: Prisma.$SessionNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      maxPlayers: number | null
      isPublic: boolean
      allowedBooks: string[]
      houseRules: Prisma.JsonValue | null
      gamemasterId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    gamemaster<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    members<T extends Campaign$membersArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMemberPayload<ExtArgs>, T, "findMany"> | Null>
    characters<T extends Campaign$charactersArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends Campaign$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    diceRolls<T extends Campaign$diceRollsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$diceRollsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiceRollPayload<ExtArgs>, T, "findMany"> | Null>
    encounters<T extends Campaign$encountersArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany"> | Null>
    starSystems<T extends Campaign$starSystemsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$starSystemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StarSystemPayload<ExtArgs>, T, "findMany"> | Null>
    starships<T extends Campaign$starshipsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$starshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StarshipPayload<ExtArgs>, T, "findMany"> | Null>
    customContent<T extends Campaign$customContentArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$customContentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomContentPayload<ExtArgs>, T, "findMany"> | Null>
    houseRulesData<T extends Campaign$houseRulesDataArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$houseRulesDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HouseRulePayload<ExtArgs>, T, "findMany"> | Null>
    handouts<T extends Campaign$handoutsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$handoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HandoutPayload<ExtArgs>, T, "findMany"> | Null>
    sessionNotes<T extends Campaign$sessionNotesArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$sessionNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionNotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */ 
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly description: FieldRef<"Campaign", 'String'>
    readonly maxPlayers: FieldRef<"Campaign", 'Int'>
    readonly isPublic: FieldRef<"Campaign", 'Boolean'>
    readonly allowedBooks: FieldRef<"Campaign", 'String[]'>
    readonly houseRules: FieldRef<"Campaign", 'Json'>
    readonly gamemasterId: FieldRef<"Campaign", 'String'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign.members
   */
  export type Campaign$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMember
     */
    select?: CampaignMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMemberInclude<ExtArgs> | null
    where?: CampaignMemberWhereInput
    orderBy?: CampaignMemberOrderByWithRelationInput | CampaignMemberOrderByWithRelationInput[]
    cursor?: CampaignMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignMemberScalarFieldEnum | CampaignMemberScalarFieldEnum[]
  }

  /**
   * Campaign.characters
   */
  export type Campaign$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Campaign.sessions
   */
  export type Campaign$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Campaign.diceRolls
   */
  export type Campaign$diceRollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiceRoll
     */
    select?: DiceRollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiceRollInclude<ExtArgs> | null
    where?: DiceRollWhereInput
    orderBy?: DiceRollOrderByWithRelationInput | DiceRollOrderByWithRelationInput[]
    cursor?: DiceRollWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiceRollScalarFieldEnum | DiceRollScalarFieldEnum[]
  }

  /**
   * Campaign.encounters
   */
  export type Campaign$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Campaign.starSystems
   */
  export type Campaign$starSystemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StarSystem
     */
    select?: StarSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarSystemInclude<ExtArgs> | null
    where?: StarSystemWhereInput
    orderBy?: StarSystemOrderByWithRelationInput | StarSystemOrderByWithRelationInput[]
    cursor?: StarSystemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StarSystemScalarFieldEnum | StarSystemScalarFieldEnum[]
  }

  /**
   * Campaign.starships
   */
  export type Campaign$starshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Starship
     */
    select?: StarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarshipInclude<ExtArgs> | null
    where?: StarshipWhereInput
    orderBy?: StarshipOrderByWithRelationInput | StarshipOrderByWithRelationInput[]
    cursor?: StarshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StarshipScalarFieldEnum | StarshipScalarFieldEnum[]
  }

  /**
   * Campaign.customContent
   */
  export type Campaign$customContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomContent
     */
    select?: CustomContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomContentInclude<ExtArgs> | null
    where?: CustomContentWhereInput
    orderBy?: CustomContentOrderByWithRelationInput | CustomContentOrderByWithRelationInput[]
    cursor?: CustomContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomContentScalarFieldEnum | CustomContentScalarFieldEnum[]
  }

  /**
   * Campaign.houseRulesData
   */
  export type Campaign$houseRulesDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseRule
     */
    select?: HouseRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseRuleInclude<ExtArgs> | null
    where?: HouseRuleWhereInput
    orderBy?: HouseRuleOrderByWithRelationInput | HouseRuleOrderByWithRelationInput[]
    cursor?: HouseRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HouseRuleScalarFieldEnum | HouseRuleScalarFieldEnum[]
  }

  /**
   * Campaign.handouts
   */
  export type Campaign$handoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Handout
     */
    select?: HandoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoutInclude<ExtArgs> | null
    where?: HandoutWhereInput
    orderBy?: HandoutOrderByWithRelationInput | HandoutOrderByWithRelationInput[]
    cursor?: HandoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HandoutScalarFieldEnum | HandoutScalarFieldEnum[]
  }

  /**
   * Campaign.sessionNotes
   */
  export type Campaign$sessionNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionNote
     */
    select?: SessionNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionNoteInclude<ExtArgs> | null
    where?: SessionNoteWhereInput
    orderBy?: SessionNoteOrderByWithRelationInput | SessionNoteOrderByWithRelationInput[]
    cursor?: SessionNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionNoteScalarFieldEnum | SessionNoteScalarFieldEnum[]
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model CampaignMember
   */

  export type AggregateCampaignMember = {
    _count: CampaignMemberCountAggregateOutputType | null
    _min: CampaignMemberMinAggregateOutputType | null
    _max: CampaignMemberMaxAggregateOutputType | null
  }

  export type CampaignMemberMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    userId: string | null
    role: $Enums.CampaignRole | null
    isActive: boolean | null
    joinedAt: Date | null
  }

  export type CampaignMemberMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    userId: string | null
    role: $Enums.CampaignRole | null
    isActive: boolean | null
    joinedAt: Date | null
  }

  export type CampaignMemberCountAggregateOutputType = {
    id: number
    campaignId: number
    userId: number
    role: number
    isActive: number
    joinedAt: number
    _all: number
  }


  export type CampaignMemberMinAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    role?: true
    isActive?: true
    joinedAt?: true
  }

  export type CampaignMemberMaxAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    role?: true
    isActive?: true
    joinedAt?: true
  }

  export type CampaignMemberCountAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    role?: true
    isActive?: true
    joinedAt?: true
    _all?: true
  }

  export type CampaignMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignMember to aggregate.
     */
    where?: CampaignMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMembers to fetch.
     */
    orderBy?: CampaignMemberOrderByWithRelationInput | CampaignMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignMembers
    **/
    _count?: true | CampaignMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMemberMaxAggregateInputType
  }

  export type GetCampaignMemberAggregateType<T extends CampaignMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignMember[P]>
      : GetScalarType<T[P], AggregateCampaignMember[P]>
  }




  export type CampaignMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignMemberWhereInput
    orderBy?: CampaignMemberOrderByWithAggregationInput | CampaignMemberOrderByWithAggregationInput[]
    by: CampaignMemberScalarFieldEnum[] | CampaignMemberScalarFieldEnum
    having?: CampaignMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignMemberCountAggregateInputType | true
    _min?: CampaignMemberMinAggregateInputType
    _max?: CampaignMemberMaxAggregateInputType
  }

  export type CampaignMemberGroupByOutputType = {
    id: string
    campaignId: string
    userId: string
    role: $Enums.CampaignRole
    isActive: boolean
    joinedAt: Date
    _count: CampaignMemberCountAggregateOutputType | null
    _min: CampaignMemberMinAggregateOutputType | null
    _max: CampaignMemberMaxAggregateOutputType | null
  }

  type GetCampaignMemberGroupByPayload<T extends CampaignMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignMemberGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignMemberGroupByOutputType[P]>
        }
      >
    >


  export type CampaignMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    role?: boolean
    isActive?: boolean
    joinedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignMember"]>

  export type CampaignMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    role?: boolean
    isActive?: boolean
    joinedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignMember"]>

  export type CampaignMemberSelectScalar = {
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    role?: boolean
    isActive?: boolean
    joinedAt?: boolean
  }

  export type CampaignMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CampaignMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CampaignMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignMember"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      userId: string
      role: $Enums.CampaignRole
      isActive: boolean
      joinedAt: Date
    }, ExtArgs["result"]["campaignMember"]>
    composites: {}
  }

  type CampaignMemberGetPayload<S extends boolean | null | undefined | CampaignMemberDefaultArgs> = $Result.GetResult<Prisma.$CampaignMemberPayload, S>

  type CampaignMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignMemberCountAggregateInputType | true
    }

  export interface CampaignMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignMember'], meta: { name: 'CampaignMember' } }
    /**
     * Find zero or one CampaignMember that matches the filter.
     * @param {CampaignMemberFindUniqueArgs} args - Arguments to find a CampaignMember
     * @example
     * // Get one CampaignMember
     * const campaignMember = await prisma.campaignMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignMemberFindUniqueArgs>(args: SelectSubset<T, CampaignMemberFindUniqueArgs<ExtArgs>>): Prisma__CampaignMemberClient<$Result.GetResult<Prisma.$CampaignMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignMemberFindUniqueOrThrowArgs} args - Arguments to find a CampaignMember
     * @example
     * // Get one CampaignMember
     * const campaignMember = await prisma.campaignMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignMemberClient<$Result.GetResult<Prisma.$CampaignMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMemberFindFirstArgs} args - Arguments to find a CampaignMember
     * @example
     * // Get one CampaignMember
     * const campaignMember = await prisma.campaignMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignMemberFindFirstArgs>(args?: SelectSubset<T, CampaignMemberFindFirstArgs<ExtArgs>>): Prisma__CampaignMemberClient<$Result.GetResult<Prisma.$CampaignMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMemberFindFirstOrThrowArgs} args - Arguments to find a CampaignMember
     * @example
     * // Get one CampaignMember
     * const campaignMember = await prisma.campaignMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignMemberClient<$Result.GetResult<Prisma.$CampaignMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignMembers
     * const campaignMembers = await prisma.campaignMember.findMany()
     * 
     * // Get first 10 CampaignMembers
     * const campaignMembers = await prisma.campaignMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignMemberWithIdOnly = await prisma.campaignMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignMemberFindManyArgs>(args?: SelectSubset<T, CampaignMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignMember.
     * @param {CampaignMemberCreateArgs} args - Arguments to create a CampaignMember.
     * @example
     * // Create one CampaignMember
     * const CampaignMember = await prisma.campaignMember.create({
     *   data: {
     *     // ... data to create a CampaignMember
     *   }
     * })
     * 
     */
    create<T extends CampaignMemberCreateArgs>(args: SelectSubset<T, CampaignMemberCreateArgs<ExtArgs>>): Prisma__CampaignMemberClient<$Result.GetResult<Prisma.$CampaignMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignMembers.
     * @param {CampaignMemberCreateManyArgs} args - Arguments to create many CampaignMembers.
     * @example
     * // Create many CampaignMembers
     * const campaignMember = await prisma.campaignMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignMemberCreateManyArgs>(args?: SelectSubset<T, CampaignMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignMembers and returns the data saved in the database.
     * @param {CampaignMemberCreateManyAndReturnArgs} args - Arguments to create many CampaignMembers.
     * @example
     * // Create many CampaignMembers
     * const campaignMember = await prisma.campaignMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignMembers and only return the `id`
     * const campaignMemberWithIdOnly = await prisma.campaignMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignMember.
     * @param {CampaignMemberDeleteArgs} args - Arguments to delete one CampaignMember.
     * @example
     * // Delete one CampaignMember
     * const CampaignMember = await prisma.campaignMember.delete({
     *   where: {
     *     // ... filter to delete one CampaignMember
     *   }
     * })
     * 
     */
    delete<T extends CampaignMemberDeleteArgs>(args: SelectSubset<T, CampaignMemberDeleteArgs<ExtArgs>>): Prisma__CampaignMemberClient<$Result.GetResult<Prisma.$CampaignMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignMember.
     * @param {CampaignMemberUpdateArgs} args - Arguments to update one CampaignMember.
     * @example
     * // Update one CampaignMember
     * const campaignMember = await prisma.campaignMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignMemberUpdateArgs>(args: SelectSubset<T, CampaignMemberUpdateArgs<ExtArgs>>): Prisma__CampaignMemberClient<$Result.GetResult<Prisma.$CampaignMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignMembers.
     * @param {CampaignMemberDeleteManyArgs} args - Arguments to filter CampaignMembers to delete.
     * @example
     * // Delete a few CampaignMembers
     * const { count } = await prisma.campaignMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignMemberDeleteManyArgs>(args?: SelectSubset<T, CampaignMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignMembers
     * const campaignMember = await prisma.campaignMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignMemberUpdateManyArgs>(args: SelectSubset<T, CampaignMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignMember.
     * @param {CampaignMemberUpsertArgs} args - Arguments to update or create a CampaignMember.
     * @example
     * // Update or create a CampaignMember
     * const campaignMember = await prisma.campaignMember.upsert({
     *   create: {
     *     // ... data to create a CampaignMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignMember we want to update
     *   }
     * })
     */
    upsert<T extends CampaignMemberUpsertArgs>(args: SelectSubset<T, CampaignMemberUpsertArgs<ExtArgs>>): Prisma__CampaignMemberClient<$Result.GetResult<Prisma.$CampaignMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMemberCountArgs} args - Arguments to filter CampaignMembers to count.
     * @example
     * // Count the number of CampaignMembers
     * const count = await prisma.campaignMember.count({
     *   where: {
     *     // ... the filter for the CampaignMembers we want to count
     *   }
     * })
    **/
    count<T extends CampaignMemberCountArgs>(
      args?: Subset<T, CampaignMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignMemberAggregateArgs>(args: Subset<T, CampaignMemberAggregateArgs>): Prisma.PrismaPromise<GetCampaignMemberAggregateType<T>>

    /**
     * Group by CampaignMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignMemberGroupByArgs['orderBy'] }
        : { orderBy?: CampaignMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignMember model
   */
  readonly fields: CampaignMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignMember model
   */ 
  interface CampaignMemberFieldRefs {
    readonly id: FieldRef<"CampaignMember", 'String'>
    readonly campaignId: FieldRef<"CampaignMember", 'String'>
    readonly userId: FieldRef<"CampaignMember", 'String'>
    readonly role: FieldRef<"CampaignMember", 'CampaignRole'>
    readonly isActive: FieldRef<"CampaignMember", 'Boolean'>
    readonly joinedAt: FieldRef<"CampaignMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignMember findUnique
   */
  export type CampaignMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMember
     */
    select?: CampaignMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMemberInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMember to fetch.
     */
    where: CampaignMemberWhereUniqueInput
  }

  /**
   * CampaignMember findUniqueOrThrow
   */
  export type CampaignMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMember
     */
    select?: CampaignMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMemberInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMember to fetch.
     */
    where: CampaignMemberWhereUniqueInput
  }

  /**
   * CampaignMember findFirst
   */
  export type CampaignMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMember
     */
    select?: CampaignMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMemberInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMember to fetch.
     */
    where?: CampaignMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMembers to fetch.
     */
    orderBy?: CampaignMemberOrderByWithRelationInput | CampaignMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignMembers.
     */
    cursor?: CampaignMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignMembers.
     */
    distinct?: CampaignMemberScalarFieldEnum | CampaignMemberScalarFieldEnum[]
  }

  /**
   * CampaignMember findFirstOrThrow
   */
  export type CampaignMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMember
     */
    select?: CampaignMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMemberInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMember to fetch.
     */
    where?: CampaignMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMembers to fetch.
     */
    orderBy?: CampaignMemberOrderByWithRelationInput | CampaignMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignMembers.
     */
    cursor?: CampaignMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignMembers.
     */
    distinct?: CampaignMemberScalarFieldEnum | CampaignMemberScalarFieldEnum[]
  }

  /**
   * CampaignMember findMany
   */
  export type CampaignMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMember
     */
    select?: CampaignMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMemberInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMembers to fetch.
     */
    where?: CampaignMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMembers to fetch.
     */
    orderBy?: CampaignMemberOrderByWithRelationInput | CampaignMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignMembers.
     */
    cursor?: CampaignMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMembers.
     */
    skip?: number
    distinct?: CampaignMemberScalarFieldEnum | CampaignMemberScalarFieldEnum[]
  }

  /**
   * CampaignMember create
   */
  export type CampaignMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMember
     */
    select?: CampaignMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignMember.
     */
    data: XOR<CampaignMemberCreateInput, CampaignMemberUncheckedCreateInput>
  }

  /**
   * CampaignMember createMany
   */
  export type CampaignMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignMembers.
     */
    data: CampaignMemberCreateManyInput | CampaignMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignMember createManyAndReturn
   */
  export type CampaignMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMember
     */
    select?: CampaignMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignMembers.
     */
    data: CampaignMemberCreateManyInput | CampaignMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignMember update
   */
  export type CampaignMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMember
     */
    select?: CampaignMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignMember.
     */
    data: XOR<CampaignMemberUpdateInput, CampaignMemberUncheckedUpdateInput>
    /**
     * Choose, which CampaignMember to update.
     */
    where: CampaignMemberWhereUniqueInput
  }

  /**
   * CampaignMember updateMany
   */
  export type CampaignMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignMembers.
     */
    data: XOR<CampaignMemberUpdateManyMutationInput, CampaignMemberUncheckedUpdateManyInput>
    /**
     * Filter which CampaignMembers to update
     */
    where?: CampaignMemberWhereInput
  }

  /**
   * CampaignMember upsert
   */
  export type CampaignMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMember
     */
    select?: CampaignMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignMember to update in case it exists.
     */
    where: CampaignMemberWhereUniqueInput
    /**
     * In case the CampaignMember found by the `where` argument doesn't exist, create a new CampaignMember with this data.
     */
    create: XOR<CampaignMemberCreateInput, CampaignMemberUncheckedCreateInput>
    /**
     * In case the CampaignMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignMemberUpdateInput, CampaignMemberUncheckedUpdateInput>
  }

  /**
   * CampaignMember delete
   */
  export type CampaignMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMember
     */
    select?: CampaignMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMemberInclude<ExtArgs> | null
    /**
     * Filter which CampaignMember to delete.
     */
    where: CampaignMemberWhereUniqueInput
  }

  /**
   * CampaignMember deleteMany
   */
  export type CampaignMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignMembers to delete
     */
    where?: CampaignMemberWhereInput
  }

  /**
   * CampaignMember without action
   */
  export type CampaignMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMember
     */
    select?: CampaignMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMemberInclude<ExtArgs> | null
  }


  /**
   * Model Character
   */

  export type AggregateCharacter = {
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  export type CharacterAvgAggregateOutputType = {
    credits: number | null
    age: number | null
  }

  export type CharacterSumAggregateOutputType = {
    credits: number | null
    age: number | null
  }

  export type CharacterMinAggregateOutputType = {
    id: string | null
    name: string | null
    credits: number | null
    notes: string | null
    portrait: string | null
    homeworld: string | null
    age: number | null
    gender: string | null
    species: string | null
    playerId: string | null
    campaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    credits: number | null
    notes: string | null
    portrait: string | null
    homeworld: string | null
    age: number | null
    gender: string | null
    species: string | null
    playerId: string | null
    campaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterCountAggregateOutputType = {
    id: number
    name: number
    credits: number
    notes: number
    portrait: number
    homeworld: number
    age: number
    gender: number
    species: number
    playerId: number
    campaignId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CharacterAvgAggregateInputType = {
    credits?: true
    age?: true
  }

  export type CharacterSumAggregateInputType = {
    credits?: true
    age?: true
  }

  export type CharacterMinAggregateInputType = {
    id?: true
    name?: true
    credits?: true
    notes?: true
    portrait?: true
    homeworld?: true
    age?: true
    gender?: true
    species?: true
    playerId?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterMaxAggregateInputType = {
    id?: true
    name?: true
    credits?: true
    notes?: true
    portrait?: true
    homeworld?: true
    age?: true
    gender?: true
    species?: true
    playerId?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterCountAggregateInputType = {
    id?: true
    name?: true
    credits?: true
    notes?: true
    portrait?: true
    homeworld?: true
    age?: true
    gender?: true
    species?: true
    playerId?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CharacterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Character to aggregate.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Characters
    **/
    _count?: true | CharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterMaxAggregateInputType
  }

  export type GetCharacterAggregateType<T extends CharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter[P]>
      : GetScalarType<T[P], AggregateCharacter[P]>
  }




  export type CharacterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithAggregationInput | CharacterOrderByWithAggregationInput[]
    by: CharacterScalarFieldEnum[] | CharacterScalarFieldEnum
    having?: CharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterCountAggregateInputType | true
    _avg?: CharacterAvgAggregateInputType
    _sum?: CharacterSumAggregateInputType
    _min?: CharacterMinAggregateInputType
    _max?: CharacterMaxAggregateInputType
  }

  export type CharacterGroupByOutputType = {
    id: string
    name: string
    credits: number
    notes: string | null
    portrait: string | null
    homeworld: string | null
    age: number | null
    gender: string | null
    species: string | null
    playerId: string
    campaignId: string
    createdAt: Date
    updatedAt: Date
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  type GetCharacterGroupByPayload<T extends CharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterGroupByOutputType[P]>
        }
      >
    >


  export type CharacterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    credits?: boolean
    notes?: boolean
    portrait?: boolean
    homeworld?: boolean
    age?: boolean
    gender?: boolean
    species?: boolean
    playerId?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    characteristics?: boolean | Character$characteristicsArgs<ExtArgs>
    skills?: boolean | Character$skillsArgs<ExtArgs>
    equipment?: boolean | Character$equipmentArgs<ExtArgs>
    lifeEvents?: boolean | Character$lifeEventsArgs<ExtArgs>
    combatActions?: boolean | Character$combatActionsArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    credits?: boolean
    notes?: boolean
    portrait?: boolean
    homeworld?: boolean
    age?: boolean
    gender?: boolean
    species?: boolean
    playerId?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    player?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectScalar = {
    id?: boolean
    name?: boolean
    credits?: boolean
    notes?: boolean
    portrait?: boolean
    homeworld?: boolean
    age?: boolean
    gender?: boolean
    species?: boolean
    playerId?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CharacterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    characteristics?: boolean | Character$characteristicsArgs<ExtArgs>
    skills?: boolean | Character$skillsArgs<ExtArgs>
    equipment?: boolean | Character$equipmentArgs<ExtArgs>
    lifeEvents?: boolean | Character$lifeEventsArgs<ExtArgs>
    combatActions?: boolean | Character$combatActionsArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CharacterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CharacterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Character"
    objects: {
      player: Prisma.$UserPayload<ExtArgs>
      campaign: Prisma.$CampaignPayload<ExtArgs>
      characteristics: Prisma.$CharacteristicsPayload<ExtArgs> | null
      skills: Prisma.$CharacterSkillPayload<ExtArgs>[]
      equipment: Prisma.$CharacterEquipmentPayload<ExtArgs>[]
      lifeEvents: Prisma.$LifeEventPayload<ExtArgs>[]
      combatActions: Prisma.$CombatActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      credits: number
      notes: string | null
      portrait: string | null
      homeworld: string | null
      age: number | null
      gender: string | null
      species: string | null
      playerId: string
      campaignId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["character"]>
    composites: {}
  }

  type CharacterGetPayload<S extends boolean | null | undefined | CharacterDefaultArgs> = $Result.GetResult<Prisma.$CharacterPayload, S>

  type CharacterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CharacterCountAggregateInputType | true
    }

  export interface CharacterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Character'], meta: { name: 'Character' } }
    /**
     * Find zero or one Character that matches the filter.
     * @param {CharacterFindUniqueArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterFindUniqueArgs>(args: SelectSubset<T, CharacterFindUniqueArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Character that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CharacterFindUniqueOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Character that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterFindFirstArgs>(args?: SelectSubset<T, CharacterFindFirstArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Character that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characters
     * const characters = await prisma.character.findMany()
     * 
     * // Get first 10 Characters
     * const characters = await prisma.character.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterWithIdOnly = await prisma.character.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterFindManyArgs>(args?: SelectSubset<T, CharacterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Character.
     * @param {CharacterCreateArgs} args - Arguments to create a Character.
     * @example
     * // Create one Character
     * const Character = await prisma.character.create({
     *   data: {
     *     // ... data to create a Character
     *   }
     * })
     * 
     */
    create<T extends CharacterCreateArgs>(args: SelectSubset<T, CharacterCreateArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Characters.
     * @param {CharacterCreateManyArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const character = await prisma.character.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterCreateManyArgs>(args?: SelectSubset<T, CharacterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Characters and returns the data saved in the database.
     * @param {CharacterCreateManyAndReturnArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const character = await prisma.character.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Characters and only return the `id`
     * const characterWithIdOnly = await prisma.character.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Character.
     * @param {CharacterDeleteArgs} args - Arguments to delete one Character.
     * @example
     * // Delete one Character
     * const Character = await prisma.character.delete({
     *   where: {
     *     // ... filter to delete one Character
     *   }
     * })
     * 
     */
    delete<T extends CharacterDeleteArgs>(args: SelectSubset<T, CharacterDeleteArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Character.
     * @param {CharacterUpdateArgs} args - Arguments to update one Character.
     * @example
     * // Update one Character
     * const character = await prisma.character.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterUpdateArgs>(args: SelectSubset<T, CharacterUpdateArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Characters.
     * @param {CharacterDeleteManyArgs} args - Arguments to filter Characters to delete.
     * @example
     * // Delete a few Characters
     * const { count } = await prisma.character.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterDeleteManyArgs>(args?: SelectSubset<T, CharacterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterUpdateManyArgs>(args: SelectSubset<T, CharacterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Character.
     * @param {CharacterUpsertArgs} args - Arguments to update or create a Character.
     * @example
     * // Update or create a Character
     * const character = await prisma.character.upsert({
     *   create: {
     *     // ... data to create a Character
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character we want to update
     *   }
     * })
     */
    upsert<T extends CharacterUpsertArgs>(args: SelectSubset<T, CharacterUpsertArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterCountArgs} args - Arguments to filter Characters to count.
     * @example
     * // Count the number of Characters
     * const count = await prisma.character.count({
     *   where: {
     *     // ... the filter for the Characters we want to count
     *   }
     * })
    **/
    count<T extends CharacterCountArgs>(
      args?: Subset<T, CharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterAggregateArgs>(args: Subset<T, CharacterAggregateArgs>): Prisma.PrismaPromise<GetCharacterAggregateType<T>>

    /**
     * Group by Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterGroupByArgs['orderBy'] }
        : { orderBy?: CharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Character model
   */
  readonly fields: CharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Character.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    characteristics<T extends Character$characteristicsArgs<ExtArgs> = {}>(args?: Subset<T, Character$characteristicsArgs<ExtArgs>>): Prisma__CharacteristicsClient<$Result.GetResult<Prisma.$CharacteristicsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    skills<T extends Character$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Character$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "findMany"> | Null>
    equipment<T extends Character$equipmentArgs<ExtArgs> = {}>(args?: Subset<T, Character$equipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, "findMany"> | Null>
    lifeEvents<T extends Character$lifeEventsArgs<ExtArgs> = {}>(args?: Subset<T, Character$lifeEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LifeEventPayload<ExtArgs>, T, "findMany"> | Null>
    combatActions<T extends Character$combatActionsArgs<ExtArgs> = {}>(args?: Subset<T, Character$combatActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombatActionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Character model
   */ 
  interface CharacterFieldRefs {
    readonly id: FieldRef<"Character", 'String'>
    readonly name: FieldRef<"Character", 'String'>
    readonly credits: FieldRef<"Character", 'Int'>
    readonly notes: FieldRef<"Character", 'String'>
    readonly portrait: FieldRef<"Character", 'String'>
    readonly homeworld: FieldRef<"Character", 'String'>
    readonly age: FieldRef<"Character", 'Int'>
    readonly gender: FieldRef<"Character", 'String'>
    readonly species: FieldRef<"Character", 'String'>
    readonly playerId: FieldRef<"Character", 'String'>
    readonly campaignId: FieldRef<"Character", 'String'>
    readonly createdAt: FieldRef<"Character", 'DateTime'>
    readonly updatedAt: FieldRef<"Character", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Character findUnique
   */
  export type CharacterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character findUniqueOrThrow
   */
  export type CharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character findFirst
   */
  export type CharacterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character findFirstOrThrow
   */
  export type CharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character findMany
   */
  export type CharacterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Characters to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character create
   */
  export type CharacterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to create a Character.
     */
    data: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
  }

  /**
   * Character createMany
   */
  export type CharacterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Character createManyAndReturn
   */
  export type CharacterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Character update
   */
  export type CharacterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to update a Character.
     */
    data: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
    /**
     * Choose, which Character to update.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character updateMany
   */
  export type CharacterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Characters.
     */
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharacterWhereInput
  }

  /**
   * Character upsert
   */
  export type CharacterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The filter to search for the Character to update in case it exists.
     */
    where: CharacterWhereUniqueInput
    /**
     * In case the Character found by the `where` argument doesn't exist, create a new Character with this data.
     */
    create: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
    /**
     * In case the Character was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
  }

  /**
   * Character delete
   */
  export type CharacterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter which Character to delete.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character deleteMany
   */
  export type CharacterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characters to delete
     */
    where?: CharacterWhereInput
  }

  /**
   * Character.characteristics
   */
  export type Character$characteristicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristics
     */
    select?: CharacteristicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicsInclude<ExtArgs> | null
    where?: CharacteristicsWhereInput
  }

  /**
   * Character.skills
   */
  export type Character$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    where?: CharacterSkillWhereInput
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    cursor?: CharacterSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterSkillScalarFieldEnum | CharacterSkillScalarFieldEnum[]
  }

  /**
   * Character.equipment
   */
  export type Character$equipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    where?: CharacterEquipmentWhereInput
    orderBy?: CharacterEquipmentOrderByWithRelationInput | CharacterEquipmentOrderByWithRelationInput[]
    cursor?: CharacterEquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterEquipmentScalarFieldEnum | CharacterEquipmentScalarFieldEnum[]
  }

  /**
   * Character.lifeEvents
   */
  export type Character$lifeEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeEvent
     */
    select?: LifeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeEventInclude<ExtArgs> | null
    where?: LifeEventWhereInput
    orderBy?: LifeEventOrderByWithRelationInput | LifeEventOrderByWithRelationInput[]
    cursor?: LifeEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LifeEventScalarFieldEnum | LifeEventScalarFieldEnum[]
  }

  /**
   * Character.combatActions
   */
  export type Character$combatActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatAction
     */
    select?: CombatActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatActionInclude<ExtArgs> | null
    where?: CombatActionWhereInput
    orderBy?: CombatActionOrderByWithRelationInput | CombatActionOrderByWithRelationInput[]
    cursor?: CombatActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CombatActionScalarFieldEnum | CombatActionScalarFieldEnum[]
  }

  /**
   * Character without action
   */
  export type CharacterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
  }


  /**
   * Model Characteristics
   */

  export type AggregateCharacteristics = {
    _count: CharacteristicsCountAggregateOutputType | null
    _avg: CharacteristicsAvgAggregateOutputType | null
    _sum: CharacteristicsSumAggregateOutputType | null
    _min: CharacteristicsMinAggregateOutputType | null
    _max: CharacteristicsMaxAggregateOutputType | null
  }

  export type CharacteristicsAvgAggregateOutputType = {
    strength: number | null
    dexterity: number | null
    endurance: number | null
    intelligence: number | null
    education: number | null
    socialStanding: number | null
    physicalDamage: number | null
    mentalDamage: number | null
  }

  export type CharacteristicsSumAggregateOutputType = {
    strength: number | null
    dexterity: number | null
    endurance: number | null
    intelligence: number | null
    education: number | null
    socialStanding: number | null
    physicalDamage: number | null
    mentalDamage: number | null
  }

  export type CharacteristicsMinAggregateOutputType = {
    id: string | null
    strength: number | null
    dexterity: number | null
    endurance: number | null
    intelligence: number | null
    education: number | null
    socialStanding: number | null
    physicalDamage: number | null
    mentalDamage: number | null
    characterId: string | null
  }

  export type CharacteristicsMaxAggregateOutputType = {
    id: string | null
    strength: number | null
    dexterity: number | null
    endurance: number | null
    intelligence: number | null
    education: number | null
    socialStanding: number | null
    physicalDamage: number | null
    mentalDamage: number | null
    characterId: string | null
  }

  export type CharacteristicsCountAggregateOutputType = {
    id: number
    strength: number
    dexterity: number
    endurance: number
    intelligence: number
    education: number
    socialStanding: number
    physicalDamage: number
    mentalDamage: number
    characterId: number
    _all: number
  }


  export type CharacteristicsAvgAggregateInputType = {
    strength?: true
    dexterity?: true
    endurance?: true
    intelligence?: true
    education?: true
    socialStanding?: true
    physicalDamage?: true
    mentalDamage?: true
  }

  export type CharacteristicsSumAggregateInputType = {
    strength?: true
    dexterity?: true
    endurance?: true
    intelligence?: true
    education?: true
    socialStanding?: true
    physicalDamage?: true
    mentalDamage?: true
  }

  export type CharacteristicsMinAggregateInputType = {
    id?: true
    strength?: true
    dexterity?: true
    endurance?: true
    intelligence?: true
    education?: true
    socialStanding?: true
    physicalDamage?: true
    mentalDamage?: true
    characterId?: true
  }

  export type CharacteristicsMaxAggregateInputType = {
    id?: true
    strength?: true
    dexterity?: true
    endurance?: true
    intelligence?: true
    education?: true
    socialStanding?: true
    physicalDamage?: true
    mentalDamage?: true
    characterId?: true
  }

  export type CharacteristicsCountAggregateInputType = {
    id?: true
    strength?: true
    dexterity?: true
    endurance?: true
    intelligence?: true
    education?: true
    socialStanding?: true
    physicalDamage?: true
    mentalDamage?: true
    characterId?: true
    _all?: true
  }

  export type CharacteristicsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characteristics to aggregate.
     */
    where?: CharacteristicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characteristics to fetch.
     */
    orderBy?: CharacteristicsOrderByWithRelationInput | CharacteristicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacteristicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characteristics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Characteristics
    **/
    _count?: true | CharacteristicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacteristicsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacteristicsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacteristicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacteristicsMaxAggregateInputType
  }

  export type GetCharacteristicsAggregateType<T extends CharacteristicsAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacteristics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacteristics[P]>
      : GetScalarType<T[P], AggregateCharacteristics[P]>
  }




  export type CharacteristicsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacteristicsWhereInput
    orderBy?: CharacteristicsOrderByWithAggregationInput | CharacteristicsOrderByWithAggregationInput[]
    by: CharacteristicsScalarFieldEnum[] | CharacteristicsScalarFieldEnum
    having?: CharacteristicsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacteristicsCountAggregateInputType | true
    _avg?: CharacteristicsAvgAggregateInputType
    _sum?: CharacteristicsSumAggregateInputType
    _min?: CharacteristicsMinAggregateInputType
    _max?: CharacteristicsMaxAggregateInputType
  }

  export type CharacteristicsGroupByOutputType = {
    id: string
    strength: number
    dexterity: number
    endurance: number
    intelligence: number
    education: number
    socialStanding: number
    physicalDamage: number | null
    mentalDamage: number | null
    characterId: string
    _count: CharacteristicsCountAggregateOutputType | null
    _avg: CharacteristicsAvgAggregateOutputType | null
    _sum: CharacteristicsSumAggregateOutputType | null
    _min: CharacteristicsMinAggregateOutputType | null
    _max: CharacteristicsMaxAggregateOutputType | null
  }

  type GetCharacteristicsGroupByPayload<T extends CharacteristicsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacteristicsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacteristicsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacteristicsGroupByOutputType[P]>
            : GetScalarType<T[P], CharacteristicsGroupByOutputType[P]>
        }
      >
    >


  export type CharacteristicsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strength?: boolean
    dexterity?: boolean
    endurance?: boolean
    intelligence?: boolean
    education?: boolean
    socialStanding?: boolean
    physicalDamage?: boolean
    mentalDamage?: boolean
    characterId?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characteristics"]>

  export type CharacteristicsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strength?: boolean
    dexterity?: boolean
    endurance?: boolean
    intelligence?: boolean
    education?: boolean
    socialStanding?: boolean
    physicalDamage?: boolean
    mentalDamage?: boolean
    characterId?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characteristics"]>

  export type CharacteristicsSelectScalar = {
    id?: boolean
    strength?: boolean
    dexterity?: boolean
    endurance?: boolean
    intelligence?: boolean
    education?: boolean
    socialStanding?: boolean
    physicalDamage?: boolean
    mentalDamage?: boolean
    characterId?: boolean
  }

  export type CharacteristicsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }
  export type CharacteristicsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }

  export type $CharacteristicsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Characteristics"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      strength: number
      dexterity: number
      endurance: number
      intelligence: number
      education: number
      socialStanding: number
      physicalDamage: number | null
      mentalDamage: number | null
      characterId: string
    }, ExtArgs["result"]["characteristics"]>
    composites: {}
  }

  type CharacteristicsGetPayload<S extends boolean | null | undefined | CharacteristicsDefaultArgs> = $Result.GetResult<Prisma.$CharacteristicsPayload, S>

  type CharacteristicsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacteristicsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CharacteristicsCountAggregateInputType | true
    }

  export interface CharacteristicsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Characteristics'], meta: { name: 'Characteristics' } }
    /**
     * Find zero or one Characteristics that matches the filter.
     * @param {CharacteristicsFindUniqueArgs} args - Arguments to find a Characteristics
     * @example
     * // Get one Characteristics
     * const characteristics = await prisma.characteristics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacteristicsFindUniqueArgs>(args: SelectSubset<T, CharacteristicsFindUniqueArgs<ExtArgs>>): Prisma__CharacteristicsClient<$Result.GetResult<Prisma.$CharacteristicsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Characteristics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CharacteristicsFindUniqueOrThrowArgs} args - Arguments to find a Characteristics
     * @example
     * // Get one Characteristics
     * const characteristics = await prisma.characteristics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacteristicsFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacteristicsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacteristicsClient<$Result.GetResult<Prisma.$CharacteristicsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Characteristics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicsFindFirstArgs} args - Arguments to find a Characteristics
     * @example
     * // Get one Characteristics
     * const characteristics = await prisma.characteristics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacteristicsFindFirstArgs>(args?: SelectSubset<T, CharacteristicsFindFirstArgs<ExtArgs>>): Prisma__CharacteristicsClient<$Result.GetResult<Prisma.$CharacteristicsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Characteristics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicsFindFirstOrThrowArgs} args - Arguments to find a Characteristics
     * @example
     * // Get one Characteristics
     * const characteristics = await prisma.characteristics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacteristicsFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacteristicsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacteristicsClient<$Result.GetResult<Prisma.$CharacteristicsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Characteristics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characteristics
     * const characteristics = await prisma.characteristics.findMany()
     * 
     * // Get first 10 Characteristics
     * const characteristics = await prisma.characteristics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characteristicsWithIdOnly = await prisma.characteristics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacteristicsFindManyArgs>(args?: SelectSubset<T, CharacteristicsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacteristicsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Characteristics.
     * @param {CharacteristicsCreateArgs} args - Arguments to create a Characteristics.
     * @example
     * // Create one Characteristics
     * const Characteristics = await prisma.characteristics.create({
     *   data: {
     *     // ... data to create a Characteristics
     *   }
     * })
     * 
     */
    create<T extends CharacteristicsCreateArgs>(args: SelectSubset<T, CharacteristicsCreateArgs<ExtArgs>>): Prisma__CharacteristicsClient<$Result.GetResult<Prisma.$CharacteristicsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Characteristics.
     * @param {CharacteristicsCreateManyArgs} args - Arguments to create many Characteristics.
     * @example
     * // Create many Characteristics
     * const characteristics = await prisma.characteristics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacteristicsCreateManyArgs>(args?: SelectSubset<T, CharacteristicsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Characteristics and returns the data saved in the database.
     * @param {CharacteristicsCreateManyAndReturnArgs} args - Arguments to create many Characteristics.
     * @example
     * // Create many Characteristics
     * const characteristics = await prisma.characteristics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Characteristics and only return the `id`
     * const characteristicsWithIdOnly = await prisma.characteristics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacteristicsCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacteristicsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacteristicsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Characteristics.
     * @param {CharacteristicsDeleteArgs} args - Arguments to delete one Characteristics.
     * @example
     * // Delete one Characteristics
     * const Characteristics = await prisma.characteristics.delete({
     *   where: {
     *     // ... filter to delete one Characteristics
     *   }
     * })
     * 
     */
    delete<T extends CharacteristicsDeleteArgs>(args: SelectSubset<T, CharacteristicsDeleteArgs<ExtArgs>>): Prisma__CharacteristicsClient<$Result.GetResult<Prisma.$CharacteristicsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Characteristics.
     * @param {CharacteristicsUpdateArgs} args - Arguments to update one Characteristics.
     * @example
     * // Update one Characteristics
     * const characteristics = await prisma.characteristics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacteristicsUpdateArgs>(args: SelectSubset<T, CharacteristicsUpdateArgs<ExtArgs>>): Prisma__CharacteristicsClient<$Result.GetResult<Prisma.$CharacteristicsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Characteristics.
     * @param {CharacteristicsDeleteManyArgs} args - Arguments to filter Characteristics to delete.
     * @example
     * // Delete a few Characteristics
     * const { count } = await prisma.characteristics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacteristicsDeleteManyArgs>(args?: SelectSubset<T, CharacteristicsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characteristics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characteristics
     * const characteristics = await prisma.characteristics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacteristicsUpdateManyArgs>(args: SelectSubset<T, CharacteristicsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Characteristics.
     * @param {CharacteristicsUpsertArgs} args - Arguments to update or create a Characteristics.
     * @example
     * // Update or create a Characteristics
     * const characteristics = await prisma.characteristics.upsert({
     *   create: {
     *     // ... data to create a Characteristics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Characteristics we want to update
     *   }
     * })
     */
    upsert<T extends CharacteristicsUpsertArgs>(args: SelectSubset<T, CharacteristicsUpsertArgs<ExtArgs>>): Prisma__CharacteristicsClient<$Result.GetResult<Prisma.$CharacteristicsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Characteristics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicsCountArgs} args - Arguments to filter Characteristics to count.
     * @example
     * // Count the number of Characteristics
     * const count = await prisma.characteristics.count({
     *   where: {
     *     // ... the filter for the Characteristics we want to count
     *   }
     * })
    **/
    count<T extends CharacteristicsCountArgs>(
      args?: Subset<T, CharacteristicsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacteristicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Characteristics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacteristicsAggregateArgs>(args: Subset<T, CharacteristicsAggregateArgs>): Prisma.PrismaPromise<GetCharacteristicsAggregateType<T>>

    /**
     * Group by Characteristics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacteristicsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacteristicsGroupByArgs['orderBy'] }
        : { orderBy?: CharacteristicsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacteristicsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacteristicsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Characteristics model
   */
  readonly fields: CharacteristicsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Characteristics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacteristicsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends CharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterDefaultArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Characteristics model
   */ 
  interface CharacteristicsFieldRefs {
    readonly id: FieldRef<"Characteristics", 'String'>
    readonly strength: FieldRef<"Characteristics", 'Int'>
    readonly dexterity: FieldRef<"Characteristics", 'Int'>
    readonly endurance: FieldRef<"Characteristics", 'Int'>
    readonly intelligence: FieldRef<"Characteristics", 'Int'>
    readonly education: FieldRef<"Characteristics", 'Int'>
    readonly socialStanding: FieldRef<"Characteristics", 'Int'>
    readonly physicalDamage: FieldRef<"Characteristics", 'Int'>
    readonly mentalDamage: FieldRef<"Characteristics", 'Int'>
    readonly characterId: FieldRef<"Characteristics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Characteristics findUnique
   */
  export type CharacteristicsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristics
     */
    select?: CharacteristicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicsInclude<ExtArgs> | null
    /**
     * Filter, which Characteristics to fetch.
     */
    where: CharacteristicsWhereUniqueInput
  }

  /**
   * Characteristics findUniqueOrThrow
   */
  export type CharacteristicsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristics
     */
    select?: CharacteristicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicsInclude<ExtArgs> | null
    /**
     * Filter, which Characteristics to fetch.
     */
    where: CharacteristicsWhereUniqueInput
  }

  /**
   * Characteristics findFirst
   */
  export type CharacteristicsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristics
     */
    select?: CharacteristicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicsInclude<ExtArgs> | null
    /**
     * Filter, which Characteristics to fetch.
     */
    where?: CharacteristicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characteristics to fetch.
     */
    orderBy?: CharacteristicsOrderByWithRelationInput | CharacteristicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characteristics.
     */
    cursor?: CharacteristicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characteristics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characteristics.
     */
    distinct?: CharacteristicsScalarFieldEnum | CharacteristicsScalarFieldEnum[]
  }

  /**
   * Characteristics findFirstOrThrow
   */
  export type CharacteristicsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristics
     */
    select?: CharacteristicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicsInclude<ExtArgs> | null
    /**
     * Filter, which Characteristics to fetch.
     */
    where?: CharacteristicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characteristics to fetch.
     */
    orderBy?: CharacteristicsOrderByWithRelationInput | CharacteristicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characteristics.
     */
    cursor?: CharacteristicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characteristics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characteristics.
     */
    distinct?: CharacteristicsScalarFieldEnum | CharacteristicsScalarFieldEnum[]
  }

  /**
   * Characteristics findMany
   */
  export type CharacteristicsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristics
     */
    select?: CharacteristicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicsInclude<ExtArgs> | null
    /**
     * Filter, which Characteristics to fetch.
     */
    where?: CharacteristicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characteristics to fetch.
     */
    orderBy?: CharacteristicsOrderByWithRelationInput | CharacteristicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Characteristics.
     */
    cursor?: CharacteristicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characteristics.
     */
    skip?: number
    distinct?: CharacteristicsScalarFieldEnum | CharacteristicsScalarFieldEnum[]
  }

  /**
   * Characteristics create
   */
  export type CharacteristicsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristics
     */
    select?: CharacteristicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicsInclude<ExtArgs> | null
    /**
     * The data needed to create a Characteristics.
     */
    data: XOR<CharacteristicsCreateInput, CharacteristicsUncheckedCreateInput>
  }

  /**
   * Characteristics createMany
   */
  export type CharacteristicsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Characteristics.
     */
    data: CharacteristicsCreateManyInput | CharacteristicsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Characteristics createManyAndReturn
   */
  export type CharacteristicsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristics
     */
    select?: CharacteristicsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Characteristics.
     */
    data: CharacteristicsCreateManyInput | CharacteristicsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Characteristics update
   */
  export type CharacteristicsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristics
     */
    select?: CharacteristicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicsInclude<ExtArgs> | null
    /**
     * The data needed to update a Characteristics.
     */
    data: XOR<CharacteristicsUpdateInput, CharacteristicsUncheckedUpdateInput>
    /**
     * Choose, which Characteristics to update.
     */
    where: CharacteristicsWhereUniqueInput
  }

  /**
   * Characteristics updateMany
   */
  export type CharacteristicsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Characteristics.
     */
    data: XOR<CharacteristicsUpdateManyMutationInput, CharacteristicsUncheckedUpdateManyInput>
    /**
     * Filter which Characteristics to update
     */
    where?: CharacteristicsWhereInput
  }

  /**
   * Characteristics upsert
   */
  export type CharacteristicsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristics
     */
    select?: CharacteristicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicsInclude<ExtArgs> | null
    /**
     * The filter to search for the Characteristics to update in case it exists.
     */
    where: CharacteristicsWhereUniqueInput
    /**
     * In case the Characteristics found by the `where` argument doesn't exist, create a new Characteristics with this data.
     */
    create: XOR<CharacteristicsCreateInput, CharacteristicsUncheckedCreateInput>
    /**
     * In case the Characteristics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacteristicsUpdateInput, CharacteristicsUncheckedUpdateInput>
  }

  /**
   * Characteristics delete
   */
  export type CharacteristicsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristics
     */
    select?: CharacteristicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicsInclude<ExtArgs> | null
    /**
     * Filter which Characteristics to delete.
     */
    where: CharacteristicsWhereUniqueInput
  }

  /**
   * Characteristics deleteMany
   */
  export type CharacteristicsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characteristics to delete
     */
    where?: CharacteristicsWhereInput
  }

  /**
   * Characteristics without action
   */
  export type CharacteristicsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristics
     */
    select?: CharacteristicsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicsInclude<ExtArgs> | null
  }


  /**
   * Model CharacterSkill
   */

  export type AggregateCharacterSkill = {
    _count: CharacterSkillCountAggregateOutputType | null
    _avg: CharacterSkillAvgAggregateOutputType | null
    _sum: CharacterSkillSumAggregateOutputType | null
    _min: CharacterSkillMinAggregateOutputType | null
    _max: CharacterSkillMaxAggregateOutputType | null
  }

  export type CharacterSkillAvgAggregateOutputType = {
    level: number | null
  }

  export type CharacterSkillSumAggregateOutputType = {
    level: number | null
  }

  export type CharacterSkillMinAggregateOutputType = {
    id: string | null
    name: string | null
    level: number | null
    specialization: string | null
    characterId: string | null
  }

  export type CharacterSkillMaxAggregateOutputType = {
    id: string | null
    name: string | null
    level: number | null
    specialization: string | null
    characterId: string | null
  }

  export type CharacterSkillCountAggregateOutputType = {
    id: number
    name: number
    level: number
    specialization: number
    characterId: number
    _all: number
  }


  export type CharacterSkillAvgAggregateInputType = {
    level?: true
  }

  export type CharacterSkillSumAggregateInputType = {
    level?: true
  }

  export type CharacterSkillMinAggregateInputType = {
    id?: true
    name?: true
    level?: true
    specialization?: true
    characterId?: true
  }

  export type CharacterSkillMaxAggregateInputType = {
    id?: true
    name?: true
    level?: true
    specialization?: true
    characterId?: true
  }

  export type CharacterSkillCountAggregateInputType = {
    id?: true
    name?: true
    level?: true
    specialization?: true
    characterId?: true
    _all?: true
  }

  export type CharacterSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterSkill to aggregate.
     */
    where?: CharacterSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSkills to fetch.
     */
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterSkills
    **/
    _count?: true | CharacterSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterSkillMaxAggregateInputType
  }

  export type GetCharacterSkillAggregateType<T extends CharacterSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterSkill[P]>
      : GetScalarType<T[P], AggregateCharacterSkill[P]>
  }




  export type CharacterSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterSkillWhereInput
    orderBy?: CharacterSkillOrderByWithAggregationInput | CharacterSkillOrderByWithAggregationInput[]
    by: CharacterSkillScalarFieldEnum[] | CharacterSkillScalarFieldEnum
    having?: CharacterSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterSkillCountAggregateInputType | true
    _avg?: CharacterSkillAvgAggregateInputType
    _sum?: CharacterSkillSumAggregateInputType
    _min?: CharacterSkillMinAggregateInputType
    _max?: CharacterSkillMaxAggregateInputType
  }

  export type CharacterSkillGroupByOutputType = {
    id: string
    name: string
    level: number
    specialization: string | null
    characterId: string
    _count: CharacterSkillCountAggregateOutputType | null
    _avg: CharacterSkillAvgAggregateOutputType | null
    _sum: CharacterSkillSumAggregateOutputType | null
    _min: CharacterSkillMinAggregateOutputType | null
    _max: CharacterSkillMaxAggregateOutputType | null
  }

  type GetCharacterSkillGroupByPayload<T extends CharacterSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterSkillGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterSkillGroupByOutputType[P]>
        }
      >
    >


  export type CharacterSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    specialization?: boolean
    characterId?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterSkill"]>

  export type CharacterSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    specialization?: boolean
    characterId?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterSkill"]>

  export type CharacterSkillSelectScalar = {
    id?: boolean
    name?: boolean
    level?: boolean
    specialization?: boolean
    characterId?: boolean
  }

  export type CharacterSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }
  export type CharacterSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }

  export type $CharacterSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterSkill"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      level: number
      specialization: string | null
      characterId: string
    }, ExtArgs["result"]["characterSkill"]>
    composites: {}
  }

  type CharacterSkillGetPayload<S extends boolean | null | undefined | CharacterSkillDefaultArgs> = $Result.GetResult<Prisma.$CharacterSkillPayload, S>

  type CharacterSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacterSkillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CharacterSkillCountAggregateInputType | true
    }

  export interface CharacterSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterSkill'], meta: { name: 'CharacterSkill' } }
    /**
     * Find zero or one CharacterSkill that matches the filter.
     * @param {CharacterSkillFindUniqueArgs} args - Arguments to find a CharacterSkill
     * @example
     * // Get one CharacterSkill
     * const characterSkill = await prisma.characterSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterSkillFindUniqueArgs>(args: SelectSubset<T, CharacterSkillFindUniqueArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CharacterSkill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CharacterSkillFindUniqueOrThrowArgs} args - Arguments to find a CharacterSkill
     * @example
     * // Get one CharacterSkill
     * const characterSkill = await prisma.characterSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CharacterSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillFindFirstArgs} args - Arguments to find a CharacterSkill
     * @example
     * // Get one CharacterSkill
     * const characterSkill = await prisma.characterSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterSkillFindFirstArgs>(args?: SelectSubset<T, CharacterSkillFindFirstArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CharacterSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillFindFirstOrThrowArgs} args - Arguments to find a CharacterSkill
     * @example
     * // Get one CharacterSkill
     * const characterSkill = await prisma.characterSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CharacterSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterSkills
     * const characterSkills = await prisma.characterSkill.findMany()
     * 
     * // Get first 10 CharacterSkills
     * const characterSkills = await prisma.characterSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterSkillWithIdOnly = await prisma.characterSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterSkillFindManyArgs>(args?: SelectSubset<T, CharacterSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CharacterSkill.
     * @param {CharacterSkillCreateArgs} args - Arguments to create a CharacterSkill.
     * @example
     * // Create one CharacterSkill
     * const CharacterSkill = await prisma.characterSkill.create({
     *   data: {
     *     // ... data to create a CharacterSkill
     *   }
     * })
     * 
     */
    create<T extends CharacterSkillCreateArgs>(args: SelectSubset<T, CharacterSkillCreateArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CharacterSkills.
     * @param {CharacterSkillCreateManyArgs} args - Arguments to create many CharacterSkills.
     * @example
     * // Create many CharacterSkills
     * const characterSkill = await prisma.characterSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterSkillCreateManyArgs>(args?: SelectSubset<T, CharacterSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CharacterSkills and returns the data saved in the database.
     * @param {CharacterSkillCreateManyAndReturnArgs} args - Arguments to create many CharacterSkills.
     * @example
     * // Create many CharacterSkills
     * const characterSkill = await prisma.characterSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CharacterSkills and only return the `id`
     * const characterSkillWithIdOnly = await prisma.characterSkill.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CharacterSkill.
     * @param {CharacterSkillDeleteArgs} args - Arguments to delete one CharacterSkill.
     * @example
     * // Delete one CharacterSkill
     * const CharacterSkill = await prisma.characterSkill.delete({
     *   where: {
     *     // ... filter to delete one CharacterSkill
     *   }
     * })
     * 
     */
    delete<T extends CharacterSkillDeleteArgs>(args: SelectSubset<T, CharacterSkillDeleteArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CharacterSkill.
     * @param {CharacterSkillUpdateArgs} args - Arguments to update one CharacterSkill.
     * @example
     * // Update one CharacterSkill
     * const characterSkill = await prisma.characterSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterSkillUpdateArgs>(args: SelectSubset<T, CharacterSkillUpdateArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CharacterSkills.
     * @param {CharacterSkillDeleteManyArgs} args - Arguments to filter CharacterSkills to delete.
     * @example
     * // Delete a few CharacterSkills
     * const { count } = await prisma.characterSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterSkillDeleteManyArgs>(args?: SelectSubset<T, CharacterSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterSkills
     * const characterSkill = await prisma.characterSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterSkillUpdateManyArgs>(args: SelectSubset<T, CharacterSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CharacterSkill.
     * @param {CharacterSkillUpsertArgs} args - Arguments to update or create a CharacterSkill.
     * @example
     * // Update or create a CharacterSkill
     * const characterSkill = await prisma.characterSkill.upsert({
     *   create: {
     *     // ... data to create a CharacterSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterSkill we want to update
     *   }
     * })
     */
    upsert<T extends CharacterSkillUpsertArgs>(args: SelectSubset<T, CharacterSkillUpsertArgs<ExtArgs>>): Prisma__CharacterSkillClient<$Result.GetResult<Prisma.$CharacterSkillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CharacterSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillCountArgs} args - Arguments to filter CharacterSkills to count.
     * @example
     * // Count the number of CharacterSkills
     * const count = await prisma.characterSkill.count({
     *   where: {
     *     // ... the filter for the CharacterSkills we want to count
     *   }
     * })
    **/
    count<T extends CharacterSkillCountArgs>(
      args?: Subset<T, CharacterSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterSkillAggregateArgs>(args: Subset<T, CharacterSkillAggregateArgs>): Prisma.PrismaPromise<GetCharacterSkillAggregateType<T>>

    /**
     * Group by CharacterSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterSkillGroupByArgs['orderBy'] }
        : { orderBy?: CharacterSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterSkill model
   */
  readonly fields: CharacterSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends CharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterDefaultArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CharacterSkill model
   */ 
  interface CharacterSkillFieldRefs {
    readonly id: FieldRef<"CharacterSkill", 'String'>
    readonly name: FieldRef<"CharacterSkill", 'String'>
    readonly level: FieldRef<"CharacterSkill", 'Int'>
    readonly specialization: FieldRef<"CharacterSkill", 'String'>
    readonly characterId: FieldRef<"CharacterSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CharacterSkill findUnique
   */
  export type CharacterSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkill to fetch.
     */
    where: CharacterSkillWhereUniqueInput
  }

  /**
   * CharacterSkill findUniqueOrThrow
   */
  export type CharacterSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkill to fetch.
     */
    where: CharacterSkillWhereUniqueInput
  }

  /**
   * CharacterSkill findFirst
   */
  export type CharacterSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkill to fetch.
     */
    where?: CharacterSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSkills to fetch.
     */
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterSkills.
     */
    cursor?: CharacterSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterSkills.
     */
    distinct?: CharacterSkillScalarFieldEnum | CharacterSkillScalarFieldEnum[]
  }

  /**
   * CharacterSkill findFirstOrThrow
   */
  export type CharacterSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkill to fetch.
     */
    where?: CharacterSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSkills to fetch.
     */
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterSkills.
     */
    cursor?: CharacterSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterSkills.
     */
    distinct?: CharacterSkillScalarFieldEnum | CharacterSkillScalarFieldEnum[]
  }

  /**
   * CharacterSkill findMany
   */
  export type CharacterSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter, which CharacterSkills to fetch.
     */
    where?: CharacterSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterSkills to fetch.
     */
    orderBy?: CharacterSkillOrderByWithRelationInput | CharacterSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterSkills.
     */
    cursor?: CharacterSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterSkills.
     */
    skip?: number
    distinct?: CharacterSkillScalarFieldEnum | CharacterSkillScalarFieldEnum[]
  }

  /**
   * CharacterSkill create
   */
  export type CharacterSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterSkill.
     */
    data: XOR<CharacterSkillCreateInput, CharacterSkillUncheckedCreateInput>
  }

  /**
   * CharacterSkill createMany
   */
  export type CharacterSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterSkills.
     */
    data: CharacterSkillCreateManyInput | CharacterSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CharacterSkill createManyAndReturn
   */
  export type CharacterSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CharacterSkills.
     */
    data: CharacterSkillCreateManyInput | CharacterSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacterSkill update
   */
  export type CharacterSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterSkill.
     */
    data: XOR<CharacterSkillUpdateInput, CharacterSkillUncheckedUpdateInput>
    /**
     * Choose, which CharacterSkill to update.
     */
    where: CharacterSkillWhereUniqueInput
  }

  /**
   * CharacterSkill updateMany
   */
  export type CharacterSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterSkills.
     */
    data: XOR<CharacterSkillUpdateManyMutationInput, CharacterSkillUncheckedUpdateManyInput>
    /**
     * Filter which CharacterSkills to update
     */
    where?: CharacterSkillWhereInput
  }

  /**
   * CharacterSkill upsert
   */
  export type CharacterSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterSkill to update in case it exists.
     */
    where: CharacterSkillWhereUniqueInput
    /**
     * In case the CharacterSkill found by the `where` argument doesn't exist, create a new CharacterSkill with this data.
     */
    create: XOR<CharacterSkillCreateInput, CharacterSkillUncheckedCreateInput>
    /**
     * In case the CharacterSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterSkillUpdateInput, CharacterSkillUncheckedUpdateInput>
  }

  /**
   * CharacterSkill delete
   */
  export type CharacterSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
    /**
     * Filter which CharacterSkill to delete.
     */
    where: CharacterSkillWhereUniqueInput
  }

  /**
   * CharacterSkill deleteMany
   */
  export type CharacterSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterSkills to delete
     */
    where?: CharacterSkillWhereInput
  }

  /**
   * CharacterSkill without action
   */
  export type CharacterSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterSkill
     */
    select?: CharacterSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterSkillInclude<ExtArgs> | null
  }


  /**
   * Model CharacterEquipment
   */

  export type AggregateCharacterEquipment = {
    _count: CharacterEquipmentCountAggregateOutputType | null
    _avg: CharacterEquipmentAvgAggregateOutputType | null
    _sum: CharacterEquipmentSumAggregateOutputType | null
    _min: CharacterEquipmentMinAggregateOutputType | null
    _max: CharacterEquipmentMaxAggregateOutputType | null
  }

  export type CharacterEquipmentAvgAggregateOutputType = {
    weight: number | null
    cost: number | null
    quantity: number | null
    armorValue: number | null
  }

  export type CharacterEquipmentSumAggregateOutputType = {
    weight: number | null
    cost: number | null
    quantity: number | null
    armorValue: number | null
  }

  export type CharacterEquipmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    weight: number | null
    cost: number | null
    quantity: number | null
    equipped: boolean | null
    category: string | null
    subcategory: string | null
    weaponType: string | null
    damage: string | null
    range: string | null
    armorValue: number | null
    armorType: string | null
    characterId: string | null
  }

  export type CharacterEquipmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    weight: number | null
    cost: number | null
    quantity: number | null
    equipped: boolean | null
    category: string | null
    subcategory: string | null
    weaponType: string | null
    damage: string | null
    range: string | null
    armorValue: number | null
    armorType: string | null
    characterId: string | null
  }

  export type CharacterEquipmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    weight: number
    cost: number
    quantity: number
    equipped: number
    category: number
    subcategory: number
    weaponType: number
    damage: number
    range: number
    armorValue: number
    armorType: number
    characterId: number
    _all: number
  }


  export type CharacterEquipmentAvgAggregateInputType = {
    weight?: true
    cost?: true
    quantity?: true
    armorValue?: true
  }

  export type CharacterEquipmentSumAggregateInputType = {
    weight?: true
    cost?: true
    quantity?: true
    armorValue?: true
  }

  export type CharacterEquipmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    weight?: true
    cost?: true
    quantity?: true
    equipped?: true
    category?: true
    subcategory?: true
    weaponType?: true
    damage?: true
    range?: true
    armorValue?: true
    armorType?: true
    characterId?: true
  }

  export type CharacterEquipmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    weight?: true
    cost?: true
    quantity?: true
    equipped?: true
    category?: true
    subcategory?: true
    weaponType?: true
    damage?: true
    range?: true
    armorValue?: true
    armorType?: true
    characterId?: true
  }

  export type CharacterEquipmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    weight?: true
    cost?: true
    quantity?: true
    equipped?: true
    category?: true
    subcategory?: true
    weaponType?: true
    damage?: true
    range?: true
    armorValue?: true
    armorType?: true
    characterId?: true
    _all?: true
  }

  export type CharacterEquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterEquipment to aggregate.
     */
    where?: CharacterEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterEquipments to fetch.
     */
    orderBy?: CharacterEquipmentOrderByWithRelationInput | CharacterEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterEquipments
    **/
    _count?: true | CharacterEquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterEquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterEquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterEquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterEquipmentMaxAggregateInputType
  }

  export type GetCharacterEquipmentAggregateType<T extends CharacterEquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterEquipment[P]>
      : GetScalarType<T[P], AggregateCharacterEquipment[P]>
  }




  export type CharacterEquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterEquipmentWhereInput
    orderBy?: CharacterEquipmentOrderByWithAggregationInput | CharacterEquipmentOrderByWithAggregationInput[]
    by: CharacterEquipmentScalarFieldEnum[] | CharacterEquipmentScalarFieldEnum
    having?: CharacterEquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterEquipmentCountAggregateInputType | true
    _avg?: CharacterEquipmentAvgAggregateInputType
    _sum?: CharacterEquipmentSumAggregateInputType
    _min?: CharacterEquipmentMinAggregateInputType
    _max?: CharacterEquipmentMaxAggregateInputType
  }

  export type CharacterEquipmentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    weight: number | null
    cost: number | null
    quantity: number
    equipped: boolean
    category: string | null
    subcategory: string | null
    weaponType: string | null
    damage: string | null
    range: string | null
    armorValue: number | null
    armorType: string | null
    characterId: string
    _count: CharacterEquipmentCountAggregateOutputType | null
    _avg: CharacterEquipmentAvgAggregateOutputType | null
    _sum: CharacterEquipmentSumAggregateOutputType | null
    _min: CharacterEquipmentMinAggregateOutputType | null
    _max: CharacterEquipmentMaxAggregateOutputType | null
  }

  type GetCharacterEquipmentGroupByPayload<T extends CharacterEquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterEquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterEquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterEquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterEquipmentGroupByOutputType[P]>
        }
      >
    >


  export type CharacterEquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    weight?: boolean
    cost?: boolean
    quantity?: boolean
    equipped?: boolean
    category?: boolean
    subcategory?: boolean
    weaponType?: boolean
    damage?: boolean
    range?: boolean
    armorValue?: boolean
    armorType?: boolean
    characterId?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterEquipment"]>

  export type CharacterEquipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    weight?: boolean
    cost?: boolean
    quantity?: boolean
    equipped?: boolean
    category?: boolean
    subcategory?: boolean
    weaponType?: boolean
    damage?: boolean
    range?: boolean
    armorValue?: boolean
    armorType?: boolean
    characterId?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterEquipment"]>

  export type CharacterEquipmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    weight?: boolean
    cost?: boolean
    quantity?: boolean
    equipped?: boolean
    category?: boolean
    subcategory?: boolean
    weaponType?: boolean
    damage?: boolean
    range?: boolean
    armorValue?: boolean
    armorType?: boolean
    characterId?: boolean
  }

  export type CharacterEquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }
  export type CharacterEquipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }

  export type $CharacterEquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterEquipment"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      weight: number | null
      cost: number | null
      quantity: number
      equipped: boolean
      category: string | null
      subcategory: string | null
      weaponType: string | null
      damage: string | null
      range: string | null
      armorValue: number | null
      armorType: string | null
      characterId: string
    }, ExtArgs["result"]["characterEquipment"]>
    composites: {}
  }

  type CharacterEquipmentGetPayload<S extends boolean | null | undefined | CharacterEquipmentDefaultArgs> = $Result.GetResult<Prisma.$CharacterEquipmentPayload, S>

  type CharacterEquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacterEquipmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CharacterEquipmentCountAggregateInputType | true
    }

  export interface CharacterEquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterEquipment'], meta: { name: 'CharacterEquipment' } }
    /**
     * Find zero or one CharacterEquipment that matches the filter.
     * @param {CharacterEquipmentFindUniqueArgs} args - Arguments to find a CharacterEquipment
     * @example
     * // Get one CharacterEquipment
     * const characterEquipment = await prisma.characterEquipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterEquipmentFindUniqueArgs>(args: SelectSubset<T, CharacterEquipmentFindUniqueArgs<ExtArgs>>): Prisma__CharacterEquipmentClient<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CharacterEquipment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CharacterEquipmentFindUniqueOrThrowArgs} args - Arguments to find a CharacterEquipment
     * @example
     * // Get one CharacterEquipment
     * const characterEquipment = await prisma.characterEquipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterEquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterEquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterEquipmentClient<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CharacterEquipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEquipmentFindFirstArgs} args - Arguments to find a CharacterEquipment
     * @example
     * // Get one CharacterEquipment
     * const characterEquipment = await prisma.characterEquipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterEquipmentFindFirstArgs>(args?: SelectSubset<T, CharacterEquipmentFindFirstArgs<ExtArgs>>): Prisma__CharacterEquipmentClient<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CharacterEquipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEquipmentFindFirstOrThrowArgs} args - Arguments to find a CharacterEquipment
     * @example
     * // Get one CharacterEquipment
     * const characterEquipment = await prisma.characterEquipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterEquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterEquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterEquipmentClient<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CharacterEquipments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterEquipments
     * const characterEquipments = await prisma.characterEquipment.findMany()
     * 
     * // Get first 10 CharacterEquipments
     * const characterEquipments = await prisma.characterEquipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterEquipmentWithIdOnly = await prisma.characterEquipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterEquipmentFindManyArgs>(args?: SelectSubset<T, CharacterEquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CharacterEquipment.
     * @param {CharacterEquipmentCreateArgs} args - Arguments to create a CharacterEquipment.
     * @example
     * // Create one CharacterEquipment
     * const CharacterEquipment = await prisma.characterEquipment.create({
     *   data: {
     *     // ... data to create a CharacterEquipment
     *   }
     * })
     * 
     */
    create<T extends CharacterEquipmentCreateArgs>(args: SelectSubset<T, CharacterEquipmentCreateArgs<ExtArgs>>): Prisma__CharacterEquipmentClient<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CharacterEquipments.
     * @param {CharacterEquipmentCreateManyArgs} args - Arguments to create many CharacterEquipments.
     * @example
     * // Create many CharacterEquipments
     * const characterEquipment = await prisma.characterEquipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterEquipmentCreateManyArgs>(args?: SelectSubset<T, CharacterEquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CharacterEquipments and returns the data saved in the database.
     * @param {CharacterEquipmentCreateManyAndReturnArgs} args - Arguments to create many CharacterEquipments.
     * @example
     * // Create many CharacterEquipments
     * const characterEquipment = await prisma.characterEquipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CharacterEquipments and only return the `id`
     * const characterEquipmentWithIdOnly = await prisma.characterEquipment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterEquipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterEquipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CharacterEquipment.
     * @param {CharacterEquipmentDeleteArgs} args - Arguments to delete one CharacterEquipment.
     * @example
     * // Delete one CharacterEquipment
     * const CharacterEquipment = await prisma.characterEquipment.delete({
     *   where: {
     *     // ... filter to delete one CharacterEquipment
     *   }
     * })
     * 
     */
    delete<T extends CharacterEquipmentDeleteArgs>(args: SelectSubset<T, CharacterEquipmentDeleteArgs<ExtArgs>>): Prisma__CharacterEquipmentClient<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CharacterEquipment.
     * @param {CharacterEquipmentUpdateArgs} args - Arguments to update one CharacterEquipment.
     * @example
     * // Update one CharacterEquipment
     * const characterEquipment = await prisma.characterEquipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterEquipmentUpdateArgs>(args: SelectSubset<T, CharacterEquipmentUpdateArgs<ExtArgs>>): Prisma__CharacterEquipmentClient<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CharacterEquipments.
     * @param {CharacterEquipmentDeleteManyArgs} args - Arguments to filter CharacterEquipments to delete.
     * @example
     * // Delete a few CharacterEquipments
     * const { count } = await prisma.characterEquipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterEquipmentDeleteManyArgs>(args?: SelectSubset<T, CharacterEquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterEquipments
     * const characterEquipment = await prisma.characterEquipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterEquipmentUpdateManyArgs>(args: SelectSubset<T, CharacterEquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CharacterEquipment.
     * @param {CharacterEquipmentUpsertArgs} args - Arguments to update or create a CharacterEquipment.
     * @example
     * // Update or create a CharacterEquipment
     * const characterEquipment = await prisma.characterEquipment.upsert({
     *   create: {
     *     // ... data to create a CharacterEquipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterEquipment we want to update
     *   }
     * })
     */
    upsert<T extends CharacterEquipmentUpsertArgs>(args: SelectSubset<T, CharacterEquipmentUpsertArgs<ExtArgs>>): Prisma__CharacterEquipmentClient<$Result.GetResult<Prisma.$CharacterEquipmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CharacterEquipments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEquipmentCountArgs} args - Arguments to filter CharacterEquipments to count.
     * @example
     * // Count the number of CharacterEquipments
     * const count = await prisma.characterEquipment.count({
     *   where: {
     *     // ... the filter for the CharacterEquipments we want to count
     *   }
     * })
    **/
    count<T extends CharacterEquipmentCountArgs>(
      args?: Subset<T, CharacterEquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterEquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterEquipmentAggregateArgs>(args: Subset<T, CharacterEquipmentAggregateArgs>): Prisma.PrismaPromise<GetCharacterEquipmentAggregateType<T>>

    /**
     * Group by CharacterEquipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterEquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterEquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterEquipmentGroupByArgs['orderBy'] }
        : { orderBy?: CharacterEquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterEquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterEquipment model
   */
  readonly fields: CharacterEquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterEquipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterEquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends CharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterDefaultArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CharacterEquipment model
   */ 
  interface CharacterEquipmentFieldRefs {
    readonly id: FieldRef<"CharacterEquipment", 'String'>
    readonly name: FieldRef<"CharacterEquipment", 'String'>
    readonly description: FieldRef<"CharacterEquipment", 'String'>
    readonly weight: FieldRef<"CharacterEquipment", 'Float'>
    readonly cost: FieldRef<"CharacterEquipment", 'Int'>
    readonly quantity: FieldRef<"CharacterEquipment", 'Int'>
    readonly equipped: FieldRef<"CharacterEquipment", 'Boolean'>
    readonly category: FieldRef<"CharacterEquipment", 'String'>
    readonly subcategory: FieldRef<"CharacterEquipment", 'String'>
    readonly weaponType: FieldRef<"CharacterEquipment", 'String'>
    readonly damage: FieldRef<"CharacterEquipment", 'String'>
    readonly range: FieldRef<"CharacterEquipment", 'String'>
    readonly armorValue: FieldRef<"CharacterEquipment", 'Int'>
    readonly armorType: FieldRef<"CharacterEquipment", 'String'>
    readonly characterId: FieldRef<"CharacterEquipment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CharacterEquipment findUnique
   */
  export type CharacterEquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which CharacterEquipment to fetch.
     */
    where: CharacterEquipmentWhereUniqueInput
  }

  /**
   * CharacterEquipment findUniqueOrThrow
   */
  export type CharacterEquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which CharacterEquipment to fetch.
     */
    where: CharacterEquipmentWhereUniqueInput
  }

  /**
   * CharacterEquipment findFirst
   */
  export type CharacterEquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which CharacterEquipment to fetch.
     */
    where?: CharacterEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterEquipments to fetch.
     */
    orderBy?: CharacterEquipmentOrderByWithRelationInput | CharacterEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterEquipments.
     */
    cursor?: CharacterEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterEquipments.
     */
    distinct?: CharacterEquipmentScalarFieldEnum | CharacterEquipmentScalarFieldEnum[]
  }

  /**
   * CharacterEquipment findFirstOrThrow
   */
  export type CharacterEquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which CharacterEquipment to fetch.
     */
    where?: CharacterEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterEquipments to fetch.
     */
    orderBy?: CharacterEquipmentOrderByWithRelationInput | CharacterEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterEquipments.
     */
    cursor?: CharacterEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterEquipments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterEquipments.
     */
    distinct?: CharacterEquipmentScalarFieldEnum | CharacterEquipmentScalarFieldEnum[]
  }

  /**
   * CharacterEquipment findMany
   */
  export type CharacterEquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    /**
     * Filter, which CharacterEquipments to fetch.
     */
    where?: CharacterEquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterEquipments to fetch.
     */
    orderBy?: CharacterEquipmentOrderByWithRelationInput | CharacterEquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterEquipments.
     */
    cursor?: CharacterEquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterEquipments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterEquipments.
     */
    skip?: number
    distinct?: CharacterEquipmentScalarFieldEnum | CharacterEquipmentScalarFieldEnum[]
  }

  /**
   * CharacterEquipment create
   */
  export type CharacterEquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterEquipment.
     */
    data: XOR<CharacterEquipmentCreateInput, CharacterEquipmentUncheckedCreateInput>
  }

  /**
   * CharacterEquipment createMany
   */
  export type CharacterEquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterEquipments.
     */
    data: CharacterEquipmentCreateManyInput | CharacterEquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CharacterEquipment createManyAndReturn
   */
  export type CharacterEquipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CharacterEquipments.
     */
    data: CharacterEquipmentCreateManyInput | CharacterEquipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterEquipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacterEquipment update
   */
  export type CharacterEquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterEquipment.
     */
    data: XOR<CharacterEquipmentUpdateInput, CharacterEquipmentUncheckedUpdateInput>
    /**
     * Choose, which CharacterEquipment to update.
     */
    where: CharacterEquipmentWhereUniqueInput
  }

  /**
   * CharacterEquipment updateMany
   */
  export type CharacterEquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterEquipments.
     */
    data: XOR<CharacterEquipmentUpdateManyMutationInput, CharacterEquipmentUncheckedUpdateManyInput>
    /**
     * Filter which CharacterEquipments to update
     */
    where?: CharacterEquipmentWhereInput
  }

  /**
   * CharacterEquipment upsert
   */
  export type CharacterEquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterEquipment to update in case it exists.
     */
    where: CharacterEquipmentWhereUniqueInput
    /**
     * In case the CharacterEquipment found by the `where` argument doesn't exist, create a new CharacterEquipment with this data.
     */
    create: XOR<CharacterEquipmentCreateInput, CharacterEquipmentUncheckedCreateInput>
    /**
     * In case the CharacterEquipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterEquipmentUpdateInput, CharacterEquipmentUncheckedUpdateInput>
  }

  /**
   * CharacterEquipment delete
   */
  export type CharacterEquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
    /**
     * Filter which CharacterEquipment to delete.
     */
    where: CharacterEquipmentWhereUniqueInput
  }

  /**
   * CharacterEquipment deleteMany
   */
  export type CharacterEquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterEquipments to delete
     */
    where?: CharacterEquipmentWhereInput
  }

  /**
   * CharacterEquipment without action
   */
  export type CharacterEquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterEquipment
     */
    select?: CharacterEquipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterEquipmentInclude<ExtArgs> | null
  }


  /**
   * Model LifeEvent
   */

  export type AggregateLifeEvent = {
    _count: LifeEventCountAggregateOutputType | null
    _avg: LifeEventAvgAggregateOutputType | null
    _sum: LifeEventSumAggregateOutputType | null
    _min: LifeEventMinAggregateOutputType | null
    _max: LifeEventMaxAggregateOutputType | null
  }

  export type LifeEventAvgAggregateOutputType = {
    age: number | null
  }

  export type LifeEventSumAggregateOutputType = {
    age: number | null
  }

  export type LifeEventMinAggregateOutputType = {
    id: string | null
    age: number | null
    event: string | null
    description: string | null
    career: string | null
    rank: string | null
    characterId: string | null
  }

  export type LifeEventMaxAggregateOutputType = {
    id: string | null
    age: number | null
    event: string | null
    description: string | null
    career: string | null
    rank: string | null
    characterId: string | null
  }

  export type LifeEventCountAggregateOutputType = {
    id: number
    age: number
    event: number
    description: number
    effects: number
    career: number
    rank: number
    skills: number
    characterId: number
    _all: number
  }


  export type LifeEventAvgAggregateInputType = {
    age?: true
  }

  export type LifeEventSumAggregateInputType = {
    age?: true
  }

  export type LifeEventMinAggregateInputType = {
    id?: true
    age?: true
    event?: true
    description?: true
    career?: true
    rank?: true
    characterId?: true
  }

  export type LifeEventMaxAggregateInputType = {
    id?: true
    age?: true
    event?: true
    description?: true
    career?: true
    rank?: true
    characterId?: true
  }

  export type LifeEventCountAggregateInputType = {
    id?: true
    age?: true
    event?: true
    description?: true
    effects?: true
    career?: true
    rank?: true
    skills?: true
    characterId?: true
    _all?: true
  }

  export type LifeEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LifeEvent to aggregate.
     */
    where?: LifeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LifeEvents to fetch.
     */
    orderBy?: LifeEventOrderByWithRelationInput | LifeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LifeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LifeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LifeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LifeEvents
    **/
    _count?: true | LifeEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LifeEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LifeEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LifeEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LifeEventMaxAggregateInputType
  }

  export type GetLifeEventAggregateType<T extends LifeEventAggregateArgs> = {
        [P in keyof T & keyof AggregateLifeEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLifeEvent[P]>
      : GetScalarType<T[P], AggregateLifeEvent[P]>
  }




  export type LifeEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LifeEventWhereInput
    orderBy?: LifeEventOrderByWithAggregationInput | LifeEventOrderByWithAggregationInput[]
    by: LifeEventScalarFieldEnum[] | LifeEventScalarFieldEnum
    having?: LifeEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LifeEventCountAggregateInputType | true
    _avg?: LifeEventAvgAggregateInputType
    _sum?: LifeEventSumAggregateInputType
    _min?: LifeEventMinAggregateInputType
    _max?: LifeEventMaxAggregateInputType
  }

  export type LifeEventGroupByOutputType = {
    id: string
    age: number
    event: string
    description: string | null
    effects: JsonValue | null
    career: string | null
    rank: string | null
    skills: string[]
    characterId: string
    _count: LifeEventCountAggregateOutputType | null
    _avg: LifeEventAvgAggregateOutputType | null
    _sum: LifeEventSumAggregateOutputType | null
    _min: LifeEventMinAggregateOutputType | null
    _max: LifeEventMaxAggregateOutputType | null
  }

  type GetLifeEventGroupByPayload<T extends LifeEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LifeEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LifeEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LifeEventGroupByOutputType[P]>
            : GetScalarType<T[P], LifeEventGroupByOutputType[P]>
        }
      >
    >


  export type LifeEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    age?: boolean
    event?: boolean
    description?: boolean
    effects?: boolean
    career?: boolean
    rank?: boolean
    skills?: boolean
    characterId?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lifeEvent"]>

  export type LifeEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    age?: boolean
    event?: boolean
    description?: boolean
    effects?: boolean
    career?: boolean
    rank?: boolean
    skills?: boolean
    characterId?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lifeEvent"]>

  export type LifeEventSelectScalar = {
    id?: boolean
    age?: boolean
    event?: boolean
    description?: boolean
    effects?: boolean
    career?: boolean
    rank?: boolean
    skills?: boolean
    characterId?: boolean
  }

  export type LifeEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }
  export type LifeEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }

  export type $LifeEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LifeEvent"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      age: number
      event: string
      description: string | null
      effects: Prisma.JsonValue | null
      career: string | null
      rank: string | null
      skills: string[]
      characterId: string
    }, ExtArgs["result"]["lifeEvent"]>
    composites: {}
  }

  type LifeEventGetPayload<S extends boolean | null | undefined | LifeEventDefaultArgs> = $Result.GetResult<Prisma.$LifeEventPayload, S>

  type LifeEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LifeEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LifeEventCountAggregateInputType | true
    }

  export interface LifeEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LifeEvent'], meta: { name: 'LifeEvent' } }
    /**
     * Find zero or one LifeEvent that matches the filter.
     * @param {LifeEventFindUniqueArgs} args - Arguments to find a LifeEvent
     * @example
     * // Get one LifeEvent
     * const lifeEvent = await prisma.lifeEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LifeEventFindUniqueArgs>(args: SelectSubset<T, LifeEventFindUniqueArgs<ExtArgs>>): Prisma__LifeEventClient<$Result.GetResult<Prisma.$LifeEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LifeEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LifeEventFindUniqueOrThrowArgs} args - Arguments to find a LifeEvent
     * @example
     * // Get one LifeEvent
     * const lifeEvent = await prisma.lifeEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LifeEventFindUniqueOrThrowArgs>(args: SelectSubset<T, LifeEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LifeEventClient<$Result.GetResult<Prisma.$LifeEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LifeEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LifeEventFindFirstArgs} args - Arguments to find a LifeEvent
     * @example
     * // Get one LifeEvent
     * const lifeEvent = await prisma.lifeEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LifeEventFindFirstArgs>(args?: SelectSubset<T, LifeEventFindFirstArgs<ExtArgs>>): Prisma__LifeEventClient<$Result.GetResult<Prisma.$LifeEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LifeEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LifeEventFindFirstOrThrowArgs} args - Arguments to find a LifeEvent
     * @example
     * // Get one LifeEvent
     * const lifeEvent = await prisma.lifeEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LifeEventFindFirstOrThrowArgs>(args?: SelectSubset<T, LifeEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__LifeEventClient<$Result.GetResult<Prisma.$LifeEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LifeEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LifeEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LifeEvents
     * const lifeEvents = await prisma.lifeEvent.findMany()
     * 
     * // Get first 10 LifeEvents
     * const lifeEvents = await prisma.lifeEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lifeEventWithIdOnly = await prisma.lifeEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LifeEventFindManyArgs>(args?: SelectSubset<T, LifeEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LifeEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LifeEvent.
     * @param {LifeEventCreateArgs} args - Arguments to create a LifeEvent.
     * @example
     * // Create one LifeEvent
     * const LifeEvent = await prisma.lifeEvent.create({
     *   data: {
     *     // ... data to create a LifeEvent
     *   }
     * })
     * 
     */
    create<T extends LifeEventCreateArgs>(args: SelectSubset<T, LifeEventCreateArgs<ExtArgs>>): Prisma__LifeEventClient<$Result.GetResult<Prisma.$LifeEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LifeEvents.
     * @param {LifeEventCreateManyArgs} args - Arguments to create many LifeEvents.
     * @example
     * // Create many LifeEvents
     * const lifeEvent = await prisma.lifeEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LifeEventCreateManyArgs>(args?: SelectSubset<T, LifeEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LifeEvents and returns the data saved in the database.
     * @param {LifeEventCreateManyAndReturnArgs} args - Arguments to create many LifeEvents.
     * @example
     * // Create many LifeEvents
     * const lifeEvent = await prisma.lifeEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LifeEvents and only return the `id`
     * const lifeEventWithIdOnly = await prisma.lifeEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LifeEventCreateManyAndReturnArgs>(args?: SelectSubset<T, LifeEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LifeEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LifeEvent.
     * @param {LifeEventDeleteArgs} args - Arguments to delete one LifeEvent.
     * @example
     * // Delete one LifeEvent
     * const LifeEvent = await prisma.lifeEvent.delete({
     *   where: {
     *     // ... filter to delete one LifeEvent
     *   }
     * })
     * 
     */
    delete<T extends LifeEventDeleteArgs>(args: SelectSubset<T, LifeEventDeleteArgs<ExtArgs>>): Prisma__LifeEventClient<$Result.GetResult<Prisma.$LifeEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LifeEvent.
     * @param {LifeEventUpdateArgs} args - Arguments to update one LifeEvent.
     * @example
     * // Update one LifeEvent
     * const lifeEvent = await prisma.lifeEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LifeEventUpdateArgs>(args: SelectSubset<T, LifeEventUpdateArgs<ExtArgs>>): Prisma__LifeEventClient<$Result.GetResult<Prisma.$LifeEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LifeEvents.
     * @param {LifeEventDeleteManyArgs} args - Arguments to filter LifeEvents to delete.
     * @example
     * // Delete a few LifeEvents
     * const { count } = await prisma.lifeEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LifeEventDeleteManyArgs>(args?: SelectSubset<T, LifeEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LifeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LifeEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LifeEvents
     * const lifeEvent = await prisma.lifeEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LifeEventUpdateManyArgs>(args: SelectSubset<T, LifeEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LifeEvent.
     * @param {LifeEventUpsertArgs} args - Arguments to update or create a LifeEvent.
     * @example
     * // Update or create a LifeEvent
     * const lifeEvent = await prisma.lifeEvent.upsert({
     *   create: {
     *     // ... data to create a LifeEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LifeEvent we want to update
     *   }
     * })
     */
    upsert<T extends LifeEventUpsertArgs>(args: SelectSubset<T, LifeEventUpsertArgs<ExtArgs>>): Prisma__LifeEventClient<$Result.GetResult<Prisma.$LifeEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LifeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LifeEventCountArgs} args - Arguments to filter LifeEvents to count.
     * @example
     * // Count the number of LifeEvents
     * const count = await prisma.lifeEvent.count({
     *   where: {
     *     // ... the filter for the LifeEvents we want to count
     *   }
     * })
    **/
    count<T extends LifeEventCountArgs>(
      args?: Subset<T, LifeEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LifeEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LifeEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LifeEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LifeEventAggregateArgs>(args: Subset<T, LifeEventAggregateArgs>): Prisma.PrismaPromise<GetLifeEventAggregateType<T>>

    /**
     * Group by LifeEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LifeEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LifeEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LifeEventGroupByArgs['orderBy'] }
        : { orderBy?: LifeEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LifeEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLifeEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LifeEvent model
   */
  readonly fields: LifeEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LifeEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LifeEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends CharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterDefaultArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LifeEvent model
   */ 
  interface LifeEventFieldRefs {
    readonly id: FieldRef<"LifeEvent", 'String'>
    readonly age: FieldRef<"LifeEvent", 'Int'>
    readonly event: FieldRef<"LifeEvent", 'String'>
    readonly description: FieldRef<"LifeEvent", 'String'>
    readonly effects: FieldRef<"LifeEvent", 'Json'>
    readonly career: FieldRef<"LifeEvent", 'String'>
    readonly rank: FieldRef<"LifeEvent", 'String'>
    readonly skills: FieldRef<"LifeEvent", 'String[]'>
    readonly characterId: FieldRef<"LifeEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LifeEvent findUnique
   */
  export type LifeEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeEvent
     */
    select?: LifeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeEventInclude<ExtArgs> | null
    /**
     * Filter, which LifeEvent to fetch.
     */
    where: LifeEventWhereUniqueInput
  }

  /**
   * LifeEvent findUniqueOrThrow
   */
  export type LifeEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeEvent
     */
    select?: LifeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeEventInclude<ExtArgs> | null
    /**
     * Filter, which LifeEvent to fetch.
     */
    where: LifeEventWhereUniqueInput
  }

  /**
   * LifeEvent findFirst
   */
  export type LifeEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeEvent
     */
    select?: LifeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeEventInclude<ExtArgs> | null
    /**
     * Filter, which LifeEvent to fetch.
     */
    where?: LifeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LifeEvents to fetch.
     */
    orderBy?: LifeEventOrderByWithRelationInput | LifeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LifeEvents.
     */
    cursor?: LifeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LifeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LifeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LifeEvents.
     */
    distinct?: LifeEventScalarFieldEnum | LifeEventScalarFieldEnum[]
  }

  /**
   * LifeEvent findFirstOrThrow
   */
  export type LifeEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeEvent
     */
    select?: LifeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeEventInclude<ExtArgs> | null
    /**
     * Filter, which LifeEvent to fetch.
     */
    where?: LifeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LifeEvents to fetch.
     */
    orderBy?: LifeEventOrderByWithRelationInput | LifeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LifeEvents.
     */
    cursor?: LifeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LifeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LifeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LifeEvents.
     */
    distinct?: LifeEventScalarFieldEnum | LifeEventScalarFieldEnum[]
  }

  /**
   * LifeEvent findMany
   */
  export type LifeEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeEvent
     */
    select?: LifeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeEventInclude<ExtArgs> | null
    /**
     * Filter, which LifeEvents to fetch.
     */
    where?: LifeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LifeEvents to fetch.
     */
    orderBy?: LifeEventOrderByWithRelationInput | LifeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LifeEvents.
     */
    cursor?: LifeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LifeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LifeEvents.
     */
    skip?: number
    distinct?: LifeEventScalarFieldEnum | LifeEventScalarFieldEnum[]
  }

  /**
   * LifeEvent create
   */
  export type LifeEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeEvent
     */
    select?: LifeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeEventInclude<ExtArgs> | null
    /**
     * The data needed to create a LifeEvent.
     */
    data: XOR<LifeEventCreateInput, LifeEventUncheckedCreateInput>
  }

  /**
   * LifeEvent createMany
   */
  export type LifeEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LifeEvents.
     */
    data: LifeEventCreateManyInput | LifeEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LifeEvent createManyAndReturn
   */
  export type LifeEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeEvent
     */
    select?: LifeEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LifeEvents.
     */
    data: LifeEventCreateManyInput | LifeEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LifeEvent update
   */
  export type LifeEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeEvent
     */
    select?: LifeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeEventInclude<ExtArgs> | null
    /**
     * The data needed to update a LifeEvent.
     */
    data: XOR<LifeEventUpdateInput, LifeEventUncheckedUpdateInput>
    /**
     * Choose, which LifeEvent to update.
     */
    where: LifeEventWhereUniqueInput
  }

  /**
   * LifeEvent updateMany
   */
  export type LifeEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LifeEvents.
     */
    data: XOR<LifeEventUpdateManyMutationInput, LifeEventUncheckedUpdateManyInput>
    /**
     * Filter which LifeEvents to update
     */
    where?: LifeEventWhereInput
  }

  /**
   * LifeEvent upsert
   */
  export type LifeEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeEvent
     */
    select?: LifeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeEventInclude<ExtArgs> | null
    /**
     * The filter to search for the LifeEvent to update in case it exists.
     */
    where: LifeEventWhereUniqueInput
    /**
     * In case the LifeEvent found by the `where` argument doesn't exist, create a new LifeEvent with this data.
     */
    create: XOR<LifeEventCreateInput, LifeEventUncheckedCreateInput>
    /**
     * In case the LifeEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LifeEventUpdateInput, LifeEventUncheckedUpdateInput>
  }

  /**
   * LifeEvent delete
   */
  export type LifeEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeEvent
     */
    select?: LifeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeEventInclude<ExtArgs> | null
    /**
     * Filter which LifeEvent to delete.
     */
    where: LifeEventWhereUniqueInput
  }

  /**
   * LifeEvent deleteMany
   */
  export type LifeEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LifeEvents to delete
     */
    where?: LifeEventWhereInput
  }

  /**
   * LifeEvent without action
   */
  export type LifeEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LifeEvent
     */
    select?: LifeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LifeEventInclude<ExtArgs> | null
  }


  /**
   * Model StarSystem
   */

  export type AggregateStarSystem = {
    _count: StarSystemCountAggregateOutputType | null
    _avg: StarSystemAvgAggregateOutputType | null
    _sum: StarSystemSumAggregateOutputType | null
    _min: StarSystemMinAggregateOutputType | null
    _max: StarSystemMaxAggregateOutputType | null
  }

  export type StarSystemAvgAggregateOutputType = {
    gasGiants: number | null
  }

  export type StarSystemSumAggregateOutputType = {
    gasGiants: number | null
  }

  export type StarSystemMinAggregateOutputType = {
    id: string | null
    name: string | null
    hexLocation: string | null
    sector: string | null
    subsector: string | null
    allegiance: string | null
    starType: string | null
    gasGiants: number | null
    campaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StarSystemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    hexLocation: string | null
    sector: string | null
    subsector: string | null
    allegiance: string | null
    starType: string | null
    gasGiants: number | null
    campaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StarSystemCountAggregateOutputType = {
    id: number
    name: number
    hexLocation: number
    sector: number
    subsector: number
    allegiance: number
    starType: number
    gasGiants: number
    jumpRoutes: number
    campaignId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StarSystemAvgAggregateInputType = {
    gasGiants?: true
  }

  export type StarSystemSumAggregateInputType = {
    gasGiants?: true
  }

  export type StarSystemMinAggregateInputType = {
    id?: true
    name?: true
    hexLocation?: true
    sector?: true
    subsector?: true
    allegiance?: true
    starType?: true
    gasGiants?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StarSystemMaxAggregateInputType = {
    id?: true
    name?: true
    hexLocation?: true
    sector?: true
    subsector?: true
    allegiance?: true
    starType?: true
    gasGiants?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StarSystemCountAggregateInputType = {
    id?: true
    name?: true
    hexLocation?: true
    sector?: true
    subsector?: true
    allegiance?: true
    starType?: true
    gasGiants?: true
    jumpRoutes?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StarSystemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StarSystem to aggregate.
     */
    where?: StarSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StarSystems to fetch.
     */
    orderBy?: StarSystemOrderByWithRelationInput | StarSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StarSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StarSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StarSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StarSystems
    **/
    _count?: true | StarSystemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StarSystemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StarSystemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StarSystemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StarSystemMaxAggregateInputType
  }

  export type GetStarSystemAggregateType<T extends StarSystemAggregateArgs> = {
        [P in keyof T & keyof AggregateStarSystem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStarSystem[P]>
      : GetScalarType<T[P], AggregateStarSystem[P]>
  }




  export type StarSystemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StarSystemWhereInput
    orderBy?: StarSystemOrderByWithAggregationInput | StarSystemOrderByWithAggregationInput[]
    by: StarSystemScalarFieldEnum[] | StarSystemScalarFieldEnum
    having?: StarSystemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StarSystemCountAggregateInputType | true
    _avg?: StarSystemAvgAggregateInputType
    _sum?: StarSystemSumAggregateInputType
    _min?: StarSystemMinAggregateInputType
    _max?: StarSystemMaxAggregateInputType
  }

  export type StarSystemGroupByOutputType = {
    id: string
    name: string
    hexLocation: string
    sector: string
    subsector: string | null
    allegiance: string | null
    starType: string | null
    gasGiants: number
    jumpRoutes: string[]
    campaignId: string | null
    createdAt: Date
    updatedAt: Date
    _count: StarSystemCountAggregateOutputType | null
    _avg: StarSystemAvgAggregateOutputType | null
    _sum: StarSystemSumAggregateOutputType | null
    _min: StarSystemMinAggregateOutputType | null
    _max: StarSystemMaxAggregateOutputType | null
  }

  type GetStarSystemGroupByPayload<T extends StarSystemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StarSystemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StarSystemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StarSystemGroupByOutputType[P]>
            : GetScalarType<T[P], StarSystemGroupByOutputType[P]>
        }
      >
    >


  export type StarSystemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    hexLocation?: boolean
    sector?: boolean
    subsector?: boolean
    allegiance?: boolean
    starType?: boolean
    gasGiants?: boolean
    jumpRoutes?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | StarSystem$campaignArgs<ExtArgs>
    planets?: boolean | StarSystem$planetsArgs<ExtArgs>
    tradeRoutes?: boolean | StarSystem$tradeRoutesArgs<ExtArgs>
    tradeRoutesDestination?: boolean | StarSystem$tradeRoutesDestinationArgs<ExtArgs>
    _count?: boolean | StarSystemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["starSystem"]>

  export type StarSystemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    hexLocation?: boolean
    sector?: boolean
    subsector?: boolean
    allegiance?: boolean
    starType?: boolean
    gasGiants?: boolean
    jumpRoutes?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | StarSystem$campaignArgs<ExtArgs>
  }, ExtArgs["result"]["starSystem"]>

  export type StarSystemSelectScalar = {
    id?: boolean
    name?: boolean
    hexLocation?: boolean
    sector?: boolean
    subsector?: boolean
    allegiance?: boolean
    starType?: boolean
    gasGiants?: boolean
    jumpRoutes?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StarSystemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | StarSystem$campaignArgs<ExtArgs>
    planets?: boolean | StarSystem$planetsArgs<ExtArgs>
    tradeRoutes?: boolean | StarSystem$tradeRoutesArgs<ExtArgs>
    tradeRoutesDestination?: boolean | StarSystem$tradeRoutesDestinationArgs<ExtArgs>
    _count?: boolean | StarSystemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StarSystemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | StarSystem$campaignArgs<ExtArgs>
  }

  export type $StarSystemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StarSystem"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs> | null
      planets: Prisma.$PlanetPayload<ExtArgs>[]
      tradeRoutes: Prisma.$TradeRoutePayload<ExtArgs>[]
      tradeRoutesDestination: Prisma.$TradeRoutePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      hexLocation: string
      sector: string
      subsector: string | null
      allegiance: string | null
      starType: string | null
      gasGiants: number
      jumpRoutes: string[]
      campaignId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["starSystem"]>
    composites: {}
  }

  type StarSystemGetPayload<S extends boolean | null | undefined | StarSystemDefaultArgs> = $Result.GetResult<Prisma.$StarSystemPayload, S>

  type StarSystemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StarSystemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StarSystemCountAggregateInputType | true
    }

  export interface StarSystemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StarSystem'], meta: { name: 'StarSystem' } }
    /**
     * Find zero or one StarSystem that matches the filter.
     * @param {StarSystemFindUniqueArgs} args - Arguments to find a StarSystem
     * @example
     * // Get one StarSystem
     * const starSystem = await prisma.starSystem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StarSystemFindUniqueArgs>(args: SelectSubset<T, StarSystemFindUniqueArgs<ExtArgs>>): Prisma__StarSystemClient<$Result.GetResult<Prisma.$StarSystemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StarSystem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StarSystemFindUniqueOrThrowArgs} args - Arguments to find a StarSystem
     * @example
     * // Get one StarSystem
     * const starSystem = await prisma.starSystem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StarSystemFindUniqueOrThrowArgs>(args: SelectSubset<T, StarSystemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StarSystemClient<$Result.GetResult<Prisma.$StarSystemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StarSystem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StarSystemFindFirstArgs} args - Arguments to find a StarSystem
     * @example
     * // Get one StarSystem
     * const starSystem = await prisma.starSystem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StarSystemFindFirstArgs>(args?: SelectSubset<T, StarSystemFindFirstArgs<ExtArgs>>): Prisma__StarSystemClient<$Result.GetResult<Prisma.$StarSystemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StarSystem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StarSystemFindFirstOrThrowArgs} args - Arguments to find a StarSystem
     * @example
     * // Get one StarSystem
     * const starSystem = await prisma.starSystem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StarSystemFindFirstOrThrowArgs>(args?: SelectSubset<T, StarSystemFindFirstOrThrowArgs<ExtArgs>>): Prisma__StarSystemClient<$Result.GetResult<Prisma.$StarSystemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StarSystems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StarSystemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StarSystems
     * const starSystems = await prisma.starSystem.findMany()
     * 
     * // Get first 10 StarSystems
     * const starSystems = await prisma.starSystem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const starSystemWithIdOnly = await prisma.starSystem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StarSystemFindManyArgs>(args?: SelectSubset<T, StarSystemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StarSystemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StarSystem.
     * @param {StarSystemCreateArgs} args - Arguments to create a StarSystem.
     * @example
     * // Create one StarSystem
     * const StarSystem = await prisma.starSystem.create({
     *   data: {
     *     // ... data to create a StarSystem
     *   }
     * })
     * 
     */
    create<T extends StarSystemCreateArgs>(args: SelectSubset<T, StarSystemCreateArgs<ExtArgs>>): Prisma__StarSystemClient<$Result.GetResult<Prisma.$StarSystemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StarSystems.
     * @param {StarSystemCreateManyArgs} args - Arguments to create many StarSystems.
     * @example
     * // Create many StarSystems
     * const starSystem = await prisma.starSystem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StarSystemCreateManyArgs>(args?: SelectSubset<T, StarSystemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StarSystems and returns the data saved in the database.
     * @param {StarSystemCreateManyAndReturnArgs} args - Arguments to create many StarSystems.
     * @example
     * // Create many StarSystems
     * const starSystem = await prisma.starSystem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StarSystems and only return the `id`
     * const starSystemWithIdOnly = await prisma.starSystem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StarSystemCreateManyAndReturnArgs>(args?: SelectSubset<T, StarSystemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StarSystemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StarSystem.
     * @param {StarSystemDeleteArgs} args - Arguments to delete one StarSystem.
     * @example
     * // Delete one StarSystem
     * const StarSystem = await prisma.starSystem.delete({
     *   where: {
     *     // ... filter to delete one StarSystem
     *   }
     * })
     * 
     */
    delete<T extends StarSystemDeleteArgs>(args: SelectSubset<T, StarSystemDeleteArgs<ExtArgs>>): Prisma__StarSystemClient<$Result.GetResult<Prisma.$StarSystemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StarSystem.
     * @param {StarSystemUpdateArgs} args - Arguments to update one StarSystem.
     * @example
     * // Update one StarSystem
     * const starSystem = await prisma.starSystem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StarSystemUpdateArgs>(args: SelectSubset<T, StarSystemUpdateArgs<ExtArgs>>): Prisma__StarSystemClient<$Result.GetResult<Prisma.$StarSystemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StarSystems.
     * @param {StarSystemDeleteManyArgs} args - Arguments to filter StarSystems to delete.
     * @example
     * // Delete a few StarSystems
     * const { count } = await prisma.starSystem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StarSystemDeleteManyArgs>(args?: SelectSubset<T, StarSystemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StarSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StarSystemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StarSystems
     * const starSystem = await prisma.starSystem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StarSystemUpdateManyArgs>(args: SelectSubset<T, StarSystemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StarSystem.
     * @param {StarSystemUpsertArgs} args - Arguments to update or create a StarSystem.
     * @example
     * // Update or create a StarSystem
     * const starSystem = await prisma.starSystem.upsert({
     *   create: {
     *     // ... data to create a StarSystem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StarSystem we want to update
     *   }
     * })
     */
    upsert<T extends StarSystemUpsertArgs>(args: SelectSubset<T, StarSystemUpsertArgs<ExtArgs>>): Prisma__StarSystemClient<$Result.GetResult<Prisma.$StarSystemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StarSystems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StarSystemCountArgs} args - Arguments to filter StarSystems to count.
     * @example
     * // Count the number of StarSystems
     * const count = await prisma.starSystem.count({
     *   where: {
     *     // ... the filter for the StarSystems we want to count
     *   }
     * })
    **/
    count<T extends StarSystemCountArgs>(
      args?: Subset<T, StarSystemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StarSystemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StarSystem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StarSystemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StarSystemAggregateArgs>(args: Subset<T, StarSystemAggregateArgs>): Prisma.PrismaPromise<GetStarSystemAggregateType<T>>

    /**
     * Group by StarSystem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StarSystemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StarSystemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StarSystemGroupByArgs['orderBy'] }
        : { orderBy?: StarSystemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StarSystemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStarSystemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StarSystem model
   */
  readonly fields: StarSystemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StarSystem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StarSystemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends StarSystem$campaignArgs<ExtArgs> = {}>(args?: Subset<T, StarSystem$campaignArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    planets<T extends StarSystem$planetsArgs<ExtArgs> = {}>(args?: Subset<T, StarSystem$planetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanetPayload<ExtArgs>, T, "findMany"> | Null>
    tradeRoutes<T extends StarSystem$tradeRoutesArgs<ExtArgs> = {}>(args?: Subset<T, StarSystem$tradeRoutesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeRoutePayload<ExtArgs>, T, "findMany"> | Null>
    tradeRoutesDestination<T extends StarSystem$tradeRoutesDestinationArgs<ExtArgs> = {}>(args?: Subset<T, StarSystem$tradeRoutesDestinationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeRoutePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StarSystem model
   */ 
  interface StarSystemFieldRefs {
    readonly id: FieldRef<"StarSystem", 'String'>
    readonly name: FieldRef<"StarSystem", 'String'>
    readonly hexLocation: FieldRef<"StarSystem", 'String'>
    readonly sector: FieldRef<"StarSystem", 'String'>
    readonly subsector: FieldRef<"StarSystem", 'String'>
    readonly allegiance: FieldRef<"StarSystem", 'String'>
    readonly starType: FieldRef<"StarSystem", 'String'>
    readonly gasGiants: FieldRef<"StarSystem", 'Int'>
    readonly jumpRoutes: FieldRef<"StarSystem", 'String[]'>
    readonly campaignId: FieldRef<"StarSystem", 'String'>
    readonly createdAt: FieldRef<"StarSystem", 'DateTime'>
    readonly updatedAt: FieldRef<"StarSystem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StarSystem findUnique
   */
  export type StarSystemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StarSystem
     */
    select?: StarSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarSystemInclude<ExtArgs> | null
    /**
     * Filter, which StarSystem to fetch.
     */
    where: StarSystemWhereUniqueInput
  }

  /**
   * StarSystem findUniqueOrThrow
   */
  export type StarSystemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StarSystem
     */
    select?: StarSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarSystemInclude<ExtArgs> | null
    /**
     * Filter, which StarSystem to fetch.
     */
    where: StarSystemWhereUniqueInput
  }

  /**
   * StarSystem findFirst
   */
  export type StarSystemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StarSystem
     */
    select?: StarSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarSystemInclude<ExtArgs> | null
    /**
     * Filter, which StarSystem to fetch.
     */
    where?: StarSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StarSystems to fetch.
     */
    orderBy?: StarSystemOrderByWithRelationInput | StarSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StarSystems.
     */
    cursor?: StarSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StarSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StarSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StarSystems.
     */
    distinct?: StarSystemScalarFieldEnum | StarSystemScalarFieldEnum[]
  }

  /**
   * StarSystem findFirstOrThrow
   */
  export type StarSystemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StarSystem
     */
    select?: StarSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarSystemInclude<ExtArgs> | null
    /**
     * Filter, which StarSystem to fetch.
     */
    where?: StarSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StarSystems to fetch.
     */
    orderBy?: StarSystemOrderByWithRelationInput | StarSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StarSystems.
     */
    cursor?: StarSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StarSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StarSystems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StarSystems.
     */
    distinct?: StarSystemScalarFieldEnum | StarSystemScalarFieldEnum[]
  }

  /**
   * StarSystem findMany
   */
  export type StarSystemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StarSystem
     */
    select?: StarSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarSystemInclude<ExtArgs> | null
    /**
     * Filter, which StarSystems to fetch.
     */
    where?: StarSystemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StarSystems to fetch.
     */
    orderBy?: StarSystemOrderByWithRelationInput | StarSystemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StarSystems.
     */
    cursor?: StarSystemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StarSystems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StarSystems.
     */
    skip?: number
    distinct?: StarSystemScalarFieldEnum | StarSystemScalarFieldEnum[]
  }

  /**
   * StarSystem create
   */
  export type StarSystemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StarSystem
     */
    select?: StarSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarSystemInclude<ExtArgs> | null
    /**
     * The data needed to create a StarSystem.
     */
    data: XOR<StarSystemCreateInput, StarSystemUncheckedCreateInput>
  }

  /**
   * StarSystem createMany
   */
  export type StarSystemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StarSystems.
     */
    data: StarSystemCreateManyInput | StarSystemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StarSystem createManyAndReturn
   */
  export type StarSystemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StarSystem
     */
    select?: StarSystemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StarSystems.
     */
    data: StarSystemCreateManyInput | StarSystemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarSystemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StarSystem update
   */
  export type StarSystemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StarSystem
     */
    select?: StarSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarSystemInclude<ExtArgs> | null
    /**
     * The data needed to update a StarSystem.
     */
    data: XOR<StarSystemUpdateInput, StarSystemUncheckedUpdateInput>
    /**
     * Choose, which StarSystem to update.
     */
    where: StarSystemWhereUniqueInput
  }

  /**
   * StarSystem updateMany
   */
  export type StarSystemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StarSystems.
     */
    data: XOR<StarSystemUpdateManyMutationInput, StarSystemUncheckedUpdateManyInput>
    /**
     * Filter which StarSystems to update
     */
    where?: StarSystemWhereInput
  }

  /**
   * StarSystem upsert
   */
  export type StarSystemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StarSystem
     */
    select?: StarSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarSystemInclude<ExtArgs> | null
    /**
     * The filter to search for the StarSystem to update in case it exists.
     */
    where: StarSystemWhereUniqueInput
    /**
     * In case the StarSystem found by the `where` argument doesn't exist, create a new StarSystem with this data.
     */
    create: XOR<StarSystemCreateInput, StarSystemUncheckedCreateInput>
    /**
     * In case the StarSystem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StarSystemUpdateInput, StarSystemUncheckedUpdateInput>
  }

  /**
   * StarSystem delete
   */
  export type StarSystemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StarSystem
     */
    select?: StarSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarSystemInclude<ExtArgs> | null
    /**
     * Filter which StarSystem to delete.
     */
    where: StarSystemWhereUniqueInput
  }

  /**
   * StarSystem deleteMany
   */
  export type StarSystemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StarSystems to delete
     */
    where?: StarSystemWhereInput
  }

  /**
   * StarSystem.campaign
   */
  export type StarSystem$campaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
  }

  /**
   * StarSystem.planets
   */
  export type StarSystem$planetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planet
     */
    select?: PlanetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanetInclude<ExtArgs> | null
    where?: PlanetWhereInput
    orderBy?: PlanetOrderByWithRelationInput | PlanetOrderByWithRelationInput[]
    cursor?: PlanetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanetScalarFieldEnum | PlanetScalarFieldEnum[]
  }

  /**
   * StarSystem.tradeRoutes
   */
  export type StarSystem$tradeRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeRoute
     */
    select?: TradeRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeRouteInclude<ExtArgs> | null
    where?: TradeRouteWhereInput
    orderBy?: TradeRouteOrderByWithRelationInput | TradeRouteOrderByWithRelationInput[]
    cursor?: TradeRouteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeRouteScalarFieldEnum | TradeRouteScalarFieldEnum[]
  }

  /**
   * StarSystem.tradeRoutesDestination
   */
  export type StarSystem$tradeRoutesDestinationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeRoute
     */
    select?: TradeRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeRouteInclude<ExtArgs> | null
    where?: TradeRouteWhereInput
    orderBy?: TradeRouteOrderByWithRelationInput | TradeRouteOrderByWithRelationInput[]
    cursor?: TradeRouteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeRouteScalarFieldEnum | TradeRouteScalarFieldEnum[]
  }

  /**
   * StarSystem without action
   */
  export type StarSystemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StarSystem
     */
    select?: StarSystemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarSystemInclude<ExtArgs> | null
  }


  /**
   * Model Planet
   */

  export type AggregatePlanet = {
    _count: PlanetCountAggregateOutputType | null
    _avg: PlanetAvgAggregateOutputType | null
    _sum: PlanetSumAggregateOutputType | null
    _min: PlanetMinAggregateOutputType | null
    _max: PlanetMaxAggregateOutputType | null
  }

  export type PlanetAvgAggregateOutputType = {
    size: number | null
    atmosphere: number | null
    hydrographics: number | null
    population: number | null
    government: number | null
    lawLevel: number | null
    techLevel: number | null
  }

  export type PlanetSumAggregateOutputType = {
    size: number | null
    atmosphere: number | null
    hydrographics: number | null
    population: number | null
    government: number | null
    lawLevel: number | null
    techLevel: number | null
  }

  export type PlanetMinAggregateOutputType = {
    id: string | null
    name: string | null
    uwp: string | null
    size: number | null
    atmosphere: number | null
    hydrographics: number | null
    population: number | null
    government: number | null
    lawLevel: number | null
    techLevel: number | null
    starport: string | null
    gasGiant: boolean | null
    description: string | null
    notes: string | null
    starSystemId: string | null
  }

  export type PlanetMaxAggregateOutputType = {
    id: string | null
    name: string | null
    uwp: string | null
    size: number | null
    atmosphere: number | null
    hydrographics: number | null
    population: number | null
    government: number | null
    lawLevel: number | null
    techLevel: number | null
    starport: string | null
    gasGiant: boolean | null
    description: string | null
    notes: string | null
    starSystemId: string | null
  }

  export type PlanetCountAggregateOutputType = {
    id: number
    name: number
    uwp: number
    size: number
    atmosphere: number
    hydrographics: number
    population: number
    government: number
    lawLevel: number
    techLevel: number
    starport: number
    tradeCodes: number
    bases: number
    gasGiant: number
    description: number
    notes: number
    starSystemId: number
    _all: number
  }


  export type PlanetAvgAggregateInputType = {
    size?: true
    atmosphere?: true
    hydrographics?: true
    population?: true
    government?: true
    lawLevel?: true
    techLevel?: true
  }

  export type PlanetSumAggregateInputType = {
    size?: true
    atmosphere?: true
    hydrographics?: true
    population?: true
    government?: true
    lawLevel?: true
    techLevel?: true
  }

  export type PlanetMinAggregateInputType = {
    id?: true
    name?: true
    uwp?: true
    size?: true
    atmosphere?: true
    hydrographics?: true
    population?: true
    government?: true
    lawLevel?: true
    techLevel?: true
    starport?: true
    gasGiant?: true
    description?: true
    notes?: true
    starSystemId?: true
  }

  export type PlanetMaxAggregateInputType = {
    id?: true
    name?: true
    uwp?: true
    size?: true
    atmosphere?: true
    hydrographics?: true
    population?: true
    government?: true
    lawLevel?: true
    techLevel?: true
    starport?: true
    gasGiant?: true
    description?: true
    notes?: true
    starSystemId?: true
  }

  export type PlanetCountAggregateInputType = {
    id?: true
    name?: true
    uwp?: true
    size?: true
    atmosphere?: true
    hydrographics?: true
    population?: true
    government?: true
    lawLevel?: true
    techLevel?: true
    starport?: true
    tradeCodes?: true
    bases?: true
    gasGiant?: true
    description?: true
    notes?: true
    starSystemId?: true
    _all?: true
  }

  export type PlanetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Planet to aggregate.
     */
    where?: PlanetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Planets to fetch.
     */
    orderBy?: PlanetOrderByWithRelationInput | PlanetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Planets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Planets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Planets
    **/
    _count?: true | PlanetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanetMaxAggregateInputType
  }

  export type GetPlanetAggregateType<T extends PlanetAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanet[P]>
      : GetScalarType<T[P], AggregatePlanet[P]>
  }




  export type PlanetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanetWhereInput
    orderBy?: PlanetOrderByWithAggregationInput | PlanetOrderByWithAggregationInput[]
    by: PlanetScalarFieldEnum[] | PlanetScalarFieldEnum
    having?: PlanetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanetCountAggregateInputType | true
    _avg?: PlanetAvgAggregateInputType
    _sum?: PlanetSumAggregateInputType
    _min?: PlanetMinAggregateInputType
    _max?: PlanetMaxAggregateInputType
  }

  export type PlanetGroupByOutputType = {
    id: string
    name: string
    uwp: string
    size: number
    atmosphere: number
    hydrographics: number
    population: number
    government: number
    lawLevel: number
    techLevel: number
    starport: string
    tradeCodes: string[]
    bases: string[]
    gasGiant: boolean
    description: string | null
    notes: string | null
    starSystemId: string
    _count: PlanetCountAggregateOutputType | null
    _avg: PlanetAvgAggregateOutputType | null
    _sum: PlanetSumAggregateOutputType | null
    _min: PlanetMinAggregateOutputType | null
    _max: PlanetMaxAggregateOutputType | null
  }

  type GetPlanetGroupByPayload<T extends PlanetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanetGroupByOutputType[P]>
            : GetScalarType<T[P], PlanetGroupByOutputType[P]>
        }
      >
    >


  export type PlanetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    uwp?: boolean
    size?: boolean
    atmosphere?: boolean
    hydrographics?: boolean
    population?: boolean
    government?: boolean
    lawLevel?: boolean
    techLevel?: boolean
    starport?: boolean
    tradeCodes?: boolean
    bases?: boolean
    gasGiant?: boolean
    description?: boolean
    notes?: boolean
    starSystemId?: boolean
    starSystem?: boolean | StarSystemDefaultArgs<ExtArgs>
    tradeGoods?: boolean | Planet$tradeGoodsArgs<ExtArgs>
    _count?: boolean | PlanetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planet"]>

  export type PlanetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    uwp?: boolean
    size?: boolean
    atmosphere?: boolean
    hydrographics?: boolean
    population?: boolean
    government?: boolean
    lawLevel?: boolean
    techLevel?: boolean
    starport?: boolean
    tradeCodes?: boolean
    bases?: boolean
    gasGiant?: boolean
    description?: boolean
    notes?: boolean
    starSystemId?: boolean
    starSystem?: boolean | StarSystemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planet"]>

  export type PlanetSelectScalar = {
    id?: boolean
    name?: boolean
    uwp?: boolean
    size?: boolean
    atmosphere?: boolean
    hydrographics?: boolean
    population?: boolean
    government?: boolean
    lawLevel?: boolean
    techLevel?: boolean
    starport?: boolean
    tradeCodes?: boolean
    bases?: boolean
    gasGiant?: boolean
    description?: boolean
    notes?: boolean
    starSystemId?: boolean
  }

  export type PlanetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    starSystem?: boolean | StarSystemDefaultArgs<ExtArgs>
    tradeGoods?: boolean | Planet$tradeGoodsArgs<ExtArgs>
    _count?: boolean | PlanetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    starSystem?: boolean | StarSystemDefaultArgs<ExtArgs>
  }

  export type $PlanetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Planet"
    objects: {
      starSystem: Prisma.$StarSystemPayload<ExtArgs>
      tradeGoods: Prisma.$TradeGoodPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      uwp: string
      size: number
      atmosphere: number
      hydrographics: number
      population: number
      government: number
      lawLevel: number
      techLevel: number
      starport: string
      tradeCodes: string[]
      bases: string[]
      gasGiant: boolean
      description: string | null
      notes: string | null
      starSystemId: string
    }, ExtArgs["result"]["planet"]>
    composites: {}
  }

  type PlanetGetPayload<S extends boolean | null | undefined | PlanetDefaultArgs> = $Result.GetResult<Prisma.$PlanetPayload, S>

  type PlanetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanetCountAggregateInputType | true
    }

  export interface PlanetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Planet'], meta: { name: 'Planet' } }
    /**
     * Find zero or one Planet that matches the filter.
     * @param {PlanetFindUniqueArgs} args - Arguments to find a Planet
     * @example
     * // Get one Planet
     * const planet = await prisma.planet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanetFindUniqueArgs>(args: SelectSubset<T, PlanetFindUniqueArgs<ExtArgs>>): Prisma__PlanetClient<$Result.GetResult<Prisma.$PlanetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Planet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanetFindUniqueOrThrowArgs} args - Arguments to find a Planet
     * @example
     * // Get one Planet
     * const planet = await prisma.planet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanetFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanetClient<$Result.GetResult<Prisma.$PlanetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Planet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanetFindFirstArgs} args - Arguments to find a Planet
     * @example
     * // Get one Planet
     * const planet = await prisma.planet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanetFindFirstArgs>(args?: SelectSubset<T, PlanetFindFirstArgs<ExtArgs>>): Prisma__PlanetClient<$Result.GetResult<Prisma.$PlanetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Planet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanetFindFirstOrThrowArgs} args - Arguments to find a Planet
     * @example
     * // Get one Planet
     * const planet = await prisma.planet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanetFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanetFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanetClient<$Result.GetResult<Prisma.$PlanetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Planets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Planets
     * const planets = await prisma.planet.findMany()
     * 
     * // Get first 10 Planets
     * const planets = await prisma.planet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planetWithIdOnly = await prisma.planet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanetFindManyArgs>(args?: SelectSubset<T, PlanetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Planet.
     * @param {PlanetCreateArgs} args - Arguments to create a Planet.
     * @example
     * // Create one Planet
     * const Planet = await prisma.planet.create({
     *   data: {
     *     // ... data to create a Planet
     *   }
     * })
     * 
     */
    create<T extends PlanetCreateArgs>(args: SelectSubset<T, PlanetCreateArgs<ExtArgs>>): Prisma__PlanetClient<$Result.GetResult<Prisma.$PlanetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Planets.
     * @param {PlanetCreateManyArgs} args - Arguments to create many Planets.
     * @example
     * // Create many Planets
     * const planet = await prisma.planet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanetCreateManyArgs>(args?: SelectSubset<T, PlanetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Planets and returns the data saved in the database.
     * @param {PlanetCreateManyAndReturnArgs} args - Arguments to create many Planets.
     * @example
     * // Create many Planets
     * const planet = await prisma.planet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Planets and only return the `id`
     * const planetWithIdOnly = await prisma.planet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanetCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Planet.
     * @param {PlanetDeleteArgs} args - Arguments to delete one Planet.
     * @example
     * // Delete one Planet
     * const Planet = await prisma.planet.delete({
     *   where: {
     *     // ... filter to delete one Planet
     *   }
     * })
     * 
     */
    delete<T extends PlanetDeleteArgs>(args: SelectSubset<T, PlanetDeleteArgs<ExtArgs>>): Prisma__PlanetClient<$Result.GetResult<Prisma.$PlanetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Planet.
     * @param {PlanetUpdateArgs} args - Arguments to update one Planet.
     * @example
     * // Update one Planet
     * const planet = await prisma.planet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanetUpdateArgs>(args: SelectSubset<T, PlanetUpdateArgs<ExtArgs>>): Prisma__PlanetClient<$Result.GetResult<Prisma.$PlanetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Planets.
     * @param {PlanetDeleteManyArgs} args - Arguments to filter Planets to delete.
     * @example
     * // Delete a few Planets
     * const { count } = await prisma.planet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanetDeleteManyArgs>(args?: SelectSubset<T, PlanetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Planets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Planets
     * const planet = await prisma.planet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanetUpdateManyArgs>(args: SelectSubset<T, PlanetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Planet.
     * @param {PlanetUpsertArgs} args - Arguments to update or create a Planet.
     * @example
     * // Update or create a Planet
     * const planet = await prisma.planet.upsert({
     *   create: {
     *     // ... data to create a Planet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Planet we want to update
     *   }
     * })
     */
    upsert<T extends PlanetUpsertArgs>(args: SelectSubset<T, PlanetUpsertArgs<ExtArgs>>): Prisma__PlanetClient<$Result.GetResult<Prisma.$PlanetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Planets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanetCountArgs} args - Arguments to filter Planets to count.
     * @example
     * // Count the number of Planets
     * const count = await prisma.planet.count({
     *   where: {
     *     // ... the filter for the Planets we want to count
     *   }
     * })
    **/
    count<T extends PlanetCountArgs>(
      args?: Subset<T, PlanetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Planet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanetAggregateArgs>(args: Subset<T, PlanetAggregateArgs>): Prisma.PrismaPromise<GetPlanetAggregateType<T>>

    /**
     * Group by Planet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanetGroupByArgs['orderBy'] }
        : { orderBy?: PlanetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Planet model
   */
  readonly fields: PlanetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Planet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    starSystem<T extends StarSystemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StarSystemDefaultArgs<ExtArgs>>): Prisma__StarSystemClient<$Result.GetResult<Prisma.$StarSystemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tradeGoods<T extends Planet$tradeGoodsArgs<ExtArgs> = {}>(args?: Subset<T, Planet$tradeGoodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeGoodPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Planet model
   */ 
  interface PlanetFieldRefs {
    readonly id: FieldRef<"Planet", 'String'>
    readonly name: FieldRef<"Planet", 'String'>
    readonly uwp: FieldRef<"Planet", 'String'>
    readonly size: FieldRef<"Planet", 'Int'>
    readonly atmosphere: FieldRef<"Planet", 'Int'>
    readonly hydrographics: FieldRef<"Planet", 'Int'>
    readonly population: FieldRef<"Planet", 'Int'>
    readonly government: FieldRef<"Planet", 'Int'>
    readonly lawLevel: FieldRef<"Planet", 'Int'>
    readonly techLevel: FieldRef<"Planet", 'Int'>
    readonly starport: FieldRef<"Planet", 'String'>
    readonly tradeCodes: FieldRef<"Planet", 'String[]'>
    readonly bases: FieldRef<"Planet", 'String[]'>
    readonly gasGiant: FieldRef<"Planet", 'Boolean'>
    readonly description: FieldRef<"Planet", 'String'>
    readonly notes: FieldRef<"Planet", 'String'>
    readonly starSystemId: FieldRef<"Planet", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Planet findUnique
   */
  export type PlanetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planet
     */
    select?: PlanetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanetInclude<ExtArgs> | null
    /**
     * Filter, which Planet to fetch.
     */
    where: PlanetWhereUniqueInput
  }

  /**
   * Planet findUniqueOrThrow
   */
  export type PlanetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planet
     */
    select?: PlanetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanetInclude<ExtArgs> | null
    /**
     * Filter, which Planet to fetch.
     */
    where: PlanetWhereUniqueInput
  }

  /**
   * Planet findFirst
   */
  export type PlanetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planet
     */
    select?: PlanetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanetInclude<ExtArgs> | null
    /**
     * Filter, which Planet to fetch.
     */
    where?: PlanetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Planets to fetch.
     */
    orderBy?: PlanetOrderByWithRelationInput | PlanetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Planets.
     */
    cursor?: PlanetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Planets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Planets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Planets.
     */
    distinct?: PlanetScalarFieldEnum | PlanetScalarFieldEnum[]
  }

  /**
   * Planet findFirstOrThrow
   */
  export type PlanetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planet
     */
    select?: PlanetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanetInclude<ExtArgs> | null
    /**
     * Filter, which Planet to fetch.
     */
    where?: PlanetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Planets to fetch.
     */
    orderBy?: PlanetOrderByWithRelationInput | PlanetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Planets.
     */
    cursor?: PlanetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Planets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Planets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Planets.
     */
    distinct?: PlanetScalarFieldEnum | PlanetScalarFieldEnum[]
  }

  /**
   * Planet findMany
   */
  export type PlanetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planet
     */
    select?: PlanetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanetInclude<ExtArgs> | null
    /**
     * Filter, which Planets to fetch.
     */
    where?: PlanetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Planets to fetch.
     */
    orderBy?: PlanetOrderByWithRelationInput | PlanetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Planets.
     */
    cursor?: PlanetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Planets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Planets.
     */
    skip?: number
    distinct?: PlanetScalarFieldEnum | PlanetScalarFieldEnum[]
  }

  /**
   * Planet create
   */
  export type PlanetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planet
     */
    select?: PlanetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanetInclude<ExtArgs> | null
    /**
     * The data needed to create a Planet.
     */
    data: XOR<PlanetCreateInput, PlanetUncheckedCreateInput>
  }

  /**
   * Planet createMany
   */
  export type PlanetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Planets.
     */
    data: PlanetCreateManyInput | PlanetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Planet createManyAndReturn
   */
  export type PlanetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planet
     */
    select?: PlanetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Planets.
     */
    data: PlanetCreateManyInput | PlanetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Planet update
   */
  export type PlanetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planet
     */
    select?: PlanetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanetInclude<ExtArgs> | null
    /**
     * The data needed to update a Planet.
     */
    data: XOR<PlanetUpdateInput, PlanetUncheckedUpdateInput>
    /**
     * Choose, which Planet to update.
     */
    where: PlanetWhereUniqueInput
  }

  /**
   * Planet updateMany
   */
  export type PlanetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Planets.
     */
    data: XOR<PlanetUpdateManyMutationInput, PlanetUncheckedUpdateManyInput>
    /**
     * Filter which Planets to update
     */
    where?: PlanetWhereInput
  }

  /**
   * Planet upsert
   */
  export type PlanetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planet
     */
    select?: PlanetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanetInclude<ExtArgs> | null
    /**
     * The filter to search for the Planet to update in case it exists.
     */
    where: PlanetWhereUniqueInput
    /**
     * In case the Planet found by the `where` argument doesn't exist, create a new Planet with this data.
     */
    create: XOR<PlanetCreateInput, PlanetUncheckedCreateInput>
    /**
     * In case the Planet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanetUpdateInput, PlanetUncheckedUpdateInput>
  }

  /**
   * Planet delete
   */
  export type PlanetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planet
     */
    select?: PlanetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanetInclude<ExtArgs> | null
    /**
     * Filter which Planet to delete.
     */
    where: PlanetWhereUniqueInput
  }

  /**
   * Planet deleteMany
   */
  export type PlanetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Planets to delete
     */
    where?: PlanetWhereInput
  }

  /**
   * Planet.tradeGoods
   */
  export type Planet$tradeGoodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeGood
     */
    select?: TradeGoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeGoodInclude<ExtArgs> | null
    where?: TradeGoodWhereInput
    orderBy?: TradeGoodOrderByWithRelationInput | TradeGoodOrderByWithRelationInput[]
    cursor?: TradeGoodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradeGoodScalarFieldEnum | TradeGoodScalarFieldEnum[]
  }

  /**
   * Planet without action
   */
  export type PlanetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planet
     */
    select?: PlanetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanetInclude<ExtArgs> | null
  }


  /**
   * Model Starship
   */

  export type AggregateStarship = {
    _count: StarshipCountAggregateOutputType | null
    _avg: StarshipAvgAggregateOutputType | null
    _sum: StarshipSumAggregateOutputType | null
    _min: StarshipMinAggregateOutputType | null
    _max: StarshipMaxAggregateOutputType | null
  }

  export type StarshipAvgAggregateOutputType = {
    tonnage: number | null
    jumpDrive: number | null
    maneuverDrive: number | null
    powerPlant: number | null
    crew: number | null
    passengers: number | null
    cargo: number | null
    fuel: number | null
    armor: number | null
  }

  export type StarshipSumAggregateOutputType = {
    tonnage: number | null
    jumpDrive: number | null
    maneuverDrive: number | null
    powerPlant: number | null
    crew: number | null
    passengers: number | null
    cargo: number | null
    fuel: number | null
    armor: number | null
  }

  export type StarshipMinAggregateOutputType = {
    id: string | null
    name: string | null
    class: string | null
    hullCode: string | null
    tonnage: number | null
    jumpDrive: number | null
    maneuverDrive: number | null
    powerPlant: number | null
    crew: number | null
    passengers: number | null
    cargo: number | null
    fuel: number | null
    armor: number | null
    status: string | null
    location: string | null
    owner: string | null
    campaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StarshipMaxAggregateOutputType = {
    id: string | null
    name: string | null
    class: string | null
    hullCode: string | null
    tonnage: number | null
    jumpDrive: number | null
    maneuverDrive: number | null
    powerPlant: number | null
    crew: number | null
    passengers: number | null
    cargo: number | null
    fuel: number | null
    armor: number | null
    status: string | null
    location: string | null
    owner: string | null
    campaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StarshipCountAggregateOutputType = {
    id: number
    name: number
    class: number
    hullCode: number
    tonnage: number
    jumpDrive: number
    maneuverDrive: number
    powerPlant: number
    crew: number
    passengers: number
    cargo: number
    fuel: number
    armor: number
    weapons: number
    status: number
    location: number
    owner: number
    campaignId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StarshipAvgAggregateInputType = {
    tonnage?: true
    jumpDrive?: true
    maneuverDrive?: true
    powerPlant?: true
    crew?: true
    passengers?: true
    cargo?: true
    fuel?: true
    armor?: true
  }

  export type StarshipSumAggregateInputType = {
    tonnage?: true
    jumpDrive?: true
    maneuverDrive?: true
    powerPlant?: true
    crew?: true
    passengers?: true
    cargo?: true
    fuel?: true
    armor?: true
  }

  export type StarshipMinAggregateInputType = {
    id?: true
    name?: true
    class?: true
    hullCode?: true
    tonnage?: true
    jumpDrive?: true
    maneuverDrive?: true
    powerPlant?: true
    crew?: true
    passengers?: true
    cargo?: true
    fuel?: true
    armor?: true
    status?: true
    location?: true
    owner?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StarshipMaxAggregateInputType = {
    id?: true
    name?: true
    class?: true
    hullCode?: true
    tonnage?: true
    jumpDrive?: true
    maneuverDrive?: true
    powerPlant?: true
    crew?: true
    passengers?: true
    cargo?: true
    fuel?: true
    armor?: true
    status?: true
    location?: true
    owner?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StarshipCountAggregateInputType = {
    id?: true
    name?: true
    class?: true
    hullCode?: true
    tonnage?: true
    jumpDrive?: true
    maneuverDrive?: true
    powerPlant?: true
    crew?: true
    passengers?: true
    cargo?: true
    fuel?: true
    armor?: true
    weapons?: true
    status?: true
    location?: true
    owner?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StarshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Starship to aggregate.
     */
    where?: StarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Starships to fetch.
     */
    orderBy?: StarshipOrderByWithRelationInput | StarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Starships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Starships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Starships
    **/
    _count?: true | StarshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StarshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StarshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StarshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StarshipMaxAggregateInputType
  }

  export type GetStarshipAggregateType<T extends StarshipAggregateArgs> = {
        [P in keyof T & keyof AggregateStarship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStarship[P]>
      : GetScalarType<T[P], AggregateStarship[P]>
  }




  export type StarshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StarshipWhereInput
    orderBy?: StarshipOrderByWithAggregationInput | StarshipOrderByWithAggregationInput[]
    by: StarshipScalarFieldEnum[] | StarshipScalarFieldEnum
    having?: StarshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StarshipCountAggregateInputType | true
    _avg?: StarshipAvgAggregateInputType
    _sum?: StarshipSumAggregateInputType
    _min?: StarshipMinAggregateInputType
    _max?: StarshipMaxAggregateInputType
  }

  export type StarshipGroupByOutputType = {
    id: string
    name: string
    class: string
    hullCode: string | null
    tonnage: number
    jumpDrive: number
    maneuverDrive: number
    powerPlant: number
    crew: number
    passengers: number
    cargo: number
    fuel: number
    armor: number
    weapons: JsonValue | null
    status: string
    location: string | null
    owner: string | null
    campaignId: string | null
    createdAt: Date
    updatedAt: Date
    _count: StarshipCountAggregateOutputType | null
    _avg: StarshipAvgAggregateOutputType | null
    _sum: StarshipSumAggregateOutputType | null
    _min: StarshipMinAggregateOutputType | null
    _max: StarshipMaxAggregateOutputType | null
  }

  type GetStarshipGroupByPayload<T extends StarshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StarshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StarshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StarshipGroupByOutputType[P]>
            : GetScalarType<T[P], StarshipGroupByOutputType[P]>
        }
      >
    >


  export type StarshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    class?: boolean
    hullCode?: boolean
    tonnage?: boolean
    jumpDrive?: boolean
    maneuverDrive?: boolean
    powerPlant?: boolean
    crew?: boolean
    passengers?: boolean
    cargo?: boolean
    fuel?: boolean
    armor?: boolean
    weapons?: boolean
    status?: boolean
    location?: boolean
    owner?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | Starship$campaignArgs<ExtArgs>
  }, ExtArgs["result"]["starship"]>

  export type StarshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    class?: boolean
    hullCode?: boolean
    tonnage?: boolean
    jumpDrive?: boolean
    maneuverDrive?: boolean
    powerPlant?: boolean
    crew?: boolean
    passengers?: boolean
    cargo?: boolean
    fuel?: boolean
    armor?: boolean
    weapons?: boolean
    status?: boolean
    location?: boolean
    owner?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | Starship$campaignArgs<ExtArgs>
  }, ExtArgs["result"]["starship"]>

  export type StarshipSelectScalar = {
    id?: boolean
    name?: boolean
    class?: boolean
    hullCode?: boolean
    tonnage?: boolean
    jumpDrive?: boolean
    maneuverDrive?: boolean
    powerPlant?: boolean
    crew?: boolean
    passengers?: boolean
    cargo?: boolean
    fuel?: boolean
    armor?: boolean
    weapons?: boolean
    status?: boolean
    location?: boolean
    owner?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StarshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | Starship$campaignArgs<ExtArgs>
  }
  export type StarshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | Starship$campaignArgs<ExtArgs>
  }

  export type $StarshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Starship"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      class: string
      hullCode: string | null
      tonnage: number
      jumpDrive: number
      maneuverDrive: number
      powerPlant: number
      crew: number
      passengers: number
      cargo: number
      fuel: number
      armor: number
      weapons: Prisma.JsonValue | null
      status: string
      location: string | null
      owner: string | null
      campaignId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["starship"]>
    composites: {}
  }

  type StarshipGetPayload<S extends boolean | null | undefined | StarshipDefaultArgs> = $Result.GetResult<Prisma.$StarshipPayload, S>

  type StarshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StarshipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StarshipCountAggregateInputType | true
    }

  export interface StarshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Starship'], meta: { name: 'Starship' } }
    /**
     * Find zero or one Starship that matches the filter.
     * @param {StarshipFindUniqueArgs} args - Arguments to find a Starship
     * @example
     * // Get one Starship
     * const starship = await prisma.starship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StarshipFindUniqueArgs>(args: SelectSubset<T, StarshipFindUniqueArgs<ExtArgs>>): Prisma__StarshipClient<$Result.GetResult<Prisma.$StarshipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Starship that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StarshipFindUniqueOrThrowArgs} args - Arguments to find a Starship
     * @example
     * // Get one Starship
     * const starship = await prisma.starship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StarshipFindUniqueOrThrowArgs>(args: SelectSubset<T, StarshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StarshipClient<$Result.GetResult<Prisma.$StarshipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Starship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StarshipFindFirstArgs} args - Arguments to find a Starship
     * @example
     * // Get one Starship
     * const starship = await prisma.starship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StarshipFindFirstArgs>(args?: SelectSubset<T, StarshipFindFirstArgs<ExtArgs>>): Prisma__StarshipClient<$Result.GetResult<Prisma.$StarshipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Starship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StarshipFindFirstOrThrowArgs} args - Arguments to find a Starship
     * @example
     * // Get one Starship
     * const starship = await prisma.starship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StarshipFindFirstOrThrowArgs>(args?: SelectSubset<T, StarshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__StarshipClient<$Result.GetResult<Prisma.$StarshipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Starships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StarshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Starships
     * const starships = await prisma.starship.findMany()
     * 
     * // Get first 10 Starships
     * const starships = await prisma.starship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const starshipWithIdOnly = await prisma.starship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StarshipFindManyArgs>(args?: SelectSubset<T, StarshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StarshipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Starship.
     * @param {StarshipCreateArgs} args - Arguments to create a Starship.
     * @example
     * // Create one Starship
     * const Starship = await prisma.starship.create({
     *   data: {
     *     // ... data to create a Starship
     *   }
     * })
     * 
     */
    create<T extends StarshipCreateArgs>(args: SelectSubset<T, StarshipCreateArgs<ExtArgs>>): Prisma__StarshipClient<$Result.GetResult<Prisma.$StarshipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Starships.
     * @param {StarshipCreateManyArgs} args - Arguments to create many Starships.
     * @example
     * // Create many Starships
     * const starship = await prisma.starship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StarshipCreateManyArgs>(args?: SelectSubset<T, StarshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Starships and returns the data saved in the database.
     * @param {StarshipCreateManyAndReturnArgs} args - Arguments to create many Starships.
     * @example
     * // Create many Starships
     * const starship = await prisma.starship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Starships and only return the `id`
     * const starshipWithIdOnly = await prisma.starship.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StarshipCreateManyAndReturnArgs>(args?: SelectSubset<T, StarshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StarshipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Starship.
     * @param {StarshipDeleteArgs} args - Arguments to delete one Starship.
     * @example
     * // Delete one Starship
     * const Starship = await prisma.starship.delete({
     *   where: {
     *     // ... filter to delete one Starship
     *   }
     * })
     * 
     */
    delete<T extends StarshipDeleteArgs>(args: SelectSubset<T, StarshipDeleteArgs<ExtArgs>>): Prisma__StarshipClient<$Result.GetResult<Prisma.$StarshipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Starship.
     * @param {StarshipUpdateArgs} args - Arguments to update one Starship.
     * @example
     * // Update one Starship
     * const starship = await prisma.starship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StarshipUpdateArgs>(args: SelectSubset<T, StarshipUpdateArgs<ExtArgs>>): Prisma__StarshipClient<$Result.GetResult<Prisma.$StarshipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Starships.
     * @param {StarshipDeleteManyArgs} args - Arguments to filter Starships to delete.
     * @example
     * // Delete a few Starships
     * const { count } = await prisma.starship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StarshipDeleteManyArgs>(args?: SelectSubset<T, StarshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Starships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StarshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Starships
     * const starship = await prisma.starship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StarshipUpdateManyArgs>(args: SelectSubset<T, StarshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Starship.
     * @param {StarshipUpsertArgs} args - Arguments to update or create a Starship.
     * @example
     * // Update or create a Starship
     * const starship = await prisma.starship.upsert({
     *   create: {
     *     // ... data to create a Starship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Starship we want to update
     *   }
     * })
     */
    upsert<T extends StarshipUpsertArgs>(args: SelectSubset<T, StarshipUpsertArgs<ExtArgs>>): Prisma__StarshipClient<$Result.GetResult<Prisma.$StarshipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Starships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StarshipCountArgs} args - Arguments to filter Starships to count.
     * @example
     * // Count the number of Starships
     * const count = await prisma.starship.count({
     *   where: {
     *     // ... the filter for the Starships we want to count
     *   }
     * })
    **/
    count<T extends StarshipCountArgs>(
      args?: Subset<T, StarshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StarshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Starship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StarshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StarshipAggregateArgs>(args: Subset<T, StarshipAggregateArgs>): Prisma.PrismaPromise<GetStarshipAggregateType<T>>

    /**
     * Group by Starship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StarshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StarshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StarshipGroupByArgs['orderBy'] }
        : { orderBy?: StarshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StarshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStarshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Starship model
   */
  readonly fields: StarshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Starship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StarshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends Starship$campaignArgs<ExtArgs> = {}>(args?: Subset<T, Starship$campaignArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Starship model
   */ 
  interface StarshipFieldRefs {
    readonly id: FieldRef<"Starship", 'String'>
    readonly name: FieldRef<"Starship", 'String'>
    readonly class: FieldRef<"Starship", 'String'>
    readonly hullCode: FieldRef<"Starship", 'String'>
    readonly tonnage: FieldRef<"Starship", 'Int'>
    readonly jumpDrive: FieldRef<"Starship", 'Int'>
    readonly maneuverDrive: FieldRef<"Starship", 'Int'>
    readonly powerPlant: FieldRef<"Starship", 'Int'>
    readonly crew: FieldRef<"Starship", 'Int'>
    readonly passengers: FieldRef<"Starship", 'Int'>
    readonly cargo: FieldRef<"Starship", 'Int'>
    readonly fuel: FieldRef<"Starship", 'Int'>
    readonly armor: FieldRef<"Starship", 'Int'>
    readonly weapons: FieldRef<"Starship", 'Json'>
    readonly status: FieldRef<"Starship", 'String'>
    readonly location: FieldRef<"Starship", 'String'>
    readonly owner: FieldRef<"Starship", 'String'>
    readonly campaignId: FieldRef<"Starship", 'String'>
    readonly createdAt: FieldRef<"Starship", 'DateTime'>
    readonly updatedAt: FieldRef<"Starship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Starship findUnique
   */
  export type StarshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Starship
     */
    select?: StarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarshipInclude<ExtArgs> | null
    /**
     * Filter, which Starship to fetch.
     */
    where: StarshipWhereUniqueInput
  }

  /**
   * Starship findUniqueOrThrow
   */
  export type StarshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Starship
     */
    select?: StarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarshipInclude<ExtArgs> | null
    /**
     * Filter, which Starship to fetch.
     */
    where: StarshipWhereUniqueInput
  }

  /**
   * Starship findFirst
   */
  export type StarshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Starship
     */
    select?: StarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarshipInclude<ExtArgs> | null
    /**
     * Filter, which Starship to fetch.
     */
    where?: StarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Starships to fetch.
     */
    orderBy?: StarshipOrderByWithRelationInput | StarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Starships.
     */
    cursor?: StarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Starships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Starships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Starships.
     */
    distinct?: StarshipScalarFieldEnum | StarshipScalarFieldEnum[]
  }

  /**
   * Starship findFirstOrThrow
   */
  export type StarshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Starship
     */
    select?: StarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarshipInclude<ExtArgs> | null
    /**
     * Filter, which Starship to fetch.
     */
    where?: StarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Starships to fetch.
     */
    orderBy?: StarshipOrderByWithRelationInput | StarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Starships.
     */
    cursor?: StarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Starships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Starships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Starships.
     */
    distinct?: StarshipScalarFieldEnum | StarshipScalarFieldEnum[]
  }

  /**
   * Starship findMany
   */
  export type StarshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Starship
     */
    select?: StarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarshipInclude<ExtArgs> | null
    /**
     * Filter, which Starships to fetch.
     */
    where?: StarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Starships to fetch.
     */
    orderBy?: StarshipOrderByWithRelationInput | StarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Starships.
     */
    cursor?: StarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Starships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Starships.
     */
    skip?: number
    distinct?: StarshipScalarFieldEnum | StarshipScalarFieldEnum[]
  }

  /**
   * Starship create
   */
  export type StarshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Starship
     */
    select?: StarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Starship.
     */
    data: XOR<StarshipCreateInput, StarshipUncheckedCreateInput>
  }

  /**
   * Starship createMany
   */
  export type StarshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Starships.
     */
    data: StarshipCreateManyInput | StarshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Starship createManyAndReturn
   */
  export type StarshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Starship
     */
    select?: StarshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Starships.
     */
    data: StarshipCreateManyInput | StarshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Starship update
   */
  export type StarshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Starship
     */
    select?: StarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Starship.
     */
    data: XOR<StarshipUpdateInput, StarshipUncheckedUpdateInput>
    /**
     * Choose, which Starship to update.
     */
    where: StarshipWhereUniqueInput
  }

  /**
   * Starship updateMany
   */
  export type StarshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Starships.
     */
    data: XOR<StarshipUpdateManyMutationInput, StarshipUncheckedUpdateManyInput>
    /**
     * Filter which Starships to update
     */
    where?: StarshipWhereInput
  }

  /**
   * Starship upsert
   */
  export type StarshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Starship
     */
    select?: StarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Starship to update in case it exists.
     */
    where: StarshipWhereUniqueInput
    /**
     * In case the Starship found by the `where` argument doesn't exist, create a new Starship with this data.
     */
    create: XOR<StarshipCreateInput, StarshipUncheckedCreateInput>
    /**
     * In case the Starship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StarshipUpdateInput, StarshipUncheckedUpdateInput>
  }

  /**
   * Starship delete
   */
  export type StarshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Starship
     */
    select?: StarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarshipInclude<ExtArgs> | null
    /**
     * Filter which Starship to delete.
     */
    where: StarshipWhereUniqueInput
  }

  /**
   * Starship deleteMany
   */
  export type StarshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Starships to delete
     */
    where?: StarshipWhereInput
  }

  /**
   * Starship.campaign
   */
  export type Starship$campaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
  }

  /**
   * Starship without action
   */
  export type StarshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Starship
     */
    select?: StarshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StarshipInclude<ExtArgs> | null
  }


  /**
   * Model TradeGood
   */

  export type AggregateTradeGood = {
    _count: TradeGoodCountAggregateOutputType | null
    _avg: TradeGoodAvgAggregateOutputType | null
    _sum: TradeGoodSumAggregateOutputType | null
    _min: TradeGoodMinAggregateOutputType | null
    _max: TradeGoodMaxAggregateOutputType | null
  }

  export type TradeGoodAvgAggregateOutputType = {
    basePrice: number | null
    dtm: number | null
  }

  export type TradeGoodSumAggregateOutputType = {
    basePrice: number | null
    dtm: number | null
  }

  export type TradeGoodMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    basePrice: number | null
    availability: string | null
    legality: string | null
    dtm: number | null
    planetId: string | null
  }

  export type TradeGoodMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    basePrice: number | null
    availability: string | null
    legality: string | null
    dtm: number | null
    planetId: string | null
  }

  export type TradeGoodCountAggregateOutputType = {
    id: number
    name: number
    category: number
    basePrice: number
    availability: number
    legality: number
    dtm: number
    planetId: number
    _all: number
  }


  export type TradeGoodAvgAggregateInputType = {
    basePrice?: true
    dtm?: true
  }

  export type TradeGoodSumAggregateInputType = {
    basePrice?: true
    dtm?: true
  }

  export type TradeGoodMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    basePrice?: true
    availability?: true
    legality?: true
    dtm?: true
    planetId?: true
  }

  export type TradeGoodMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    basePrice?: true
    availability?: true
    legality?: true
    dtm?: true
    planetId?: true
  }

  export type TradeGoodCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    basePrice?: true
    availability?: true
    legality?: true
    dtm?: true
    planetId?: true
    _all?: true
  }

  export type TradeGoodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeGood to aggregate.
     */
    where?: TradeGoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeGoods to fetch.
     */
    orderBy?: TradeGoodOrderByWithRelationInput | TradeGoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TradeGoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeGoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeGoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TradeGoods
    **/
    _count?: true | TradeGoodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TradeGoodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TradeGoodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TradeGoodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TradeGoodMaxAggregateInputType
  }

  export type GetTradeGoodAggregateType<T extends TradeGoodAggregateArgs> = {
        [P in keyof T & keyof AggregateTradeGood]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTradeGood[P]>
      : GetScalarType<T[P], AggregateTradeGood[P]>
  }




  export type TradeGoodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeGoodWhereInput
    orderBy?: TradeGoodOrderByWithAggregationInput | TradeGoodOrderByWithAggregationInput[]
    by: TradeGoodScalarFieldEnum[] | TradeGoodScalarFieldEnum
    having?: TradeGoodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TradeGoodCountAggregateInputType | true
    _avg?: TradeGoodAvgAggregateInputType
    _sum?: TradeGoodSumAggregateInputType
    _min?: TradeGoodMinAggregateInputType
    _max?: TradeGoodMaxAggregateInputType
  }

  export type TradeGoodGroupByOutputType = {
    id: string
    name: string
    category: string
    basePrice: number
    availability: string | null
    legality: string | null
    dtm: number
    planetId: string | null
    _count: TradeGoodCountAggregateOutputType | null
    _avg: TradeGoodAvgAggregateOutputType | null
    _sum: TradeGoodSumAggregateOutputType | null
    _min: TradeGoodMinAggregateOutputType | null
    _max: TradeGoodMaxAggregateOutputType | null
  }

  type GetTradeGoodGroupByPayload<T extends TradeGoodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TradeGoodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TradeGoodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TradeGoodGroupByOutputType[P]>
            : GetScalarType<T[P], TradeGoodGroupByOutputType[P]>
        }
      >
    >


  export type TradeGoodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    basePrice?: boolean
    availability?: boolean
    legality?: boolean
    dtm?: boolean
    planetId?: boolean
    planet?: boolean | TradeGood$planetArgs<ExtArgs>
  }, ExtArgs["result"]["tradeGood"]>

  export type TradeGoodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    basePrice?: boolean
    availability?: boolean
    legality?: boolean
    dtm?: boolean
    planetId?: boolean
    planet?: boolean | TradeGood$planetArgs<ExtArgs>
  }, ExtArgs["result"]["tradeGood"]>

  export type TradeGoodSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    basePrice?: boolean
    availability?: boolean
    legality?: boolean
    dtm?: boolean
    planetId?: boolean
  }

  export type TradeGoodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planet?: boolean | TradeGood$planetArgs<ExtArgs>
  }
  export type TradeGoodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planet?: boolean | TradeGood$planetArgs<ExtArgs>
  }

  export type $TradeGoodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TradeGood"
    objects: {
      planet: Prisma.$PlanetPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string
      basePrice: number
      availability: string | null
      legality: string | null
      dtm: number
      planetId: string | null
    }, ExtArgs["result"]["tradeGood"]>
    composites: {}
  }

  type TradeGoodGetPayload<S extends boolean | null | undefined | TradeGoodDefaultArgs> = $Result.GetResult<Prisma.$TradeGoodPayload, S>

  type TradeGoodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TradeGoodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TradeGoodCountAggregateInputType | true
    }

  export interface TradeGoodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TradeGood'], meta: { name: 'TradeGood' } }
    /**
     * Find zero or one TradeGood that matches the filter.
     * @param {TradeGoodFindUniqueArgs} args - Arguments to find a TradeGood
     * @example
     * // Get one TradeGood
     * const tradeGood = await prisma.tradeGood.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TradeGoodFindUniqueArgs>(args: SelectSubset<T, TradeGoodFindUniqueArgs<ExtArgs>>): Prisma__TradeGoodClient<$Result.GetResult<Prisma.$TradeGoodPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TradeGood that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TradeGoodFindUniqueOrThrowArgs} args - Arguments to find a TradeGood
     * @example
     * // Get one TradeGood
     * const tradeGood = await prisma.tradeGood.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TradeGoodFindUniqueOrThrowArgs>(args: SelectSubset<T, TradeGoodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TradeGoodClient<$Result.GetResult<Prisma.$TradeGoodPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TradeGood that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeGoodFindFirstArgs} args - Arguments to find a TradeGood
     * @example
     * // Get one TradeGood
     * const tradeGood = await prisma.tradeGood.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TradeGoodFindFirstArgs>(args?: SelectSubset<T, TradeGoodFindFirstArgs<ExtArgs>>): Prisma__TradeGoodClient<$Result.GetResult<Prisma.$TradeGoodPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TradeGood that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeGoodFindFirstOrThrowArgs} args - Arguments to find a TradeGood
     * @example
     * // Get one TradeGood
     * const tradeGood = await prisma.tradeGood.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TradeGoodFindFirstOrThrowArgs>(args?: SelectSubset<T, TradeGoodFindFirstOrThrowArgs<ExtArgs>>): Prisma__TradeGoodClient<$Result.GetResult<Prisma.$TradeGoodPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TradeGoods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeGoodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TradeGoods
     * const tradeGoods = await prisma.tradeGood.findMany()
     * 
     * // Get first 10 TradeGoods
     * const tradeGoods = await prisma.tradeGood.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tradeGoodWithIdOnly = await prisma.tradeGood.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TradeGoodFindManyArgs>(args?: SelectSubset<T, TradeGoodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeGoodPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TradeGood.
     * @param {TradeGoodCreateArgs} args - Arguments to create a TradeGood.
     * @example
     * // Create one TradeGood
     * const TradeGood = await prisma.tradeGood.create({
     *   data: {
     *     // ... data to create a TradeGood
     *   }
     * })
     * 
     */
    create<T extends TradeGoodCreateArgs>(args: SelectSubset<T, TradeGoodCreateArgs<ExtArgs>>): Prisma__TradeGoodClient<$Result.GetResult<Prisma.$TradeGoodPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TradeGoods.
     * @param {TradeGoodCreateManyArgs} args - Arguments to create many TradeGoods.
     * @example
     * // Create many TradeGoods
     * const tradeGood = await prisma.tradeGood.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TradeGoodCreateManyArgs>(args?: SelectSubset<T, TradeGoodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TradeGoods and returns the data saved in the database.
     * @param {TradeGoodCreateManyAndReturnArgs} args - Arguments to create many TradeGoods.
     * @example
     * // Create many TradeGoods
     * const tradeGood = await prisma.tradeGood.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TradeGoods and only return the `id`
     * const tradeGoodWithIdOnly = await prisma.tradeGood.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TradeGoodCreateManyAndReturnArgs>(args?: SelectSubset<T, TradeGoodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeGoodPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TradeGood.
     * @param {TradeGoodDeleteArgs} args - Arguments to delete one TradeGood.
     * @example
     * // Delete one TradeGood
     * const TradeGood = await prisma.tradeGood.delete({
     *   where: {
     *     // ... filter to delete one TradeGood
     *   }
     * })
     * 
     */
    delete<T extends TradeGoodDeleteArgs>(args: SelectSubset<T, TradeGoodDeleteArgs<ExtArgs>>): Prisma__TradeGoodClient<$Result.GetResult<Prisma.$TradeGoodPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TradeGood.
     * @param {TradeGoodUpdateArgs} args - Arguments to update one TradeGood.
     * @example
     * // Update one TradeGood
     * const tradeGood = await prisma.tradeGood.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TradeGoodUpdateArgs>(args: SelectSubset<T, TradeGoodUpdateArgs<ExtArgs>>): Prisma__TradeGoodClient<$Result.GetResult<Prisma.$TradeGoodPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TradeGoods.
     * @param {TradeGoodDeleteManyArgs} args - Arguments to filter TradeGoods to delete.
     * @example
     * // Delete a few TradeGoods
     * const { count } = await prisma.tradeGood.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TradeGoodDeleteManyArgs>(args?: SelectSubset<T, TradeGoodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TradeGoods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeGoodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TradeGoods
     * const tradeGood = await prisma.tradeGood.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TradeGoodUpdateManyArgs>(args: SelectSubset<T, TradeGoodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TradeGood.
     * @param {TradeGoodUpsertArgs} args - Arguments to update or create a TradeGood.
     * @example
     * // Update or create a TradeGood
     * const tradeGood = await prisma.tradeGood.upsert({
     *   create: {
     *     // ... data to create a TradeGood
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TradeGood we want to update
     *   }
     * })
     */
    upsert<T extends TradeGoodUpsertArgs>(args: SelectSubset<T, TradeGoodUpsertArgs<ExtArgs>>): Prisma__TradeGoodClient<$Result.GetResult<Prisma.$TradeGoodPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TradeGoods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeGoodCountArgs} args - Arguments to filter TradeGoods to count.
     * @example
     * // Count the number of TradeGoods
     * const count = await prisma.tradeGood.count({
     *   where: {
     *     // ... the filter for the TradeGoods we want to count
     *   }
     * })
    **/
    count<T extends TradeGoodCountArgs>(
      args?: Subset<T, TradeGoodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TradeGoodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TradeGood.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeGoodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TradeGoodAggregateArgs>(args: Subset<T, TradeGoodAggregateArgs>): Prisma.PrismaPromise<GetTradeGoodAggregateType<T>>

    /**
     * Group by TradeGood.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeGoodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TradeGoodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TradeGoodGroupByArgs['orderBy'] }
        : { orderBy?: TradeGoodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TradeGoodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTradeGoodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TradeGood model
   */
  readonly fields: TradeGoodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TradeGood.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TradeGoodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    planet<T extends TradeGood$planetArgs<ExtArgs> = {}>(args?: Subset<T, TradeGood$planetArgs<ExtArgs>>): Prisma__PlanetClient<$Result.GetResult<Prisma.$PlanetPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TradeGood model
   */ 
  interface TradeGoodFieldRefs {
    readonly id: FieldRef<"TradeGood", 'String'>
    readonly name: FieldRef<"TradeGood", 'String'>
    readonly category: FieldRef<"TradeGood", 'String'>
    readonly basePrice: FieldRef<"TradeGood", 'Int'>
    readonly availability: FieldRef<"TradeGood", 'String'>
    readonly legality: FieldRef<"TradeGood", 'String'>
    readonly dtm: FieldRef<"TradeGood", 'Int'>
    readonly planetId: FieldRef<"TradeGood", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TradeGood findUnique
   */
  export type TradeGoodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeGood
     */
    select?: TradeGoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeGoodInclude<ExtArgs> | null
    /**
     * Filter, which TradeGood to fetch.
     */
    where: TradeGoodWhereUniqueInput
  }

  /**
   * TradeGood findUniqueOrThrow
   */
  export type TradeGoodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeGood
     */
    select?: TradeGoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeGoodInclude<ExtArgs> | null
    /**
     * Filter, which TradeGood to fetch.
     */
    where: TradeGoodWhereUniqueInput
  }

  /**
   * TradeGood findFirst
   */
  export type TradeGoodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeGood
     */
    select?: TradeGoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeGoodInclude<ExtArgs> | null
    /**
     * Filter, which TradeGood to fetch.
     */
    where?: TradeGoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeGoods to fetch.
     */
    orderBy?: TradeGoodOrderByWithRelationInput | TradeGoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeGoods.
     */
    cursor?: TradeGoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeGoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeGoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeGoods.
     */
    distinct?: TradeGoodScalarFieldEnum | TradeGoodScalarFieldEnum[]
  }

  /**
   * TradeGood findFirstOrThrow
   */
  export type TradeGoodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeGood
     */
    select?: TradeGoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeGoodInclude<ExtArgs> | null
    /**
     * Filter, which TradeGood to fetch.
     */
    where?: TradeGoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeGoods to fetch.
     */
    orderBy?: TradeGoodOrderByWithRelationInput | TradeGoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeGoods.
     */
    cursor?: TradeGoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeGoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeGoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeGoods.
     */
    distinct?: TradeGoodScalarFieldEnum | TradeGoodScalarFieldEnum[]
  }

  /**
   * TradeGood findMany
   */
  export type TradeGoodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeGood
     */
    select?: TradeGoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeGoodInclude<ExtArgs> | null
    /**
     * Filter, which TradeGoods to fetch.
     */
    where?: TradeGoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeGoods to fetch.
     */
    orderBy?: TradeGoodOrderByWithRelationInput | TradeGoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TradeGoods.
     */
    cursor?: TradeGoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeGoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeGoods.
     */
    skip?: number
    distinct?: TradeGoodScalarFieldEnum | TradeGoodScalarFieldEnum[]
  }

  /**
   * TradeGood create
   */
  export type TradeGoodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeGood
     */
    select?: TradeGoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeGoodInclude<ExtArgs> | null
    /**
     * The data needed to create a TradeGood.
     */
    data: XOR<TradeGoodCreateInput, TradeGoodUncheckedCreateInput>
  }

  /**
   * TradeGood createMany
   */
  export type TradeGoodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TradeGoods.
     */
    data: TradeGoodCreateManyInput | TradeGoodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TradeGood createManyAndReturn
   */
  export type TradeGoodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeGood
     */
    select?: TradeGoodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TradeGoods.
     */
    data: TradeGoodCreateManyInput | TradeGoodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeGoodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TradeGood update
   */
  export type TradeGoodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeGood
     */
    select?: TradeGoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeGoodInclude<ExtArgs> | null
    /**
     * The data needed to update a TradeGood.
     */
    data: XOR<TradeGoodUpdateInput, TradeGoodUncheckedUpdateInput>
    /**
     * Choose, which TradeGood to update.
     */
    where: TradeGoodWhereUniqueInput
  }

  /**
   * TradeGood updateMany
   */
  export type TradeGoodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TradeGoods.
     */
    data: XOR<TradeGoodUpdateManyMutationInput, TradeGoodUncheckedUpdateManyInput>
    /**
     * Filter which TradeGoods to update
     */
    where?: TradeGoodWhereInput
  }

  /**
   * TradeGood upsert
   */
  export type TradeGoodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeGood
     */
    select?: TradeGoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeGoodInclude<ExtArgs> | null
    /**
     * The filter to search for the TradeGood to update in case it exists.
     */
    where: TradeGoodWhereUniqueInput
    /**
     * In case the TradeGood found by the `where` argument doesn't exist, create a new TradeGood with this data.
     */
    create: XOR<TradeGoodCreateInput, TradeGoodUncheckedCreateInput>
    /**
     * In case the TradeGood was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TradeGoodUpdateInput, TradeGoodUncheckedUpdateInput>
  }

  /**
   * TradeGood delete
   */
  export type TradeGoodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeGood
     */
    select?: TradeGoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeGoodInclude<ExtArgs> | null
    /**
     * Filter which TradeGood to delete.
     */
    where: TradeGoodWhereUniqueInput
  }

  /**
   * TradeGood deleteMany
   */
  export type TradeGoodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeGoods to delete
     */
    where?: TradeGoodWhereInput
  }

  /**
   * TradeGood.planet
   */
  export type TradeGood$planetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planet
     */
    select?: PlanetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanetInclude<ExtArgs> | null
    where?: PlanetWhereInput
  }

  /**
   * TradeGood without action
   */
  export type TradeGoodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeGood
     */
    select?: TradeGoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeGoodInclude<ExtArgs> | null
  }


  /**
   * Model TradeRoute
   */

  export type AggregateTradeRoute = {
    _count: TradeRouteCountAggregateOutputType | null
    _avg: TradeRouteAvgAggregateOutputType | null
    _sum: TradeRouteSumAggregateOutputType | null
    _min: TradeRouteMinAggregateOutputType | null
    _max: TradeRouteMaxAggregateOutputType | null
  }

  export type TradeRouteAvgAggregateOutputType = {
    distance: number | null
    difficulty: number | null
    profitMargin: number | null
  }

  export type TradeRouteSumAggregateOutputType = {
    distance: number | null
    difficulty: number | null
    profitMargin: number | null
  }

  export type TradeRouteMinAggregateOutputType = {
    id: string | null
    name: string | null
    distance: number | null
    difficulty: number | null
    originId: string | null
    destinationId: string | null
    profitMargin: number | null
  }

  export type TradeRouteMaxAggregateOutputType = {
    id: string | null
    name: string | null
    distance: number | null
    difficulty: number | null
    originId: string | null
    destinationId: string | null
    profitMargin: number | null
  }

  export type TradeRouteCountAggregateOutputType = {
    id: number
    name: number
    distance: number
    difficulty: number
    originId: number
    destinationId: number
    cargoTypes: number
    profitMargin: number
    _all: number
  }


  export type TradeRouteAvgAggregateInputType = {
    distance?: true
    difficulty?: true
    profitMargin?: true
  }

  export type TradeRouteSumAggregateInputType = {
    distance?: true
    difficulty?: true
    profitMargin?: true
  }

  export type TradeRouteMinAggregateInputType = {
    id?: true
    name?: true
    distance?: true
    difficulty?: true
    originId?: true
    destinationId?: true
    profitMargin?: true
  }

  export type TradeRouteMaxAggregateInputType = {
    id?: true
    name?: true
    distance?: true
    difficulty?: true
    originId?: true
    destinationId?: true
    profitMargin?: true
  }

  export type TradeRouteCountAggregateInputType = {
    id?: true
    name?: true
    distance?: true
    difficulty?: true
    originId?: true
    destinationId?: true
    cargoTypes?: true
    profitMargin?: true
    _all?: true
  }

  export type TradeRouteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeRoute to aggregate.
     */
    where?: TradeRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeRoutes to fetch.
     */
    orderBy?: TradeRouteOrderByWithRelationInput | TradeRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TradeRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TradeRoutes
    **/
    _count?: true | TradeRouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TradeRouteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TradeRouteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TradeRouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TradeRouteMaxAggregateInputType
  }

  export type GetTradeRouteAggregateType<T extends TradeRouteAggregateArgs> = {
        [P in keyof T & keyof AggregateTradeRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTradeRoute[P]>
      : GetScalarType<T[P], AggregateTradeRoute[P]>
  }




  export type TradeRouteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TradeRouteWhereInput
    orderBy?: TradeRouteOrderByWithAggregationInput | TradeRouteOrderByWithAggregationInput[]
    by: TradeRouteScalarFieldEnum[] | TradeRouteScalarFieldEnum
    having?: TradeRouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TradeRouteCountAggregateInputType | true
    _avg?: TradeRouteAvgAggregateInputType
    _sum?: TradeRouteSumAggregateInputType
    _min?: TradeRouteMinAggregateInputType
    _max?: TradeRouteMaxAggregateInputType
  }

  export type TradeRouteGroupByOutputType = {
    id: string
    name: string
    distance: number
    difficulty: number
    originId: string
    destinationId: string
    cargoTypes: string[]
    profitMargin: number | null
    _count: TradeRouteCountAggregateOutputType | null
    _avg: TradeRouteAvgAggregateOutputType | null
    _sum: TradeRouteSumAggregateOutputType | null
    _min: TradeRouteMinAggregateOutputType | null
    _max: TradeRouteMaxAggregateOutputType | null
  }

  type GetTradeRouteGroupByPayload<T extends TradeRouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TradeRouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TradeRouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TradeRouteGroupByOutputType[P]>
            : GetScalarType<T[P], TradeRouteGroupByOutputType[P]>
        }
      >
    >


  export type TradeRouteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    distance?: boolean
    difficulty?: boolean
    originId?: boolean
    destinationId?: boolean
    cargoTypes?: boolean
    profitMargin?: boolean
    origin?: boolean | StarSystemDefaultArgs<ExtArgs>
    destination?: boolean | StarSystemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tradeRoute"]>

  export type TradeRouteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    distance?: boolean
    difficulty?: boolean
    originId?: boolean
    destinationId?: boolean
    cargoTypes?: boolean
    profitMargin?: boolean
    origin?: boolean | StarSystemDefaultArgs<ExtArgs>
    destination?: boolean | StarSystemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tradeRoute"]>

  export type TradeRouteSelectScalar = {
    id?: boolean
    name?: boolean
    distance?: boolean
    difficulty?: boolean
    originId?: boolean
    destinationId?: boolean
    cargoTypes?: boolean
    profitMargin?: boolean
  }

  export type TradeRouteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin?: boolean | StarSystemDefaultArgs<ExtArgs>
    destination?: boolean | StarSystemDefaultArgs<ExtArgs>
  }
  export type TradeRouteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin?: boolean | StarSystemDefaultArgs<ExtArgs>
    destination?: boolean | StarSystemDefaultArgs<ExtArgs>
  }

  export type $TradeRoutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TradeRoute"
    objects: {
      origin: Prisma.$StarSystemPayload<ExtArgs>
      destination: Prisma.$StarSystemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      distance: number
      difficulty: number
      originId: string
      destinationId: string
      cargoTypes: string[]
      profitMargin: number | null
    }, ExtArgs["result"]["tradeRoute"]>
    composites: {}
  }

  type TradeRouteGetPayload<S extends boolean | null | undefined | TradeRouteDefaultArgs> = $Result.GetResult<Prisma.$TradeRoutePayload, S>

  type TradeRouteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TradeRouteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TradeRouteCountAggregateInputType | true
    }

  export interface TradeRouteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TradeRoute'], meta: { name: 'TradeRoute' } }
    /**
     * Find zero or one TradeRoute that matches the filter.
     * @param {TradeRouteFindUniqueArgs} args - Arguments to find a TradeRoute
     * @example
     * // Get one TradeRoute
     * const tradeRoute = await prisma.tradeRoute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TradeRouteFindUniqueArgs>(args: SelectSubset<T, TradeRouteFindUniqueArgs<ExtArgs>>): Prisma__TradeRouteClient<$Result.GetResult<Prisma.$TradeRoutePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TradeRoute that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TradeRouteFindUniqueOrThrowArgs} args - Arguments to find a TradeRoute
     * @example
     * // Get one TradeRoute
     * const tradeRoute = await prisma.tradeRoute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TradeRouteFindUniqueOrThrowArgs>(args: SelectSubset<T, TradeRouteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TradeRouteClient<$Result.GetResult<Prisma.$TradeRoutePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TradeRoute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeRouteFindFirstArgs} args - Arguments to find a TradeRoute
     * @example
     * // Get one TradeRoute
     * const tradeRoute = await prisma.tradeRoute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TradeRouteFindFirstArgs>(args?: SelectSubset<T, TradeRouteFindFirstArgs<ExtArgs>>): Prisma__TradeRouteClient<$Result.GetResult<Prisma.$TradeRoutePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TradeRoute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeRouteFindFirstOrThrowArgs} args - Arguments to find a TradeRoute
     * @example
     * // Get one TradeRoute
     * const tradeRoute = await prisma.tradeRoute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TradeRouteFindFirstOrThrowArgs>(args?: SelectSubset<T, TradeRouteFindFirstOrThrowArgs<ExtArgs>>): Prisma__TradeRouteClient<$Result.GetResult<Prisma.$TradeRoutePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TradeRoutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeRouteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TradeRoutes
     * const tradeRoutes = await prisma.tradeRoute.findMany()
     * 
     * // Get first 10 TradeRoutes
     * const tradeRoutes = await prisma.tradeRoute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tradeRouteWithIdOnly = await prisma.tradeRoute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TradeRouteFindManyArgs>(args?: SelectSubset<T, TradeRouteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeRoutePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TradeRoute.
     * @param {TradeRouteCreateArgs} args - Arguments to create a TradeRoute.
     * @example
     * // Create one TradeRoute
     * const TradeRoute = await prisma.tradeRoute.create({
     *   data: {
     *     // ... data to create a TradeRoute
     *   }
     * })
     * 
     */
    create<T extends TradeRouteCreateArgs>(args: SelectSubset<T, TradeRouteCreateArgs<ExtArgs>>): Prisma__TradeRouteClient<$Result.GetResult<Prisma.$TradeRoutePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TradeRoutes.
     * @param {TradeRouteCreateManyArgs} args - Arguments to create many TradeRoutes.
     * @example
     * // Create many TradeRoutes
     * const tradeRoute = await prisma.tradeRoute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TradeRouteCreateManyArgs>(args?: SelectSubset<T, TradeRouteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TradeRoutes and returns the data saved in the database.
     * @param {TradeRouteCreateManyAndReturnArgs} args - Arguments to create many TradeRoutes.
     * @example
     * // Create many TradeRoutes
     * const tradeRoute = await prisma.tradeRoute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TradeRoutes and only return the `id`
     * const tradeRouteWithIdOnly = await prisma.tradeRoute.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TradeRouteCreateManyAndReturnArgs>(args?: SelectSubset<T, TradeRouteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TradeRoutePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TradeRoute.
     * @param {TradeRouteDeleteArgs} args - Arguments to delete one TradeRoute.
     * @example
     * // Delete one TradeRoute
     * const TradeRoute = await prisma.tradeRoute.delete({
     *   where: {
     *     // ... filter to delete one TradeRoute
     *   }
     * })
     * 
     */
    delete<T extends TradeRouteDeleteArgs>(args: SelectSubset<T, TradeRouteDeleteArgs<ExtArgs>>): Prisma__TradeRouteClient<$Result.GetResult<Prisma.$TradeRoutePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TradeRoute.
     * @param {TradeRouteUpdateArgs} args - Arguments to update one TradeRoute.
     * @example
     * // Update one TradeRoute
     * const tradeRoute = await prisma.tradeRoute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TradeRouteUpdateArgs>(args: SelectSubset<T, TradeRouteUpdateArgs<ExtArgs>>): Prisma__TradeRouteClient<$Result.GetResult<Prisma.$TradeRoutePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TradeRoutes.
     * @param {TradeRouteDeleteManyArgs} args - Arguments to filter TradeRoutes to delete.
     * @example
     * // Delete a few TradeRoutes
     * const { count } = await prisma.tradeRoute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TradeRouteDeleteManyArgs>(args?: SelectSubset<T, TradeRouteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TradeRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeRouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TradeRoutes
     * const tradeRoute = await prisma.tradeRoute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TradeRouteUpdateManyArgs>(args: SelectSubset<T, TradeRouteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TradeRoute.
     * @param {TradeRouteUpsertArgs} args - Arguments to update or create a TradeRoute.
     * @example
     * // Update or create a TradeRoute
     * const tradeRoute = await prisma.tradeRoute.upsert({
     *   create: {
     *     // ... data to create a TradeRoute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TradeRoute we want to update
     *   }
     * })
     */
    upsert<T extends TradeRouteUpsertArgs>(args: SelectSubset<T, TradeRouteUpsertArgs<ExtArgs>>): Prisma__TradeRouteClient<$Result.GetResult<Prisma.$TradeRoutePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TradeRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeRouteCountArgs} args - Arguments to filter TradeRoutes to count.
     * @example
     * // Count the number of TradeRoutes
     * const count = await prisma.tradeRoute.count({
     *   where: {
     *     // ... the filter for the TradeRoutes we want to count
     *   }
     * })
    **/
    count<T extends TradeRouteCountArgs>(
      args?: Subset<T, TradeRouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TradeRouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TradeRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeRouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TradeRouteAggregateArgs>(args: Subset<T, TradeRouteAggregateArgs>): Prisma.PrismaPromise<GetTradeRouteAggregateType<T>>

    /**
     * Group by TradeRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradeRouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TradeRouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TradeRouteGroupByArgs['orderBy'] }
        : { orderBy?: TradeRouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TradeRouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTradeRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TradeRoute model
   */
  readonly fields: TradeRouteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TradeRoute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TradeRouteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    origin<T extends StarSystemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StarSystemDefaultArgs<ExtArgs>>): Prisma__StarSystemClient<$Result.GetResult<Prisma.$StarSystemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    destination<T extends StarSystemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StarSystemDefaultArgs<ExtArgs>>): Prisma__StarSystemClient<$Result.GetResult<Prisma.$StarSystemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TradeRoute model
   */ 
  interface TradeRouteFieldRefs {
    readonly id: FieldRef<"TradeRoute", 'String'>
    readonly name: FieldRef<"TradeRoute", 'String'>
    readonly distance: FieldRef<"TradeRoute", 'Int'>
    readonly difficulty: FieldRef<"TradeRoute", 'Int'>
    readonly originId: FieldRef<"TradeRoute", 'String'>
    readonly destinationId: FieldRef<"TradeRoute", 'String'>
    readonly cargoTypes: FieldRef<"TradeRoute", 'String[]'>
    readonly profitMargin: FieldRef<"TradeRoute", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * TradeRoute findUnique
   */
  export type TradeRouteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeRoute
     */
    select?: TradeRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeRouteInclude<ExtArgs> | null
    /**
     * Filter, which TradeRoute to fetch.
     */
    where: TradeRouteWhereUniqueInput
  }

  /**
   * TradeRoute findUniqueOrThrow
   */
  export type TradeRouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeRoute
     */
    select?: TradeRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeRouteInclude<ExtArgs> | null
    /**
     * Filter, which TradeRoute to fetch.
     */
    where: TradeRouteWhereUniqueInput
  }

  /**
   * TradeRoute findFirst
   */
  export type TradeRouteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeRoute
     */
    select?: TradeRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeRouteInclude<ExtArgs> | null
    /**
     * Filter, which TradeRoute to fetch.
     */
    where?: TradeRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeRoutes to fetch.
     */
    orderBy?: TradeRouteOrderByWithRelationInput | TradeRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeRoutes.
     */
    cursor?: TradeRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeRoutes.
     */
    distinct?: TradeRouteScalarFieldEnum | TradeRouteScalarFieldEnum[]
  }

  /**
   * TradeRoute findFirstOrThrow
   */
  export type TradeRouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeRoute
     */
    select?: TradeRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeRouteInclude<ExtArgs> | null
    /**
     * Filter, which TradeRoute to fetch.
     */
    where?: TradeRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeRoutes to fetch.
     */
    orderBy?: TradeRouteOrderByWithRelationInput | TradeRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TradeRoutes.
     */
    cursor?: TradeRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TradeRoutes.
     */
    distinct?: TradeRouteScalarFieldEnum | TradeRouteScalarFieldEnum[]
  }

  /**
   * TradeRoute findMany
   */
  export type TradeRouteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeRoute
     */
    select?: TradeRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeRouteInclude<ExtArgs> | null
    /**
     * Filter, which TradeRoutes to fetch.
     */
    where?: TradeRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TradeRoutes to fetch.
     */
    orderBy?: TradeRouteOrderByWithRelationInput | TradeRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TradeRoutes.
     */
    cursor?: TradeRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TradeRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TradeRoutes.
     */
    skip?: number
    distinct?: TradeRouteScalarFieldEnum | TradeRouteScalarFieldEnum[]
  }

  /**
   * TradeRoute create
   */
  export type TradeRouteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeRoute
     */
    select?: TradeRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeRouteInclude<ExtArgs> | null
    /**
     * The data needed to create a TradeRoute.
     */
    data: XOR<TradeRouteCreateInput, TradeRouteUncheckedCreateInput>
  }

  /**
   * TradeRoute createMany
   */
  export type TradeRouteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TradeRoutes.
     */
    data: TradeRouteCreateManyInput | TradeRouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TradeRoute createManyAndReturn
   */
  export type TradeRouteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeRoute
     */
    select?: TradeRouteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TradeRoutes.
     */
    data: TradeRouteCreateManyInput | TradeRouteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeRouteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TradeRoute update
   */
  export type TradeRouteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeRoute
     */
    select?: TradeRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeRouteInclude<ExtArgs> | null
    /**
     * The data needed to update a TradeRoute.
     */
    data: XOR<TradeRouteUpdateInput, TradeRouteUncheckedUpdateInput>
    /**
     * Choose, which TradeRoute to update.
     */
    where: TradeRouteWhereUniqueInput
  }

  /**
   * TradeRoute updateMany
   */
  export type TradeRouteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TradeRoutes.
     */
    data: XOR<TradeRouteUpdateManyMutationInput, TradeRouteUncheckedUpdateManyInput>
    /**
     * Filter which TradeRoutes to update
     */
    where?: TradeRouteWhereInput
  }

  /**
   * TradeRoute upsert
   */
  export type TradeRouteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeRoute
     */
    select?: TradeRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeRouteInclude<ExtArgs> | null
    /**
     * The filter to search for the TradeRoute to update in case it exists.
     */
    where: TradeRouteWhereUniqueInput
    /**
     * In case the TradeRoute found by the `where` argument doesn't exist, create a new TradeRoute with this data.
     */
    create: XOR<TradeRouteCreateInput, TradeRouteUncheckedCreateInput>
    /**
     * In case the TradeRoute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TradeRouteUpdateInput, TradeRouteUncheckedUpdateInput>
  }

  /**
   * TradeRoute delete
   */
  export type TradeRouteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeRoute
     */
    select?: TradeRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeRouteInclude<ExtArgs> | null
    /**
     * Filter which TradeRoute to delete.
     */
    where: TradeRouteWhereUniqueInput
  }

  /**
   * TradeRoute deleteMany
   */
  export type TradeRouteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TradeRoutes to delete
     */
    where?: TradeRouteWhereInput
  }

  /**
   * TradeRoute without action
   */
  export type TradeRouteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TradeRoute
     */
    select?: TradeRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TradeRouteInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    duration: number | null
  }

  export type SessionSumAggregateOutputType = {
    duration: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    name: string | null
    scheduledFor: Date | null
    duration: number | null
    notes: string | null
    status: $Enums.SessionStatus | null
    campaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    scheduledFor: Date | null
    duration: number | null
    notes: string | null
    status: $Enums.SessionStatus | null
    campaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    name: number
    scheduledFor: number
    duration: number
    notes: number
    status: number
    campaignId: number
    participants: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    duration?: true
  }

  export type SessionSumAggregateInputType = {
    duration?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    name?: true
    scheduledFor?: true
    duration?: true
    notes?: true
    status?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    name?: true
    scheduledFor?: true
    duration?: true
    notes?: true
    status?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    name?: true
    scheduledFor?: true
    duration?: true
    notes?: true
    status?: true
    campaignId?: true
    participants?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    name: string
    scheduledFor: Date | null
    duration: number | null
    notes: string | null
    status: $Enums.SessionStatus
    campaignId: string
    participants: string[]
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    scheduledFor?: boolean
    duration?: boolean
    notes?: boolean
    status?: boolean
    campaignId?: boolean
    participants?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    encounters?: boolean | Session$encountersArgs<ExtArgs>
    combatSessions?: boolean | Session$combatSessionsArgs<ExtArgs>
    sessionNotes?: boolean | Session$sessionNotesArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    scheduledFor?: boolean
    duration?: boolean
    notes?: boolean
    status?: boolean
    campaignId?: boolean
    participants?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    name?: boolean
    scheduledFor?: boolean
    duration?: boolean
    notes?: boolean
    status?: boolean
    campaignId?: boolean
    participants?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    encounters?: boolean | Session$encountersArgs<ExtArgs>
    combatSessions?: boolean | Session$combatSessionsArgs<ExtArgs>
    sessionNotes?: boolean | Session$sessionNotesArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      encounters: Prisma.$EncounterPayload<ExtArgs>[]
      combatSessions: Prisma.$CombatSessionPayload<ExtArgs>[]
      sessionNotes: Prisma.$SessionNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      scheduledFor: Date | null
      duration: number | null
      notes: string | null
      status: $Enums.SessionStatus
      campaignId: string
      participants: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    encounters<T extends Session$encountersArgs<ExtArgs> = {}>(args?: Subset<T, Session$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany"> | Null>
    combatSessions<T extends Session$combatSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Session$combatSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombatSessionPayload<ExtArgs>, T, "findMany"> | Null>
    sessionNotes<T extends Session$sessionNotesArgs<ExtArgs> = {}>(args?: Subset<T, Session$sessionNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionNotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly name: FieldRef<"Session", 'String'>
    readonly scheduledFor: FieldRef<"Session", 'DateTime'>
    readonly duration: FieldRef<"Session", 'Int'>
    readonly notes: FieldRef<"Session", 'String'>
    readonly status: FieldRef<"Session", 'SessionStatus'>
    readonly campaignId: FieldRef<"Session", 'String'>
    readonly participants: FieldRef<"Session", 'String[]'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session.encounters
   */
  export type Session$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Session.combatSessions
   */
  export type Session$combatSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatSession
     */
    select?: CombatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatSessionInclude<ExtArgs> | null
    where?: CombatSessionWhereInput
    orderBy?: CombatSessionOrderByWithRelationInput | CombatSessionOrderByWithRelationInput[]
    cursor?: CombatSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CombatSessionScalarFieldEnum | CombatSessionScalarFieldEnum[]
  }

  /**
   * Session.sessionNotes
   */
  export type Session$sessionNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionNote
     */
    select?: SessionNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionNoteInclude<ExtArgs> | null
    where?: SessionNoteWhereInput
    orderBy?: SessionNoteOrderByWithRelationInput | SessionNoteOrderByWithRelationInput[]
    cursor?: SessionNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionNoteScalarFieldEnum | SessionNoteScalarFieldEnum[]
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Encounter
   */

  export type AggregateEncounter = {
    _count: EncounterCountAggregateOutputType | null
    _avg: EncounterAvgAggregateOutputType | null
    _sum: EncounterSumAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  export type EncounterAvgAggregateOutputType = {
    difficulty: number | null
  }

  export type EncounterSumAggregateOutputType = {
    difficulty: number | null
  }

  export type EncounterMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    encounterType: string | null
    difficulty: number | null
    location: string | null
    status: string | null
    outcome: string | null
    campaignId: string | null
    sessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EncounterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    encounterType: string | null
    difficulty: number | null
    location: string | null
    status: string | null
    outcome: string | null
    campaignId: string | null
    sessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EncounterCountAggregateOutputType = {
    id: number
    name: number
    description: number
    encounterType: number
    difficulty: number
    location: number
    environment: number
    npcs: number
    rewards: number
    status: number
    outcome: number
    campaignId: number
    sessionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EncounterAvgAggregateInputType = {
    difficulty?: true
  }

  export type EncounterSumAggregateInputType = {
    difficulty?: true
  }

  export type EncounterMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    encounterType?: true
    difficulty?: true
    location?: true
    status?: true
    outcome?: true
    campaignId?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EncounterMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    encounterType?: true
    difficulty?: true
    location?: true
    status?: true
    outcome?: true
    campaignId?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EncounterCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    encounterType?: true
    difficulty?: true
    location?: true
    environment?: true
    npcs?: true
    rewards?: true
    status?: true
    outcome?: true
    campaignId?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EncounterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounter to aggregate.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Encounters
    **/
    _count?: true | EncounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncounterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncounterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterMaxAggregateInputType
  }

  export type GetEncounterAggregateType<T extends EncounterAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounter[P]>
      : GetScalarType<T[P], AggregateEncounter[P]>
  }




  export type EncounterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithAggregationInput | EncounterOrderByWithAggregationInput[]
    by: EncounterScalarFieldEnum[] | EncounterScalarFieldEnum
    having?: EncounterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterCountAggregateInputType | true
    _avg?: EncounterAvgAggregateInputType
    _sum?: EncounterSumAggregateInputType
    _min?: EncounterMinAggregateInputType
    _max?: EncounterMaxAggregateInputType
  }

  export type EncounterGroupByOutputType = {
    id: string
    name: string
    description: string | null
    encounterType: string
    difficulty: number | null
    location: string | null
    environment: JsonValue | null
    npcs: JsonValue | null
    rewards: JsonValue | null
    status: string
    outcome: string | null
    campaignId: string
    sessionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: EncounterCountAggregateOutputType | null
    _avg: EncounterAvgAggregateOutputType | null
    _sum: EncounterSumAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  type GetEncounterGroupByPayload<T extends EncounterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterGroupByOutputType[P]>
        }
      >
    >


  export type EncounterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    encounterType?: boolean
    difficulty?: boolean
    location?: boolean
    environment?: boolean
    npcs?: boolean
    rewards?: boolean
    status?: boolean
    outcome?: boolean
    campaignId?: boolean
    sessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    session?: boolean | Encounter$sessionArgs<ExtArgs>
    combatSessions?: boolean | Encounter$combatSessionsArgs<ExtArgs>
    _count?: boolean | EncounterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    encounterType?: boolean
    difficulty?: boolean
    location?: boolean
    environment?: boolean
    npcs?: boolean
    rewards?: boolean
    status?: boolean
    outcome?: boolean
    campaignId?: boolean
    sessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    session?: boolean | Encounter$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    encounterType?: boolean
    difficulty?: boolean
    location?: boolean
    environment?: boolean
    npcs?: boolean
    rewards?: boolean
    status?: boolean
    outcome?: boolean
    campaignId?: boolean
    sessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EncounterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    session?: boolean | Encounter$sessionArgs<ExtArgs>
    combatSessions?: boolean | Encounter$combatSessionsArgs<ExtArgs>
    _count?: boolean | EncounterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EncounterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    session?: boolean | Encounter$sessionArgs<ExtArgs>
  }

  export type $EncounterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Encounter"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      session: Prisma.$SessionPayload<ExtArgs> | null
      combatSessions: Prisma.$CombatSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      encounterType: string
      difficulty: number | null
      location: string | null
      environment: Prisma.JsonValue | null
      npcs: Prisma.JsonValue | null
      rewards: Prisma.JsonValue | null
      status: string
      outcome: string | null
      campaignId: string
      sessionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["encounter"]>
    composites: {}
  }

  type EncounterGetPayload<S extends boolean | null | undefined | EncounterDefaultArgs> = $Result.GetResult<Prisma.$EncounterPayload, S>

  type EncounterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EncounterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EncounterCountAggregateInputType | true
    }

  export interface EncounterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Encounter'], meta: { name: 'Encounter' } }
    /**
     * Find zero or one Encounter that matches the filter.
     * @param {EncounterFindUniqueArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterFindUniqueArgs>(args: SelectSubset<T, EncounterFindUniqueArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Encounter that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EncounterFindUniqueOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Encounter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterFindFirstArgs>(args?: SelectSubset<T, EncounterFindFirstArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Encounter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Encounters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Encounters
     * const encounters = await prisma.encounter.findMany()
     * 
     * // Get first 10 Encounters
     * const encounters = await prisma.encounter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterWithIdOnly = await prisma.encounter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterFindManyArgs>(args?: SelectSubset<T, EncounterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Encounter.
     * @param {EncounterCreateArgs} args - Arguments to create a Encounter.
     * @example
     * // Create one Encounter
     * const Encounter = await prisma.encounter.create({
     *   data: {
     *     // ... data to create a Encounter
     *   }
     * })
     * 
     */
    create<T extends EncounterCreateArgs>(args: SelectSubset<T, EncounterCreateArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Encounters.
     * @param {EncounterCreateManyArgs} args - Arguments to create many Encounters.
     * @example
     * // Create many Encounters
     * const encounter = await prisma.encounter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterCreateManyArgs>(args?: SelectSubset<T, EncounterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Encounters and returns the data saved in the database.
     * @param {EncounterCreateManyAndReturnArgs} args - Arguments to create many Encounters.
     * @example
     * // Create many Encounters
     * const encounter = await prisma.encounter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Encounters and only return the `id`
     * const encounterWithIdOnly = await prisma.encounter.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Encounter.
     * @param {EncounterDeleteArgs} args - Arguments to delete one Encounter.
     * @example
     * // Delete one Encounter
     * const Encounter = await prisma.encounter.delete({
     *   where: {
     *     // ... filter to delete one Encounter
     *   }
     * })
     * 
     */
    delete<T extends EncounterDeleteArgs>(args: SelectSubset<T, EncounterDeleteArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Encounter.
     * @param {EncounterUpdateArgs} args - Arguments to update one Encounter.
     * @example
     * // Update one Encounter
     * const encounter = await prisma.encounter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterUpdateArgs>(args: SelectSubset<T, EncounterUpdateArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Encounters.
     * @param {EncounterDeleteManyArgs} args - Arguments to filter Encounters to delete.
     * @example
     * // Delete a few Encounters
     * const { count } = await prisma.encounter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterDeleteManyArgs>(args?: SelectSubset<T, EncounterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Encounters
     * const encounter = await prisma.encounter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterUpdateManyArgs>(args: SelectSubset<T, EncounterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Encounter.
     * @param {EncounterUpsertArgs} args - Arguments to update or create a Encounter.
     * @example
     * // Update or create a Encounter
     * const encounter = await prisma.encounter.upsert({
     *   create: {
     *     // ... data to create a Encounter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Encounter we want to update
     *   }
     * })
     */
    upsert<T extends EncounterUpsertArgs>(args: SelectSubset<T, EncounterUpsertArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterCountArgs} args - Arguments to filter Encounters to count.
     * @example
     * // Count the number of Encounters
     * const count = await prisma.encounter.count({
     *   where: {
     *     // ... the filter for the Encounters we want to count
     *   }
     * })
    **/
    count<T extends EncounterCountArgs>(
      args?: Subset<T, EncounterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterAggregateArgs>(args: Subset<T, EncounterAggregateArgs>): Prisma.PrismaPromise<GetEncounterAggregateType<T>>

    /**
     * Group by Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterGroupByArgs['orderBy'] }
        : { orderBy?: EncounterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Encounter model
   */
  readonly fields: EncounterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Encounter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    session<T extends Encounter$sessionArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$sessionArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    combatSessions<T extends Encounter$combatSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$combatSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombatSessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Encounter model
   */ 
  interface EncounterFieldRefs {
    readonly id: FieldRef<"Encounter", 'String'>
    readonly name: FieldRef<"Encounter", 'String'>
    readonly description: FieldRef<"Encounter", 'String'>
    readonly encounterType: FieldRef<"Encounter", 'String'>
    readonly difficulty: FieldRef<"Encounter", 'Int'>
    readonly location: FieldRef<"Encounter", 'String'>
    readonly environment: FieldRef<"Encounter", 'Json'>
    readonly npcs: FieldRef<"Encounter", 'Json'>
    readonly rewards: FieldRef<"Encounter", 'Json'>
    readonly status: FieldRef<"Encounter", 'String'>
    readonly outcome: FieldRef<"Encounter", 'String'>
    readonly campaignId: FieldRef<"Encounter", 'String'>
    readonly sessionId: FieldRef<"Encounter", 'String'>
    readonly createdAt: FieldRef<"Encounter", 'DateTime'>
    readonly updatedAt: FieldRef<"Encounter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Encounter findUnique
   */
  export type EncounterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findUniqueOrThrow
   */
  export type EncounterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findFirst
   */
  export type EncounterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findFirstOrThrow
   */
  export type EncounterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findMany
   */
  export type EncounterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounters to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter create
   */
  export type EncounterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to create a Encounter.
     */
    data: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
  }

  /**
   * Encounter createMany
   */
  export type EncounterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Encounters.
     */
    data: EncounterCreateManyInput | EncounterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Encounter createManyAndReturn
   */
  export type EncounterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Encounters.
     */
    data: EncounterCreateManyInput | EncounterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Encounter update
   */
  export type EncounterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to update a Encounter.
     */
    data: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
    /**
     * Choose, which Encounter to update.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter updateMany
   */
  export type EncounterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Encounters.
     */
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyInput>
    /**
     * Filter which Encounters to update
     */
    where?: EncounterWhereInput
  }

  /**
   * Encounter upsert
   */
  export type EncounterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The filter to search for the Encounter to update in case it exists.
     */
    where: EncounterWhereUniqueInput
    /**
     * In case the Encounter found by the `where` argument doesn't exist, create a new Encounter with this data.
     */
    create: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
    /**
     * In case the Encounter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
  }

  /**
   * Encounter delete
   */
  export type EncounterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter which Encounter to delete.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter deleteMany
   */
  export type EncounterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounters to delete
     */
    where?: EncounterWhereInput
  }

  /**
   * Encounter.session
   */
  export type Encounter$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
  }

  /**
   * Encounter.combatSessions
   */
  export type Encounter$combatSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatSession
     */
    select?: CombatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatSessionInclude<ExtArgs> | null
    where?: CombatSessionWhereInput
    orderBy?: CombatSessionOrderByWithRelationInput | CombatSessionOrderByWithRelationInput[]
    cursor?: CombatSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CombatSessionScalarFieldEnum | CombatSessionScalarFieldEnum[]
  }

  /**
   * Encounter without action
   */
  export type EncounterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
  }


  /**
   * Model CombatSession
   */

  export type AggregateCombatSession = {
    _count: CombatSessionCountAggregateOutputType | null
    _avg: CombatSessionAvgAggregateOutputType | null
    _sum: CombatSessionSumAggregateOutputType | null
    _min: CombatSessionMinAggregateOutputType | null
    _max: CombatSessionMaxAggregateOutputType | null
  }

  export type CombatSessionAvgAggregateOutputType = {
    round: number | null
  }

  export type CombatSessionSumAggregateOutputType = {
    round: number | null
  }

  export type CombatSessionMinAggregateOutputType = {
    id: string | null
    name: string | null
    round: number | null
    phase: string | null
    status: string | null
    encounterId: string | null
    sessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CombatSessionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    round: number | null
    phase: string | null
    status: string | null
    encounterId: string | null
    sessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CombatSessionCountAggregateOutputType = {
    id: number
    name: number
    round: number
    phase: number
    status: number
    initiative: number
    encounterId: number
    sessionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CombatSessionAvgAggregateInputType = {
    round?: true
  }

  export type CombatSessionSumAggregateInputType = {
    round?: true
  }

  export type CombatSessionMinAggregateInputType = {
    id?: true
    name?: true
    round?: true
    phase?: true
    status?: true
    encounterId?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CombatSessionMaxAggregateInputType = {
    id?: true
    name?: true
    round?: true
    phase?: true
    status?: true
    encounterId?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CombatSessionCountAggregateInputType = {
    id?: true
    name?: true
    round?: true
    phase?: true
    status?: true
    initiative?: true
    encounterId?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CombatSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CombatSession to aggregate.
     */
    where?: CombatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatSessions to fetch.
     */
    orderBy?: CombatSessionOrderByWithRelationInput | CombatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CombatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CombatSessions
    **/
    _count?: true | CombatSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CombatSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CombatSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CombatSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CombatSessionMaxAggregateInputType
  }

  export type GetCombatSessionAggregateType<T extends CombatSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateCombatSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCombatSession[P]>
      : GetScalarType<T[P], AggregateCombatSession[P]>
  }




  export type CombatSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CombatSessionWhereInput
    orderBy?: CombatSessionOrderByWithAggregationInput | CombatSessionOrderByWithAggregationInput[]
    by: CombatSessionScalarFieldEnum[] | CombatSessionScalarFieldEnum
    having?: CombatSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CombatSessionCountAggregateInputType | true
    _avg?: CombatSessionAvgAggregateInputType
    _sum?: CombatSessionSumAggregateInputType
    _min?: CombatSessionMinAggregateInputType
    _max?: CombatSessionMaxAggregateInputType
  }

  export type CombatSessionGroupByOutputType = {
    id: string
    name: string | null
    round: number
    phase: string
    status: string
    initiative: JsonValue | null
    encounterId: string | null
    sessionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CombatSessionCountAggregateOutputType | null
    _avg: CombatSessionAvgAggregateOutputType | null
    _sum: CombatSessionSumAggregateOutputType | null
    _min: CombatSessionMinAggregateOutputType | null
    _max: CombatSessionMaxAggregateOutputType | null
  }

  type GetCombatSessionGroupByPayload<T extends CombatSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CombatSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CombatSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CombatSessionGroupByOutputType[P]>
            : GetScalarType<T[P], CombatSessionGroupByOutputType[P]>
        }
      >
    >


  export type CombatSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    round?: boolean
    phase?: boolean
    status?: boolean
    initiative?: boolean
    encounterId?: boolean
    sessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    encounter?: boolean | CombatSession$encounterArgs<ExtArgs>
    session?: boolean | CombatSession$sessionArgs<ExtArgs>
    actions?: boolean | CombatSession$actionsArgs<ExtArgs>
    _count?: boolean | CombatSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["combatSession"]>

  export type CombatSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    round?: boolean
    phase?: boolean
    status?: boolean
    initiative?: boolean
    encounterId?: boolean
    sessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    encounter?: boolean | CombatSession$encounterArgs<ExtArgs>
    session?: boolean | CombatSession$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["combatSession"]>

  export type CombatSessionSelectScalar = {
    id?: boolean
    name?: boolean
    round?: boolean
    phase?: boolean
    status?: boolean
    initiative?: boolean
    encounterId?: boolean
    sessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CombatSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | CombatSession$encounterArgs<ExtArgs>
    session?: boolean | CombatSession$sessionArgs<ExtArgs>
    actions?: boolean | CombatSession$actionsArgs<ExtArgs>
    _count?: boolean | CombatSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CombatSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | CombatSession$encounterArgs<ExtArgs>
    session?: boolean | CombatSession$sessionArgs<ExtArgs>
  }

  export type $CombatSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CombatSession"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs> | null
      session: Prisma.$SessionPayload<ExtArgs> | null
      actions: Prisma.$CombatActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      round: number
      phase: string
      status: string
      initiative: Prisma.JsonValue | null
      encounterId: string | null
      sessionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["combatSession"]>
    composites: {}
  }

  type CombatSessionGetPayload<S extends boolean | null | undefined | CombatSessionDefaultArgs> = $Result.GetResult<Prisma.$CombatSessionPayload, S>

  type CombatSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CombatSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CombatSessionCountAggregateInputType | true
    }

  export interface CombatSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CombatSession'], meta: { name: 'CombatSession' } }
    /**
     * Find zero or one CombatSession that matches the filter.
     * @param {CombatSessionFindUniqueArgs} args - Arguments to find a CombatSession
     * @example
     * // Get one CombatSession
     * const combatSession = await prisma.combatSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CombatSessionFindUniqueArgs>(args: SelectSubset<T, CombatSessionFindUniqueArgs<ExtArgs>>): Prisma__CombatSessionClient<$Result.GetResult<Prisma.$CombatSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CombatSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CombatSessionFindUniqueOrThrowArgs} args - Arguments to find a CombatSession
     * @example
     * // Get one CombatSession
     * const combatSession = await prisma.combatSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CombatSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, CombatSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CombatSessionClient<$Result.GetResult<Prisma.$CombatSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CombatSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatSessionFindFirstArgs} args - Arguments to find a CombatSession
     * @example
     * // Get one CombatSession
     * const combatSession = await prisma.combatSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CombatSessionFindFirstArgs>(args?: SelectSubset<T, CombatSessionFindFirstArgs<ExtArgs>>): Prisma__CombatSessionClient<$Result.GetResult<Prisma.$CombatSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CombatSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatSessionFindFirstOrThrowArgs} args - Arguments to find a CombatSession
     * @example
     * // Get one CombatSession
     * const combatSession = await prisma.combatSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CombatSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, CombatSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CombatSessionClient<$Result.GetResult<Prisma.$CombatSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CombatSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CombatSessions
     * const combatSessions = await prisma.combatSession.findMany()
     * 
     * // Get first 10 CombatSessions
     * const combatSessions = await prisma.combatSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const combatSessionWithIdOnly = await prisma.combatSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CombatSessionFindManyArgs>(args?: SelectSubset<T, CombatSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombatSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CombatSession.
     * @param {CombatSessionCreateArgs} args - Arguments to create a CombatSession.
     * @example
     * // Create one CombatSession
     * const CombatSession = await prisma.combatSession.create({
     *   data: {
     *     // ... data to create a CombatSession
     *   }
     * })
     * 
     */
    create<T extends CombatSessionCreateArgs>(args: SelectSubset<T, CombatSessionCreateArgs<ExtArgs>>): Prisma__CombatSessionClient<$Result.GetResult<Prisma.$CombatSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CombatSessions.
     * @param {CombatSessionCreateManyArgs} args - Arguments to create many CombatSessions.
     * @example
     * // Create many CombatSessions
     * const combatSession = await prisma.combatSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CombatSessionCreateManyArgs>(args?: SelectSubset<T, CombatSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CombatSessions and returns the data saved in the database.
     * @param {CombatSessionCreateManyAndReturnArgs} args - Arguments to create many CombatSessions.
     * @example
     * // Create many CombatSessions
     * const combatSession = await prisma.combatSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CombatSessions and only return the `id`
     * const combatSessionWithIdOnly = await prisma.combatSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CombatSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, CombatSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombatSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CombatSession.
     * @param {CombatSessionDeleteArgs} args - Arguments to delete one CombatSession.
     * @example
     * // Delete one CombatSession
     * const CombatSession = await prisma.combatSession.delete({
     *   where: {
     *     // ... filter to delete one CombatSession
     *   }
     * })
     * 
     */
    delete<T extends CombatSessionDeleteArgs>(args: SelectSubset<T, CombatSessionDeleteArgs<ExtArgs>>): Prisma__CombatSessionClient<$Result.GetResult<Prisma.$CombatSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CombatSession.
     * @param {CombatSessionUpdateArgs} args - Arguments to update one CombatSession.
     * @example
     * // Update one CombatSession
     * const combatSession = await prisma.combatSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CombatSessionUpdateArgs>(args: SelectSubset<T, CombatSessionUpdateArgs<ExtArgs>>): Prisma__CombatSessionClient<$Result.GetResult<Prisma.$CombatSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CombatSessions.
     * @param {CombatSessionDeleteManyArgs} args - Arguments to filter CombatSessions to delete.
     * @example
     * // Delete a few CombatSessions
     * const { count } = await prisma.combatSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CombatSessionDeleteManyArgs>(args?: SelectSubset<T, CombatSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CombatSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CombatSessions
     * const combatSession = await prisma.combatSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CombatSessionUpdateManyArgs>(args: SelectSubset<T, CombatSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CombatSession.
     * @param {CombatSessionUpsertArgs} args - Arguments to update or create a CombatSession.
     * @example
     * // Update or create a CombatSession
     * const combatSession = await prisma.combatSession.upsert({
     *   create: {
     *     // ... data to create a CombatSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CombatSession we want to update
     *   }
     * })
     */
    upsert<T extends CombatSessionUpsertArgs>(args: SelectSubset<T, CombatSessionUpsertArgs<ExtArgs>>): Prisma__CombatSessionClient<$Result.GetResult<Prisma.$CombatSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CombatSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatSessionCountArgs} args - Arguments to filter CombatSessions to count.
     * @example
     * // Count the number of CombatSessions
     * const count = await prisma.combatSession.count({
     *   where: {
     *     // ... the filter for the CombatSessions we want to count
     *   }
     * })
    **/
    count<T extends CombatSessionCountArgs>(
      args?: Subset<T, CombatSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CombatSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CombatSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CombatSessionAggregateArgs>(args: Subset<T, CombatSessionAggregateArgs>): Prisma.PrismaPromise<GetCombatSessionAggregateType<T>>

    /**
     * Group by CombatSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CombatSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CombatSessionGroupByArgs['orderBy'] }
        : { orderBy?: CombatSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CombatSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCombatSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CombatSession model
   */
  readonly fields: CombatSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CombatSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CombatSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends CombatSession$encounterArgs<ExtArgs> = {}>(args?: Subset<T, CombatSession$encounterArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    session<T extends CombatSession$sessionArgs<ExtArgs> = {}>(args?: Subset<T, CombatSession$sessionArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    actions<T extends CombatSession$actionsArgs<ExtArgs> = {}>(args?: Subset<T, CombatSession$actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombatActionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CombatSession model
   */ 
  interface CombatSessionFieldRefs {
    readonly id: FieldRef<"CombatSession", 'String'>
    readonly name: FieldRef<"CombatSession", 'String'>
    readonly round: FieldRef<"CombatSession", 'Int'>
    readonly phase: FieldRef<"CombatSession", 'String'>
    readonly status: FieldRef<"CombatSession", 'String'>
    readonly initiative: FieldRef<"CombatSession", 'Json'>
    readonly encounterId: FieldRef<"CombatSession", 'String'>
    readonly sessionId: FieldRef<"CombatSession", 'String'>
    readonly createdAt: FieldRef<"CombatSession", 'DateTime'>
    readonly updatedAt: FieldRef<"CombatSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CombatSession findUnique
   */
  export type CombatSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatSession
     */
    select?: CombatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatSessionInclude<ExtArgs> | null
    /**
     * Filter, which CombatSession to fetch.
     */
    where: CombatSessionWhereUniqueInput
  }

  /**
   * CombatSession findUniqueOrThrow
   */
  export type CombatSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatSession
     */
    select?: CombatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatSessionInclude<ExtArgs> | null
    /**
     * Filter, which CombatSession to fetch.
     */
    where: CombatSessionWhereUniqueInput
  }

  /**
   * CombatSession findFirst
   */
  export type CombatSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatSession
     */
    select?: CombatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatSessionInclude<ExtArgs> | null
    /**
     * Filter, which CombatSession to fetch.
     */
    where?: CombatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatSessions to fetch.
     */
    orderBy?: CombatSessionOrderByWithRelationInput | CombatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CombatSessions.
     */
    cursor?: CombatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CombatSessions.
     */
    distinct?: CombatSessionScalarFieldEnum | CombatSessionScalarFieldEnum[]
  }

  /**
   * CombatSession findFirstOrThrow
   */
  export type CombatSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatSession
     */
    select?: CombatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatSessionInclude<ExtArgs> | null
    /**
     * Filter, which CombatSession to fetch.
     */
    where?: CombatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatSessions to fetch.
     */
    orderBy?: CombatSessionOrderByWithRelationInput | CombatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CombatSessions.
     */
    cursor?: CombatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CombatSessions.
     */
    distinct?: CombatSessionScalarFieldEnum | CombatSessionScalarFieldEnum[]
  }

  /**
   * CombatSession findMany
   */
  export type CombatSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatSession
     */
    select?: CombatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatSessionInclude<ExtArgs> | null
    /**
     * Filter, which CombatSessions to fetch.
     */
    where?: CombatSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatSessions to fetch.
     */
    orderBy?: CombatSessionOrderByWithRelationInput | CombatSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CombatSessions.
     */
    cursor?: CombatSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatSessions.
     */
    skip?: number
    distinct?: CombatSessionScalarFieldEnum | CombatSessionScalarFieldEnum[]
  }

  /**
   * CombatSession create
   */
  export type CombatSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatSession
     */
    select?: CombatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a CombatSession.
     */
    data: XOR<CombatSessionCreateInput, CombatSessionUncheckedCreateInput>
  }

  /**
   * CombatSession createMany
   */
  export type CombatSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CombatSessions.
     */
    data: CombatSessionCreateManyInput | CombatSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CombatSession createManyAndReturn
   */
  export type CombatSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatSession
     */
    select?: CombatSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CombatSessions.
     */
    data: CombatSessionCreateManyInput | CombatSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CombatSession update
   */
  export type CombatSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatSession
     */
    select?: CombatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a CombatSession.
     */
    data: XOR<CombatSessionUpdateInput, CombatSessionUncheckedUpdateInput>
    /**
     * Choose, which CombatSession to update.
     */
    where: CombatSessionWhereUniqueInput
  }

  /**
   * CombatSession updateMany
   */
  export type CombatSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CombatSessions.
     */
    data: XOR<CombatSessionUpdateManyMutationInput, CombatSessionUncheckedUpdateManyInput>
    /**
     * Filter which CombatSessions to update
     */
    where?: CombatSessionWhereInput
  }

  /**
   * CombatSession upsert
   */
  export type CombatSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatSession
     */
    select?: CombatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the CombatSession to update in case it exists.
     */
    where: CombatSessionWhereUniqueInput
    /**
     * In case the CombatSession found by the `where` argument doesn't exist, create a new CombatSession with this data.
     */
    create: XOR<CombatSessionCreateInput, CombatSessionUncheckedCreateInput>
    /**
     * In case the CombatSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CombatSessionUpdateInput, CombatSessionUncheckedUpdateInput>
  }

  /**
   * CombatSession delete
   */
  export type CombatSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatSession
     */
    select?: CombatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatSessionInclude<ExtArgs> | null
    /**
     * Filter which CombatSession to delete.
     */
    where: CombatSessionWhereUniqueInput
  }

  /**
   * CombatSession deleteMany
   */
  export type CombatSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CombatSessions to delete
     */
    where?: CombatSessionWhereInput
  }

  /**
   * CombatSession.encounter
   */
  export type CombatSession$encounterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
  }

  /**
   * CombatSession.session
   */
  export type CombatSession$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
  }

  /**
   * CombatSession.actions
   */
  export type CombatSession$actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatAction
     */
    select?: CombatActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatActionInclude<ExtArgs> | null
    where?: CombatActionWhereInput
    orderBy?: CombatActionOrderByWithRelationInput | CombatActionOrderByWithRelationInput[]
    cursor?: CombatActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CombatActionScalarFieldEnum | CombatActionScalarFieldEnum[]
  }

  /**
   * CombatSession without action
   */
  export type CombatSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatSession
     */
    select?: CombatSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatSessionInclude<ExtArgs> | null
  }


  /**
   * Model CombatAction
   */

  export type AggregateCombatAction = {
    _count: CombatActionCountAggregateOutputType | null
    _avg: CombatActionAvgAggregateOutputType | null
    _sum: CombatActionSumAggregateOutputType | null
    _min: CombatActionMinAggregateOutputType | null
    _max: CombatActionMaxAggregateOutputType | null
  }

  export type CombatActionAvgAggregateOutputType = {
    rollResult: number | null
    round: number | null
  }

  export type CombatActionSumAggregateOutputType = {
    rollResult: number | null
    round: number | null
  }

  export type CombatActionMinAggregateOutputType = {
    id: string | null
    actionType: string | null
    description: string | null
    target: string | null
    diceRolled: string | null
    rollResult: number | null
    characterId: string | null
    combatSessionId: string | null
    round: number | null
    timestamp: Date | null
  }

  export type CombatActionMaxAggregateOutputType = {
    id: string | null
    actionType: string | null
    description: string | null
    target: string | null
    diceRolled: string | null
    rollResult: number | null
    characterId: string | null
    combatSessionId: string | null
    round: number | null
    timestamp: Date | null
  }

  export type CombatActionCountAggregateOutputType = {
    id: number
    actionType: number
    description: number
    target: number
    result: number
    diceRolled: number
    rollResult: number
    modifiers: number
    characterId: number
    combatSessionId: number
    round: number
    timestamp: number
    _all: number
  }


  export type CombatActionAvgAggregateInputType = {
    rollResult?: true
    round?: true
  }

  export type CombatActionSumAggregateInputType = {
    rollResult?: true
    round?: true
  }

  export type CombatActionMinAggregateInputType = {
    id?: true
    actionType?: true
    description?: true
    target?: true
    diceRolled?: true
    rollResult?: true
    characterId?: true
    combatSessionId?: true
    round?: true
    timestamp?: true
  }

  export type CombatActionMaxAggregateInputType = {
    id?: true
    actionType?: true
    description?: true
    target?: true
    diceRolled?: true
    rollResult?: true
    characterId?: true
    combatSessionId?: true
    round?: true
    timestamp?: true
  }

  export type CombatActionCountAggregateInputType = {
    id?: true
    actionType?: true
    description?: true
    target?: true
    result?: true
    diceRolled?: true
    rollResult?: true
    modifiers?: true
    characterId?: true
    combatSessionId?: true
    round?: true
    timestamp?: true
    _all?: true
  }

  export type CombatActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CombatAction to aggregate.
     */
    where?: CombatActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatActions to fetch.
     */
    orderBy?: CombatActionOrderByWithRelationInput | CombatActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CombatActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CombatActions
    **/
    _count?: true | CombatActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CombatActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CombatActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CombatActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CombatActionMaxAggregateInputType
  }

  export type GetCombatActionAggregateType<T extends CombatActionAggregateArgs> = {
        [P in keyof T & keyof AggregateCombatAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCombatAction[P]>
      : GetScalarType<T[P], AggregateCombatAction[P]>
  }




  export type CombatActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CombatActionWhereInput
    orderBy?: CombatActionOrderByWithAggregationInput | CombatActionOrderByWithAggregationInput[]
    by: CombatActionScalarFieldEnum[] | CombatActionScalarFieldEnum
    having?: CombatActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CombatActionCountAggregateInputType | true
    _avg?: CombatActionAvgAggregateInputType
    _sum?: CombatActionSumAggregateInputType
    _min?: CombatActionMinAggregateInputType
    _max?: CombatActionMaxAggregateInputType
  }

  export type CombatActionGroupByOutputType = {
    id: string
    actionType: string
    description: string | null
    target: string | null
    result: JsonValue | null
    diceRolled: string | null
    rollResult: number | null
    modifiers: JsonValue | null
    characterId: string | null
    combatSessionId: string
    round: number
    timestamp: Date
    _count: CombatActionCountAggregateOutputType | null
    _avg: CombatActionAvgAggregateOutputType | null
    _sum: CombatActionSumAggregateOutputType | null
    _min: CombatActionMinAggregateOutputType | null
    _max: CombatActionMaxAggregateOutputType | null
  }

  type GetCombatActionGroupByPayload<T extends CombatActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CombatActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CombatActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CombatActionGroupByOutputType[P]>
            : GetScalarType<T[P], CombatActionGroupByOutputType[P]>
        }
      >
    >


  export type CombatActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actionType?: boolean
    description?: boolean
    target?: boolean
    result?: boolean
    diceRolled?: boolean
    rollResult?: boolean
    modifiers?: boolean
    characterId?: boolean
    combatSessionId?: boolean
    round?: boolean
    timestamp?: boolean
    character?: boolean | CombatAction$characterArgs<ExtArgs>
    combatSession?: boolean | CombatSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["combatAction"]>

  export type CombatActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actionType?: boolean
    description?: boolean
    target?: boolean
    result?: boolean
    diceRolled?: boolean
    rollResult?: boolean
    modifiers?: boolean
    characterId?: boolean
    combatSessionId?: boolean
    round?: boolean
    timestamp?: boolean
    character?: boolean | CombatAction$characterArgs<ExtArgs>
    combatSession?: boolean | CombatSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["combatAction"]>

  export type CombatActionSelectScalar = {
    id?: boolean
    actionType?: boolean
    description?: boolean
    target?: boolean
    result?: boolean
    diceRolled?: boolean
    rollResult?: boolean
    modifiers?: boolean
    characterId?: boolean
    combatSessionId?: boolean
    round?: boolean
    timestamp?: boolean
  }

  export type CombatActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CombatAction$characterArgs<ExtArgs>
    combatSession?: boolean | CombatSessionDefaultArgs<ExtArgs>
  }
  export type CombatActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CombatAction$characterArgs<ExtArgs>
    combatSession?: boolean | CombatSessionDefaultArgs<ExtArgs>
  }

  export type $CombatActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CombatAction"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs> | null
      combatSession: Prisma.$CombatSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actionType: string
      description: string | null
      target: string | null
      result: Prisma.JsonValue | null
      diceRolled: string | null
      rollResult: number | null
      modifiers: Prisma.JsonValue | null
      characterId: string | null
      combatSessionId: string
      round: number
      timestamp: Date
    }, ExtArgs["result"]["combatAction"]>
    composites: {}
  }

  type CombatActionGetPayload<S extends boolean | null | undefined | CombatActionDefaultArgs> = $Result.GetResult<Prisma.$CombatActionPayload, S>

  type CombatActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CombatActionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CombatActionCountAggregateInputType | true
    }

  export interface CombatActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CombatAction'], meta: { name: 'CombatAction' } }
    /**
     * Find zero or one CombatAction that matches the filter.
     * @param {CombatActionFindUniqueArgs} args - Arguments to find a CombatAction
     * @example
     * // Get one CombatAction
     * const combatAction = await prisma.combatAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CombatActionFindUniqueArgs>(args: SelectSubset<T, CombatActionFindUniqueArgs<ExtArgs>>): Prisma__CombatActionClient<$Result.GetResult<Prisma.$CombatActionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CombatAction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CombatActionFindUniqueOrThrowArgs} args - Arguments to find a CombatAction
     * @example
     * // Get one CombatAction
     * const combatAction = await prisma.combatAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CombatActionFindUniqueOrThrowArgs>(args: SelectSubset<T, CombatActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CombatActionClient<$Result.GetResult<Prisma.$CombatActionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CombatAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatActionFindFirstArgs} args - Arguments to find a CombatAction
     * @example
     * // Get one CombatAction
     * const combatAction = await prisma.combatAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CombatActionFindFirstArgs>(args?: SelectSubset<T, CombatActionFindFirstArgs<ExtArgs>>): Prisma__CombatActionClient<$Result.GetResult<Prisma.$CombatActionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CombatAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatActionFindFirstOrThrowArgs} args - Arguments to find a CombatAction
     * @example
     * // Get one CombatAction
     * const combatAction = await prisma.combatAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CombatActionFindFirstOrThrowArgs>(args?: SelectSubset<T, CombatActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CombatActionClient<$Result.GetResult<Prisma.$CombatActionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CombatActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CombatActions
     * const combatActions = await prisma.combatAction.findMany()
     * 
     * // Get first 10 CombatActions
     * const combatActions = await prisma.combatAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const combatActionWithIdOnly = await prisma.combatAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CombatActionFindManyArgs>(args?: SelectSubset<T, CombatActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombatActionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CombatAction.
     * @param {CombatActionCreateArgs} args - Arguments to create a CombatAction.
     * @example
     * // Create one CombatAction
     * const CombatAction = await prisma.combatAction.create({
     *   data: {
     *     // ... data to create a CombatAction
     *   }
     * })
     * 
     */
    create<T extends CombatActionCreateArgs>(args: SelectSubset<T, CombatActionCreateArgs<ExtArgs>>): Prisma__CombatActionClient<$Result.GetResult<Prisma.$CombatActionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CombatActions.
     * @param {CombatActionCreateManyArgs} args - Arguments to create many CombatActions.
     * @example
     * // Create many CombatActions
     * const combatAction = await prisma.combatAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CombatActionCreateManyArgs>(args?: SelectSubset<T, CombatActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CombatActions and returns the data saved in the database.
     * @param {CombatActionCreateManyAndReturnArgs} args - Arguments to create many CombatActions.
     * @example
     * // Create many CombatActions
     * const combatAction = await prisma.combatAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CombatActions and only return the `id`
     * const combatActionWithIdOnly = await prisma.combatAction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CombatActionCreateManyAndReturnArgs>(args?: SelectSubset<T, CombatActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CombatActionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CombatAction.
     * @param {CombatActionDeleteArgs} args - Arguments to delete one CombatAction.
     * @example
     * // Delete one CombatAction
     * const CombatAction = await prisma.combatAction.delete({
     *   where: {
     *     // ... filter to delete one CombatAction
     *   }
     * })
     * 
     */
    delete<T extends CombatActionDeleteArgs>(args: SelectSubset<T, CombatActionDeleteArgs<ExtArgs>>): Prisma__CombatActionClient<$Result.GetResult<Prisma.$CombatActionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CombatAction.
     * @param {CombatActionUpdateArgs} args - Arguments to update one CombatAction.
     * @example
     * // Update one CombatAction
     * const combatAction = await prisma.combatAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CombatActionUpdateArgs>(args: SelectSubset<T, CombatActionUpdateArgs<ExtArgs>>): Prisma__CombatActionClient<$Result.GetResult<Prisma.$CombatActionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CombatActions.
     * @param {CombatActionDeleteManyArgs} args - Arguments to filter CombatActions to delete.
     * @example
     * // Delete a few CombatActions
     * const { count } = await prisma.combatAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CombatActionDeleteManyArgs>(args?: SelectSubset<T, CombatActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CombatActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CombatActions
     * const combatAction = await prisma.combatAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CombatActionUpdateManyArgs>(args: SelectSubset<T, CombatActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CombatAction.
     * @param {CombatActionUpsertArgs} args - Arguments to update or create a CombatAction.
     * @example
     * // Update or create a CombatAction
     * const combatAction = await prisma.combatAction.upsert({
     *   create: {
     *     // ... data to create a CombatAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CombatAction we want to update
     *   }
     * })
     */
    upsert<T extends CombatActionUpsertArgs>(args: SelectSubset<T, CombatActionUpsertArgs<ExtArgs>>): Prisma__CombatActionClient<$Result.GetResult<Prisma.$CombatActionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CombatActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatActionCountArgs} args - Arguments to filter CombatActions to count.
     * @example
     * // Count the number of CombatActions
     * const count = await prisma.combatAction.count({
     *   where: {
     *     // ... the filter for the CombatActions we want to count
     *   }
     * })
    **/
    count<T extends CombatActionCountArgs>(
      args?: Subset<T, CombatActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CombatActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CombatAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CombatActionAggregateArgs>(args: Subset<T, CombatActionAggregateArgs>): Prisma.PrismaPromise<GetCombatActionAggregateType<T>>

    /**
     * Group by CombatAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombatActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CombatActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CombatActionGroupByArgs['orderBy'] }
        : { orderBy?: CombatActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CombatActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCombatActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CombatAction model
   */
  readonly fields: CombatActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CombatAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CombatActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends CombatAction$characterArgs<ExtArgs> = {}>(args?: Subset<T, CombatAction$characterArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    combatSession<T extends CombatSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CombatSessionDefaultArgs<ExtArgs>>): Prisma__CombatSessionClient<$Result.GetResult<Prisma.$CombatSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CombatAction model
   */ 
  interface CombatActionFieldRefs {
    readonly id: FieldRef<"CombatAction", 'String'>
    readonly actionType: FieldRef<"CombatAction", 'String'>
    readonly description: FieldRef<"CombatAction", 'String'>
    readonly target: FieldRef<"CombatAction", 'String'>
    readonly result: FieldRef<"CombatAction", 'Json'>
    readonly diceRolled: FieldRef<"CombatAction", 'String'>
    readonly rollResult: FieldRef<"CombatAction", 'Int'>
    readonly modifiers: FieldRef<"CombatAction", 'Json'>
    readonly characterId: FieldRef<"CombatAction", 'String'>
    readonly combatSessionId: FieldRef<"CombatAction", 'String'>
    readonly round: FieldRef<"CombatAction", 'Int'>
    readonly timestamp: FieldRef<"CombatAction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CombatAction findUnique
   */
  export type CombatActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatAction
     */
    select?: CombatActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatActionInclude<ExtArgs> | null
    /**
     * Filter, which CombatAction to fetch.
     */
    where: CombatActionWhereUniqueInput
  }

  /**
   * CombatAction findUniqueOrThrow
   */
  export type CombatActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatAction
     */
    select?: CombatActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatActionInclude<ExtArgs> | null
    /**
     * Filter, which CombatAction to fetch.
     */
    where: CombatActionWhereUniqueInput
  }

  /**
   * CombatAction findFirst
   */
  export type CombatActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatAction
     */
    select?: CombatActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatActionInclude<ExtArgs> | null
    /**
     * Filter, which CombatAction to fetch.
     */
    where?: CombatActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatActions to fetch.
     */
    orderBy?: CombatActionOrderByWithRelationInput | CombatActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CombatActions.
     */
    cursor?: CombatActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CombatActions.
     */
    distinct?: CombatActionScalarFieldEnum | CombatActionScalarFieldEnum[]
  }

  /**
   * CombatAction findFirstOrThrow
   */
  export type CombatActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatAction
     */
    select?: CombatActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatActionInclude<ExtArgs> | null
    /**
     * Filter, which CombatAction to fetch.
     */
    where?: CombatActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatActions to fetch.
     */
    orderBy?: CombatActionOrderByWithRelationInput | CombatActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CombatActions.
     */
    cursor?: CombatActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CombatActions.
     */
    distinct?: CombatActionScalarFieldEnum | CombatActionScalarFieldEnum[]
  }

  /**
   * CombatAction findMany
   */
  export type CombatActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatAction
     */
    select?: CombatActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatActionInclude<ExtArgs> | null
    /**
     * Filter, which CombatActions to fetch.
     */
    where?: CombatActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CombatActions to fetch.
     */
    orderBy?: CombatActionOrderByWithRelationInput | CombatActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CombatActions.
     */
    cursor?: CombatActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CombatActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CombatActions.
     */
    skip?: number
    distinct?: CombatActionScalarFieldEnum | CombatActionScalarFieldEnum[]
  }

  /**
   * CombatAction create
   */
  export type CombatActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatAction
     */
    select?: CombatActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatActionInclude<ExtArgs> | null
    /**
     * The data needed to create a CombatAction.
     */
    data: XOR<CombatActionCreateInput, CombatActionUncheckedCreateInput>
  }

  /**
   * CombatAction createMany
   */
  export type CombatActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CombatActions.
     */
    data: CombatActionCreateManyInput | CombatActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CombatAction createManyAndReturn
   */
  export type CombatActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatAction
     */
    select?: CombatActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CombatActions.
     */
    data: CombatActionCreateManyInput | CombatActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CombatAction update
   */
  export type CombatActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatAction
     */
    select?: CombatActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatActionInclude<ExtArgs> | null
    /**
     * The data needed to update a CombatAction.
     */
    data: XOR<CombatActionUpdateInput, CombatActionUncheckedUpdateInput>
    /**
     * Choose, which CombatAction to update.
     */
    where: CombatActionWhereUniqueInput
  }

  /**
   * CombatAction updateMany
   */
  export type CombatActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CombatActions.
     */
    data: XOR<CombatActionUpdateManyMutationInput, CombatActionUncheckedUpdateManyInput>
    /**
     * Filter which CombatActions to update
     */
    where?: CombatActionWhereInput
  }

  /**
   * CombatAction upsert
   */
  export type CombatActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatAction
     */
    select?: CombatActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatActionInclude<ExtArgs> | null
    /**
     * The filter to search for the CombatAction to update in case it exists.
     */
    where: CombatActionWhereUniqueInput
    /**
     * In case the CombatAction found by the `where` argument doesn't exist, create a new CombatAction with this data.
     */
    create: XOR<CombatActionCreateInput, CombatActionUncheckedCreateInput>
    /**
     * In case the CombatAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CombatActionUpdateInput, CombatActionUncheckedUpdateInput>
  }

  /**
   * CombatAction delete
   */
  export type CombatActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatAction
     */
    select?: CombatActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatActionInclude<ExtArgs> | null
    /**
     * Filter which CombatAction to delete.
     */
    where: CombatActionWhereUniqueInput
  }

  /**
   * CombatAction deleteMany
   */
  export type CombatActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CombatActions to delete
     */
    where?: CombatActionWhereInput
  }

  /**
   * CombatAction.character
   */
  export type CombatAction$characterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
  }

  /**
   * CombatAction without action
   */
  export type CombatActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CombatAction
     */
    select?: CombatActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CombatActionInclude<ExtArgs> | null
  }


  /**
   * Model DiceRoll
   */

  export type AggregateDiceRoll = {
    _count: DiceRollCountAggregateOutputType | null
    _avg: DiceRollAvgAggregateOutputType | null
    _sum: DiceRollSumAggregateOutputType | null
    _min: DiceRollMinAggregateOutputType | null
    _max: DiceRollMaxAggregateOutputType | null
  }

  export type DiceRollAvgAggregateOutputType = {
    result: number | null
    individual: number | null
  }

  export type DiceRollSumAggregateOutputType = {
    result: number | null
    individual: number[]
  }

  export type DiceRollMinAggregateOutputType = {
    id: string | null
    dice: string | null
    result: number | null
    description: string | null
    isPublic: boolean | null
    isGMOnly: boolean | null
    rollerId: string | null
    campaignId: string | null
    character: string | null
    skill: string | null
    timestamp: Date | null
  }

  export type DiceRollMaxAggregateOutputType = {
    id: string | null
    dice: string | null
    result: number | null
    description: string | null
    isPublic: boolean | null
    isGMOnly: boolean | null
    rollerId: string | null
    campaignId: string | null
    character: string | null
    skill: string | null
    timestamp: Date | null
  }

  export type DiceRollCountAggregateOutputType = {
    id: number
    dice: number
    result: number
    individual: number
    modifiers: number
    description: number
    isPublic: number
    isGMOnly: number
    rollerId: number
    campaignId: number
    character: number
    skill: number
    timestamp: number
    _all: number
  }


  export type DiceRollAvgAggregateInputType = {
    result?: true
    individual?: true
  }

  export type DiceRollSumAggregateInputType = {
    result?: true
    individual?: true
  }

  export type DiceRollMinAggregateInputType = {
    id?: true
    dice?: true
    result?: true
    description?: true
    isPublic?: true
    isGMOnly?: true
    rollerId?: true
    campaignId?: true
    character?: true
    skill?: true
    timestamp?: true
  }

  export type DiceRollMaxAggregateInputType = {
    id?: true
    dice?: true
    result?: true
    description?: true
    isPublic?: true
    isGMOnly?: true
    rollerId?: true
    campaignId?: true
    character?: true
    skill?: true
    timestamp?: true
  }

  export type DiceRollCountAggregateInputType = {
    id?: true
    dice?: true
    result?: true
    individual?: true
    modifiers?: true
    description?: true
    isPublic?: true
    isGMOnly?: true
    rollerId?: true
    campaignId?: true
    character?: true
    skill?: true
    timestamp?: true
    _all?: true
  }

  export type DiceRollAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiceRoll to aggregate.
     */
    where?: DiceRollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiceRolls to fetch.
     */
    orderBy?: DiceRollOrderByWithRelationInput | DiceRollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiceRollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiceRolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiceRolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiceRolls
    **/
    _count?: true | DiceRollCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiceRollAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiceRollSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiceRollMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiceRollMaxAggregateInputType
  }

  export type GetDiceRollAggregateType<T extends DiceRollAggregateArgs> = {
        [P in keyof T & keyof AggregateDiceRoll]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiceRoll[P]>
      : GetScalarType<T[P], AggregateDiceRoll[P]>
  }




  export type DiceRollGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiceRollWhereInput
    orderBy?: DiceRollOrderByWithAggregationInput | DiceRollOrderByWithAggregationInput[]
    by: DiceRollScalarFieldEnum[] | DiceRollScalarFieldEnum
    having?: DiceRollScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiceRollCountAggregateInputType | true
    _avg?: DiceRollAvgAggregateInputType
    _sum?: DiceRollSumAggregateInputType
    _min?: DiceRollMinAggregateInputType
    _max?: DiceRollMaxAggregateInputType
  }

  export type DiceRollGroupByOutputType = {
    id: string
    dice: string
    result: number
    individual: number[]
    modifiers: string[]
    description: string | null
    isPublic: boolean
    isGMOnly: boolean
    rollerId: string
    campaignId: string
    character: string | null
    skill: string | null
    timestamp: Date
    _count: DiceRollCountAggregateOutputType | null
    _avg: DiceRollAvgAggregateOutputType | null
    _sum: DiceRollSumAggregateOutputType | null
    _min: DiceRollMinAggregateOutputType | null
    _max: DiceRollMaxAggregateOutputType | null
  }

  type GetDiceRollGroupByPayload<T extends DiceRollGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiceRollGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiceRollGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiceRollGroupByOutputType[P]>
            : GetScalarType<T[P], DiceRollGroupByOutputType[P]>
        }
      >
    >


  export type DiceRollSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dice?: boolean
    result?: boolean
    individual?: boolean
    modifiers?: boolean
    description?: boolean
    isPublic?: boolean
    isGMOnly?: boolean
    rollerId?: boolean
    campaignId?: boolean
    character?: boolean
    skill?: boolean
    timestamp?: boolean
    roller?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diceRoll"]>

  export type DiceRollSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dice?: boolean
    result?: boolean
    individual?: boolean
    modifiers?: boolean
    description?: boolean
    isPublic?: boolean
    isGMOnly?: boolean
    rollerId?: boolean
    campaignId?: boolean
    character?: boolean
    skill?: boolean
    timestamp?: boolean
    roller?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diceRoll"]>

  export type DiceRollSelectScalar = {
    id?: boolean
    dice?: boolean
    result?: boolean
    individual?: boolean
    modifiers?: boolean
    description?: boolean
    isPublic?: boolean
    isGMOnly?: boolean
    rollerId?: boolean
    campaignId?: boolean
    character?: boolean
    skill?: boolean
    timestamp?: boolean
  }

  export type DiceRollInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roller?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type DiceRollIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roller?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $DiceRollPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DiceRoll"
    objects: {
      roller: Prisma.$UserPayload<ExtArgs>
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dice: string
      result: number
      individual: number[]
      modifiers: string[]
      description: string | null
      isPublic: boolean
      isGMOnly: boolean
      rollerId: string
      campaignId: string
      character: string | null
      skill: string | null
      timestamp: Date
    }, ExtArgs["result"]["diceRoll"]>
    composites: {}
  }

  type DiceRollGetPayload<S extends boolean | null | undefined | DiceRollDefaultArgs> = $Result.GetResult<Prisma.$DiceRollPayload, S>

  type DiceRollCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DiceRollFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DiceRollCountAggregateInputType | true
    }

  export interface DiceRollDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DiceRoll'], meta: { name: 'DiceRoll' } }
    /**
     * Find zero or one DiceRoll that matches the filter.
     * @param {DiceRollFindUniqueArgs} args - Arguments to find a DiceRoll
     * @example
     * // Get one DiceRoll
     * const diceRoll = await prisma.diceRoll.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiceRollFindUniqueArgs>(args: SelectSubset<T, DiceRollFindUniqueArgs<ExtArgs>>): Prisma__DiceRollClient<$Result.GetResult<Prisma.$DiceRollPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DiceRoll that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DiceRollFindUniqueOrThrowArgs} args - Arguments to find a DiceRoll
     * @example
     * // Get one DiceRoll
     * const diceRoll = await prisma.diceRoll.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiceRollFindUniqueOrThrowArgs>(args: SelectSubset<T, DiceRollFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiceRollClient<$Result.GetResult<Prisma.$DiceRollPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DiceRoll that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiceRollFindFirstArgs} args - Arguments to find a DiceRoll
     * @example
     * // Get one DiceRoll
     * const diceRoll = await prisma.diceRoll.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiceRollFindFirstArgs>(args?: SelectSubset<T, DiceRollFindFirstArgs<ExtArgs>>): Prisma__DiceRollClient<$Result.GetResult<Prisma.$DiceRollPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DiceRoll that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiceRollFindFirstOrThrowArgs} args - Arguments to find a DiceRoll
     * @example
     * // Get one DiceRoll
     * const diceRoll = await prisma.diceRoll.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiceRollFindFirstOrThrowArgs>(args?: SelectSubset<T, DiceRollFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiceRollClient<$Result.GetResult<Prisma.$DiceRollPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DiceRolls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiceRollFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiceRolls
     * const diceRolls = await prisma.diceRoll.findMany()
     * 
     * // Get first 10 DiceRolls
     * const diceRolls = await prisma.diceRoll.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const diceRollWithIdOnly = await prisma.diceRoll.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiceRollFindManyArgs>(args?: SelectSubset<T, DiceRollFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiceRollPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DiceRoll.
     * @param {DiceRollCreateArgs} args - Arguments to create a DiceRoll.
     * @example
     * // Create one DiceRoll
     * const DiceRoll = await prisma.diceRoll.create({
     *   data: {
     *     // ... data to create a DiceRoll
     *   }
     * })
     * 
     */
    create<T extends DiceRollCreateArgs>(args: SelectSubset<T, DiceRollCreateArgs<ExtArgs>>): Prisma__DiceRollClient<$Result.GetResult<Prisma.$DiceRollPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DiceRolls.
     * @param {DiceRollCreateManyArgs} args - Arguments to create many DiceRolls.
     * @example
     * // Create many DiceRolls
     * const diceRoll = await prisma.diceRoll.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiceRollCreateManyArgs>(args?: SelectSubset<T, DiceRollCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DiceRolls and returns the data saved in the database.
     * @param {DiceRollCreateManyAndReturnArgs} args - Arguments to create many DiceRolls.
     * @example
     * // Create many DiceRolls
     * const diceRoll = await prisma.diceRoll.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DiceRolls and only return the `id`
     * const diceRollWithIdOnly = await prisma.diceRoll.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiceRollCreateManyAndReturnArgs>(args?: SelectSubset<T, DiceRollCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiceRollPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DiceRoll.
     * @param {DiceRollDeleteArgs} args - Arguments to delete one DiceRoll.
     * @example
     * // Delete one DiceRoll
     * const DiceRoll = await prisma.diceRoll.delete({
     *   where: {
     *     // ... filter to delete one DiceRoll
     *   }
     * })
     * 
     */
    delete<T extends DiceRollDeleteArgs>(args: SelectSubset<T, DiceRollDeleteArgs<ExtArgs>>): Prisma__DiceRollClient<$Result.GetResult<Prisma.$DiceRollPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DiceRoll.
     * @param {DiceRollUpdateArgs} args - Arguments to update one DiceRoll.
     * @example
     * // Update one DiceRoll
     * const diceRoll = await prisma.diceRoll.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiceRollUpdateArgs>(args: SelectSubset<T, DiceRollUpdateArgs<ExtArgs>>): Prisma__DiceRollClient<$Result.GetResult<Prisma.$DiceRollPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DiceRolls.
     * @param {DiceRollDeleteManyArgs} args - Arguments to filter DiceRolls to delete.
     * @example
     * // Delete a few DiceRolls
     * const { count } = await prisma.diceRoll.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiceRollDeleteManyArgs>(args?: SelectSubset<T, DiceRollDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiceRolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiceRollUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiceRolls
     * const diceRoll = await prisma.diceRoll.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiceRollUpdateManyArgs>(args: SelectSubset<T, DiceRollUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DiceRoll.
     * @param {DiceRollUpsertArgs} args - Arguments to update or create a DiceRoll.
     * @example
     * // Update or create a DiceRoll
     * const diceRoll = await prisma.diceRoll.upsert({
     *   create: {
     *     // ... data to create a DiceRoll
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiceRoll we want to update
     *   }
     * })
     */
    upsert<T extends DiceRollUpsertArgs>(args: SelectSubset<T, DiceRollUpsertArgs<ExtArgs>>): Prisma__DiceRollClient<$Result.GetResult<Prisma.$DiceRollPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DiceRolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiceRollCountArgs} args - Arguments to filter DiceRolls to count.
     * @example
     * // Count the number of DiceRolls
     * const count = await prisma.diceRoll.count({
     *   where: {
     *     // ... the filter for the DiceRolls we want to count
     *   }
     * })
    **/
    count<T extends DiceRollCountArgs>(
      args?: Subset<T, DiceRollCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiceRollCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiceRoll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiceRollAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiceRollAggregateArgs>(args: Subset<T, DiceRollAggregateArgs>): Prisma.PrismaPromise<GetDiceRollAggregateType<T>>

    /**
     * Group by DiceRoll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiceRollGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiceRollGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiceRollGroupByArgs['orderBy'] }
        : { orderBy?: DiceRollGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiceRollGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiceRollGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DiceRoll model
   */
  readonly fields: DiceRollFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiceRoll.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiceRollClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roller<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DiceRoll model
   */ 
  interface DiceRollFieldRefs {
    readonly id: FieldRef<"DiceRoll", 'String'>
    readonly dice: FieldRef<"DiceRoll", 'String'>
    readonly result: FieldRef<"DiceRoll", 'Int'>
    readonly individual: FieldRef<"DiceRoll", 'Int[]'>
    readonly modifiers: FieldRef<"DiceRoll", 'String[]'>
    readonly description: FieldRef<"DiceRoll", 'String'>
    readonly isPublic: FieldRef<"DiceRoll", 'Boolean'>
    readonly isGMOnly: FieldRef<"DiceRoll", 'Boolean'>
    readonly rollerId: FieldRef<"DiceRoll", 'String'>
    readonly campaignId: FieldRef<"DiceRoll", 'String'>
    readonly character: FieldRef<"DiceRoll", 'String'>
    readonly skill: FieldRef<"DiceRoll", 'String'>
    readonly timestamp: FieldRef<"DiceRoll", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DiceRoll findUnique
   */
  export type DiceRollFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiceRoll
     */
    select?: DiceRollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiceRollInclude<ExtArgs> | null
    /**
     * Filter, which DiceRoll to fetch.
     */
    where: DiceRollWhereUniqueInput
  }

  /**
   * DiceRoll findUniqueOrThrow
   */
  export type DiceRollFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiceRoll
     */
    select?: DiceRollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiceRollInclude<ExtArgs> | null
    /**
     * Filter, which DiceRoll to fetch.
     */
    where: DiceRollWhereUniqueInput
  }

  /**
   * DiceRoll findFirst
   */
  export type DiceRollFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiceRoll
     */
    select?: DiceRollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiceRollInclude<ExtArgs> | null
    /**
     * Filter, which DiceRoll to fetch.
     */
    where?: DiceRollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiceRolls to fetch.
     */
    orderBy?: DiceRollOrderByWithRelationInput | DiceRollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiceRolls.
     */
    cursor?: DiceRollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiceRolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiceRolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiceRolls.
     */
    distinct?: DiceRollScalarFieldEnum | DiceRollScalarFieldEnum[]
  }

  /**
   * DiceRoll findFirstOrThrow
   */
  export type DiceRollFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiceRoll
     */
    select?: DiceRollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiceRollInclude<ExtArgs> | null
    /**
     * Filter, which DiceRoll to fetch.
     */
    where?: DiceRollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiceRolls to fetch.
     */
    orderBy?: DiceRollOrderByWithRelationInput | DiceRollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiceRolls.
     */
    cursor?: DiceRollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiceRolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiceRolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiceRolls.
     */
    distinct?: DiceRollScalarFieldEnum | DiceRollScalarFieldEnum[]
  }

  /**
   * DiceRoll findMany
   */
  export type DiceRollFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiceRoll
     */
    select?: DiceRollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiceRollInclude<ExtArgs> | null
    /**
     * Filter, which DiceRolls to fetch.
     */
    where?: DiceRollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiceRolls to fetch.
     */
    orderBy?: DiceRollOrderByWithRelationInput | DiceRollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiceRolls.
     */
    cursor?: DiceRollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiceRolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiceRolls.
     */
    skip?: number
    distinct?: DiceRollScalarFieldEnum | DiceRollScalarFieldEnum[]
  }

  /**
   * DiceRoll create
   */
  export type DiceRollCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiceRoll
     */
    select?: DiceRollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiceRollInclude<ExtArgs> | null
    /**
     * The data needed to create a DiceRoll.
     */
    data: XOR<DiceRollCreateInput, DiceRollUncheckedCreateInput>
  }

  /**
   * DiceRoll createMany
   */
  export type DiceRollCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DiceRolls.
     */
    data: DiceRollCreateManyInput | DiceRollCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DiceRoll createManyAndReturn
   */
  export type DiceRollCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiceRoll
     */
    select?: DiceRollSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DiceRolls.
     */
    data: DiceRollCreateManyInput | DiceRollCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiceRollIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DiceRoll update
   */
  export type DiceRollUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiceRoll
     */
    select?: DiceRollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiceRollInclude<ExtArgs> | null
    /**
     * The data needed to update a DiceRoll.
     */
    data: XOR<DiceRollUpdateInput, DiceRollUncheckedUpdateInput>
    /**
     * Choose, which DiceRoll to update.
     */
    where: DiceRollWhereUniqueInput
  }

  /**
   * DiceRoll updateMany
   */
  export type DiceRollUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DiceRolls.
     */
    data: XOR<DiceRollUpdateManyMutationInput, DiceRollUncheckedUpdateManyInput>
    /**
     * Filter which DiceRolls to update
     */
    where?: DiceRollWhereInput
  }

  /**
   * DiceRoll upsert
   */
  export type DiceRollUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiceRoll
     */
    select?: DiceRollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiceRollInclude<ExtArgs> | null
    /**
     * The filter to search for the DiceRoll to update in case it exists.
     */
    where: DiceRollWhereUniqueInput
    /**
     * In case the DiceRoll found by the `where` argument doesn't exist, create a new DiceRoll with this data.
     */
    create: XOR<DiceRollCreateInput, DiceRollUncheckedCreateInput>
    /**
     * In case the DiceRoll was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiceRollUpdateInput, DiceRollUncheckedUpdateInput>
  }

  /**
   * DiceRoll delete
   */
  export type DiceRollDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiceRoll
     */
    select?: DiceRollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiceRollInclude<ExtArgs> | null
    /**
     * Filter which DiceRoll to delete.
     */
    where: DiceRollWhereUniqueInput
  }

  /**
   * DiceRoll deleteMany
   */
  export type DiceRollDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiceRolls to delete
     */
    where?: DiceRollWhereInput
  }

  /**
   * DiceRoll without action
   */
  export type DiceRollDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiceRoll
     */
    select?: DiceRollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiceRollInclude<ExtArgs> | null
  }


  /**
   * Model CustomContent
   */

  export type AggregateCustomContent = {
    _count: CustomContentCountAggregateOutputType | null
    _min: CustomContentMinAggregateOutputType | null
    _max: CustomContentMaxAggregateOutputType | null
  }

  export type CustomContentMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    contentType: string | null
    category: string | null
    isPublic: boolean | null
    isOfficial: boolean | null
    authorId: string | null
    campaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomContentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    contentType: string | null
    category: string | null
    isPublic: boolean | null
    isOfficial: boolean | null
    authorId: string | null
    campaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomContentCountAggregateOutputType = {
    id: number
    title: number
    description: number
    contentType: number
    category: number
    data: number
    tags: number
    isPublic: number
    isOfficial: number
    authorId: number
    campaignId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomContentMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    contentType?: true
    category?: true
    isPublic?: true
    isOfficial?: true
    authorId?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomContentMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    contentType?: true
    category?: true
    isPublic?: true
    isOfficial?: true
    authorId?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomContentCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    contentType?: true
    category?: true
    data?: true
    tags?: true
    isPublic?: true
    isOfficial?: true
    authorId?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomContent to aggregate.
     */
    where?: CustomContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomContents to fetch.
     */
    orderBy?: CustomContentOrderByWithRelationInput | CustomContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomContents
    **/
    _count?: true | CustomContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomContentMaxAggregateInputType
  }

  export type GetCustomContentAggregateType<T extends CustomContentAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomContent[P]>
      : GetScalarType<T[P], AggregateCustomContent[P]>
  }




  export type CustomContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomContentWhereInput
    orderBy?: CustomContentOrderByWithAggregationInput | CustomContentOrderByWithAggregationInput[]
    by: CustomContentScalarFieldEnum[] | CustomContentScalarFieldEnum
    having?: CustomContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomContentCountAggregateInputType | true
    _min?: CustomContentMinAggregateInputType
    _max?: CustomContentMaxAggregateInputType
  }

  export type CustomContentGroupByOutputType = {
    id: string
    title: string
    description: string | null
    contentType: string
    category: string | null
    data: JsonValue
    tags: string[]
    isPublic: boolean
    isOfficial: boolean
    authorId: string
    campaignId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CustomContentCountAggregateOutputType | null
    _min: CustomContentMinAggregateOutputType | null
    _max: CustomContentMaxAggregateOutputType | null
  }

  type GetCustomContentGroupByPayload<T extends CustomContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomContentGroupByOutputType[P]>
            : GetScalarType<T[P], CustomContentGroupByOutputType[P]>
        }
      >
    >


  export type CustomContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    contentType?: boolean
    category?: boolean
    data?: boolean
    tags?: boolean
    isPublic?: boolean
    isOfficial?: boolean
    authorId?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CustomContent$campaignArgs<ExtArgs>
  }, ExtArgs["result"]["customContent"]>

  export type CustomContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    contentType?: boolean
    category?: boolean
    data?: boolean
    tags?: boolean
    isPublic?: boolean
    isOfficial?: boolean
    authorId?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CustomContent$campaignArgs<ExtArgs>
  }, ExtArgs["result"]["customContent"]>

  export type CustomContentSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    contentType?: boolean
    category?: boolean
    data?: boolean
    tags?: boolean
    isPublic?: boolean
    isOfficial?: boolean
    authorId?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CustomContent$campaignArgs<ExtArgs>
  }
  export type CustomContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CustomContent$campaignArgs<ExtArgs>
  }

  export type $CustomContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomContent"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      campaign: Prisma.$CampaignPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      contentType: string
      category: string | null
      data: Prisma.JsonValue
      tags: string[]
      isPublic: boolean
      isOfficial: boolean
      authorId: string
      campaignId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customContent"]>
    composites: {}
  }

  type CustomContentGetPayload<S extends boolean | null | undefined | CustomContentDefaultArgs> = $Result.GetResult<Prisma.$CustomContentPayload, S>

  type CustomContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomContentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomContentCountAggregateInputType | true
    }

  export interface CustomContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomContent'], meta: { name: 'CustomContent' } }
    /**
     * Find zero or one CustomContent that matches the filter.
     * @param {CustomContentFindUniqueArgs} args - Arguments to find a CustomContent
     * @example
     * // Get one CustomContent
     * const customContent = await prisma.customContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomContentFindUniqueArgs>(args: SelectSubset<T, CustomContentFindUniqueArgs<ExtArgs>>): Prisma__CustomContentClient<$Result.GetResult<Prisma.$CustomContentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomContent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomContentFindUniqueOrThrowArgs} args - Arguments to find a CustomContent
     * @example
     * // Get one CustomContent
     * const customContent = await prisma.customContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomContentFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomContentClient<$Result.GetResult<Prisma.$CustomContentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomContentFindFirstArgs} args - Arguments to find a CustomContent
     * @example
     * // Get one CustomContent
     * const customContent = await prisma.customContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomContentFindFirstArgs>(args?: SelectSubset<T, CustomContentFindFirstArgs<ExtArgs>>): Prisma__CustomContentClient<$Result.GetResult<Prisma.$CustomContentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomContentFindFirstOrThrowArgs} args - Arguments to find a CustomContent
     * @example
     * // Get one CustomContent
     * const customContent = await prisma.customContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomContentFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomContentClient<$Result.GetResult<Prisma.$CustomContentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomContents
     * const customContents = await prisma.customContent.findMany()
     * 
     * // Get first 10 CustomContents
     * const customContents = await prisma.customContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customContentWithIdOnly = await prisma.customContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomContentFindManyArgs>(args?: SelectSubset<T, CustomContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomContentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomContent.
     * @param {CustomContentCreateArgs} args - Arguments to create a CustomContent.
     * @example
     * // Create one CustomContent
     * const CustomContent = await prisma.customContent.create({
     *   data: {
     *     // ... data to create a CustomContent
     *   }
     * })
     * 
     */
    create<T extends CustomContentCreateArgs>(args: SelectSubset<T, CustomContentCreateArgs<ExtArgs>>): Prisma__CustomContentClient<$Result.GetResult<Prisma.$CustomContentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomContents.
     * @param {CustomContentCreateManyArgs} args - Arguments to create many CustomContents.
     * @example
     * // Create many CustomContents
     * const customContent = await prisma.customContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomContentCreateManyArgs>(args?: SelectSubset<T, CustomContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomContents and returns the data saved in the database.
     * @param {CustomContentCreateManyAndReturnArgs} args - Arguments to create many CustomContents.
     * @example
     * // Create many CustomContents
     * const customContent = await prisma.customContent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomContents and only return the `id`
     * const customContentWithIdOnly = await prisma.customContent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomContentCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomContentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomContent.
     * @param {CustomContentDeleteArgs} args - Arguments to delete one CustomContent.
     * @example
     * // Delete one CustomContent
     * const CustomContent = await prisma.customContent.delete({
     *   where: {
     *     // ... filter to delete one CustomContent
     *   }
     * })
     * 
     */
    delete<T extends CustomContentDeleteArgs>(args: SelectSubset<T, CustomContentDeleteArgs<ExtArgs>>): Prisma__CustomContentClient<$Result.GetResult<Prisma.$CustomContentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomContent.
     * @param {CustomContentUpdateArgs} args - Arguments to update one CustomContent.
     * @example
     * // Update one CustomContent
     * const customContent = await prisma.customContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomContentUpdateArgs>(args: SelectSubset<T, CustomContentUpdateArgs<ExtArgs>>): Prisma__CustomContentClient<$Result.GetResult<Prisma.$CustomContentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomContents.
     * @param {CustomContentDeleteManyArgs} args - Arguments to filter CustomContents to delete.
     * @example
     * // Delete a few CustomContents
     * const { count } = await prisma.customContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomContentDeleteManyArgs>(args?: SelectSubset<T, CustomContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomContents
     * const customContent = await prisma.customContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomContentUpdateManyArgs>(args: SelectSubset<T, CustomContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomContent.
     * @param {CustomContentUpsertArgs} args - Arguments to update or create a CustomContent.
     * @example
     * // Update or create a CustomContent
     * const customContent = await prisma.customContent.upsert({
     *   create: {
     *     // ... data to create a CustomContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomContent we want to update
     *   }
     * })
     */
    upsert<T extends CustomContentUpsertArgs>(args: SelectSubset<T, CustomContentUpsertArgs<ExtArgs>>): Prisma__CustomContentClient<$Result.GetResult<Prisma.$CustomContentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomContentCountArgs} args - Arguments to filter CustomContents to count.
     * @example
     * // Count the number of CustomContents
     * const count = await prisma.customContent.count({
     *   where: {
     *     // ... the filter for the CustomContents we want to count
     *   }
     * })
    **/
    count<T extends CustomContentCountArgs>(
      args?: Subset<T, CustomContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomContentAggregateArgs>(args: Subset<T, CustomContentAggregateArgs>): Prisma.PrismaPromise<GetCustomContentAggregateType<T>>

    /**
     * Group by CustomContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomContentGroupByArgs['orderBy'] }
        : { orderBy?: CustomContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomContent model
   */
  readonly fields: CustomContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    campaign<T extends CustomContent$campaignArgs<ExtArgs> = {}>(args?: Subset<T, CustomContent$campaignArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomContent model
   */ 
  interface CustomContentFieldRefs {
    readonly id: FieldRef<"CustomContent", 'String'>
    readonly title: FieldRef<"CustomContent", 'String'>
    readonly description: FieldRef<"CustomContent", 'String'>
    readonly contentType: FieldRef<"CustomContent", 'String'>
    readonly category: FieldRef<"CustomContent", 'String'>
    readonly data: FieldRef<"CustomContent", 'Json'>
    readonly tags: FieldRef<"CustomContent", 'String[]'>
    readonly isPublic: FieldRef<"CustomContent", 'Boolean'>
    readonly isOfficial: FieldRef<"CustomContent", 'Boolean'>
    readonly authorId: FieldRef<"CustomContent", 'String'>
    readonly campaignId: FieldRef<"CustomContent", 'String'>
    readonly createdAt: FieldRef<"CustomContent", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomContent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomContent findUnique
   */
  export type CustomContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomContent
     */
    select?: CustomContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomContentInclude<ExtArgs> | null
    /**
     * Filter, which CustomContent to fetch.
     */
    where: CustomContentWhereUniqueInput
  }

  /**
   * CustomContent findUniqueOrThrow
   */
  export type CustomContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomContent
     */
    select?: CustomContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomContentInclude<ExtArgs> | null
    /**
     * Filter, which CustomContent to fetch.
     */
    where: CustomContentWhereUniqueInput
  }

  /**
   * CustomContent findFirst
   */
  export type CustomContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomContent
     */
    select?: CustomContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomContentInclude<ExtArgs> | null
    /**
     * Filter, which CustomContent to fetch.
     */
    where?: CustomContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomContents to fetch.
     */
    orderBy?: CustomContentOrderByWithRelationInput | CustomContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomContents.
     */
    cursor?: CustomContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomContents.
     */
    distinct?: CustomContentScalarFieldEnum | CustomContentScalarFieldEnum[]
  }

  /**
   * CustomContent findFirstOrThrow
   */
  export type CustomContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomContent
     */
    select?: CustomContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomContentInclude<ExtArgs> | null
    /**
     * Filter, which CustomContent to fetch.
     */
    where?: CustomContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomContents to fetch.
     */
    orderBy?: CustomContentOrderByWithRelationInput | CustomContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomContents.
     */
    cursor?: CustomContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomContents.
     */
    distinct?: CustomContentScalarFieldEnum | CustomContentScalarFieldEnum[]
  }

  /**
   * CustomContent findMany
   */
  export type CustomContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomContent
     */
    select?: CustomContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomContentInclude<ExtArgs> | null
    /**
     * Filter, which CustomContents to fetch.
     */
    where?: CustomContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomContents to fetch.
     */
    orderBy?: CustomContentOrderByWithRelationInput | CustomContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomContents.
     */
    cursor?: CustomContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomContents.
     */
    skip?: number
    distinct?: CustomContentScalarFieldEnum | CustomContentScalarFieldEnum[]
  }

  /**
   * CustomContent create
   */
  export type CustomContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomContent
     */
    select?: CustomContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomContentInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomContent.
     */
    data: XOR<CustomContentCreateInput, CustomContentUncheckedCreateInput>
  }

  /**
   * CustomContent createMany
   */
  export type CustomContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomContents.
     */
    data: CustomContentCreateManyInput | CustomContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomContent createManyAndReturn
   */
  export type CustomContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomContent
     */
    select?: CustomContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomContents.
     */
    data: CustomContentCreateManyInput | CustomContentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomContentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomContent update
   */
  export type CustomContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomContent
     */
    select?: CustomContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomContentInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomContent.
     */
    data: XOR<CustomContentUpdateInput, CustomContentUncheckedUpdateInput>
    /**
     * Choose, which CustomContent to update.
     */
    where: CustomContentWhereUniqueInput
  }

  /**
   * CustomContent updateMany
   */
  export type CustomContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomContents.
     */
    data: XOR<CustomContentUpdateManyMutationInput, CustomContentUncheckedUpdateManyInput>
    /**
     * Filter which CustomContents to update
     */
    where?: CustomContentWhereInput
  }

  /**
   * CustomContent upsert
   */
  export type CustomContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomContent
     */
    select?: CustomContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomContentInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomContent to update in case it exists.
     */
    where: CustomContentWhereUniqueInput
    /**
     * In case the CustomContent found by the `where` argument doesn't exist, create a new CustomContent with this data.
     */
    create: XOR<CustomContentCreateInput, CustomContentUncheckedCreateInput>
    /**
     * In case the CustomContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomContentUpdateInput, CustomContentUncheckedUpdateInput>
  }

  /**
   * CustomContent delete
   */
  export type CustomContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomContent
     */
    select?: CustomContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomContentInclude<ExtArgs> | null
    /**
     * Filter which CustomContent to delete.
     */
    where: CustomContentWhereUniqueInput
  }

  /**
   * CustomContent deleteMany
   */
  export type CustomContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomContents to delete
     */
    where?: CustomContentWhereInput
  }

  /**
   * CustomContent.campaign
   */
  export type CustomContent$campaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
  }

  /**
   * CustomContent without action
   */
  export type CustomContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomContent
     */
    select?: CustomContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomContentInclude<ExtArgs> | null
  }


  /**
   * Model HouseRule
   */

  export type AggregateHouseRule = {
    _count: HouseRuleCountAggregateOutputType | null
    _min: HouseRuleMinAggregateOutputType | null
    _max: HouseRuleMaxAggregateOutputType | null
  }

  export type HouseRuleMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    ruleText: string | null
    pageReference: string | null
    replaces: string | null
    isActive: boolean | null
    campaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HouseRuleMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    ruleText: string | null
    pageReference: string | null
    replaces: string | null
    isActive: boolean | null
    campaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HouseRuleCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    ruleText: number
    pageReference: number
    replaces: number
    isActive: number
    campaignId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HouseRuleMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    ruleText?: true
    pageReference?: true
    replaces?: true
    isActive?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HouseRuleMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    ruleText?: true
    pageReference?: true
    replaces?: true
    isActive?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HouseRuleCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    ruleText?: true
    pageReference?: true
    replaces?: true
    isActive?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HouseRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HouseRule to aggregate.
     */
    where?: HouseRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HouseRules to fetch.
     */
    orderBy?: HouseRuleOrderByWithRelationInput | HouseRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HouseRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HouseRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HouseRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HouseRules
    **/
    _count?: true | HouseRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HouseRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HouseRuleMaxAggregateInputType
  }

  export type GetHouseRuleAggregateType<T extends HouseRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateHouseRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHouseRule[P]>
      : GetScalarType<T[P], AggregateHouseRule[P]>
  }




  export type HouseRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HouseRuleWhereInput
    orderBy?: HouseRuleOrderByWithAggregationInput | HouseRuleOrderByWithAggregationInput[]
    by: HouseRuleScalarFieldEnum[] | HouseRuleScalarFieldEnum
    having?: HouseRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HouseRuleCountAggregateInputType | true
    _min?: HouseRuleMinAggregateInputType
    _max?: HouseRuleMaxAggregateInputType
  }

  export type HouseRuleGroupByOutputType = {
    id: string
    title: string
    description: string
    category: string
    ruleText: string
    pageReference: string | null
    replaces: string | null
    isActive: boolean
    campaignId: string
    createdAt: Date
    updatedAt: Date
    _count: HouseRuleCountAggregateOutputType | null
    _min: HouseRuleMinAggregateOutputType | null
    _max: HouseRuleMaxAggregateOutputType | null
  }

  type GetHouseRuleGroupByPayload<T extends HouseRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HouseRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HouseRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HouseRuleGroupByOutputType[P]>
            : GetScalarType<T[P], HouseRuleGroupByOutputType[P]>
        }
      >
    >


  export type HouseRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    ruleText?: boolean
    pageReference?: boolean
    replaces?: boolean
    isActive?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["houseRule"]>

  export type HouseRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    ruleText?: boolean
    pageReference?: boolean
    replaces?: boolean
    isActive?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["houseRule"]>

  export type HouseRuleSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    ruleText?: boolean
    pageReference?: boolean
    replaces?: boolean
    isActive?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HouseRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type HouseRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $HouseRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HouseRule"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      category: string
      ruleText: string
      pageReference: string | null
      replaces: string | null
      isActive: boolean
      campaignId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["houseRule"]>
    composites: {}
  }

  type HouseRuleGetPayload<S extends boolean | null | undefined | HouseRuleDefaultArgs> = $Result.GetResult<Prisma.$HouseRulePayload, S>

  type HouseRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HouseRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HouseRuleCountAggregateInputType | true
    }

  export interface HouseRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HouseRule'], meta: { name: 'HouseRule' } }
    /**
     * Find zero or one HouseRule that matches the filter.
     * @param {HouseRuleFindUniqueArgs} args - Arguments to find a HouseRule
     * @example
     * // Get one HouseRule
     * const houseRule = await prisma.houseRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HouseRuleFindUniqueArgs>(args: SelectSubset<T, HouseRuleFindUniqueArgs<ExtArgs>>): Prisma__HouseRuleClient<$Result.GetResult<Prisma.$HouseRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HouseRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HouseRuleFindUniqueOrThrowArgs} args - Arguments to find a HouseRule
     * @example
     * // Get one HouseRule
     * const houseRule = await prisma.houseRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HouseRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, HouseRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HouseRuleClient<$Result.GetResult<Prisma.$HouseRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HouseRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseRuleFindFirstArgs} args - Arguments to find a HouseRule
     * @example
     * // Get one HouseRule
     * const houseRule = await prisma.houseRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HouseRuleFindFirstArgs>(args?: SelectSubset<T, HouseRuleFindFirstArgs<ExtArgs>>): Prisma__HouseRuleClient<$Result.GetResult<Prisma.$HouseRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HouseRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseRuleFindFirstOrThrowArgs} args - Arguments to find a HouseRule
     * @example
     * // Get one HouseRule
     * const houseRule = await prisma.houseRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HouseRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, HouseRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__HouseRuleClient<$Result.GetResult<Prisma.$HouseRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HouseRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HouseRules
     * const houseRules = await prisma.houseRule.findMany()
     * 
     * // Get first 10 HouseRules
     * const houseRules = await prisma.houseRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const houseRuleWithIdOnly = await prisma.houseRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HouseRuleFindManyArgs>(args?: SelectSubset<T, HouseRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HouseRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HouseRule.
     * @param {HouseRuleCreateArgs} args - Arguments to create a HouseRule.
     * @example
     * // Create one HouseRule
     * const HouseRule = await prisma.houseRule.create({
     *   data: {
     *     // ... data to create a HouseRule
     *   }
     * })
     * 
     */
    create<T extends HouseRuleCreateArgs>(args: SelectSubset<T, HouseRuleCreateArgs<ExtArgs>>): Prisma__HouseRuleClient<$Result.GetResult<Prisma.$HouseRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HouseRules.
     * @param {HouseRuleCreateManyArgs} args - Arguments to create many HouseRules.
     * @example
     * // Create many HouseRules
     * const houseRule = await prisma.houseRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HouseRuleCreateManyArgs>(args?: SelectSubset<T, HouseRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HouseRules and returns the data saved in the database.
     * @param {HouseRuleCreateManyAndReturnArgs} args - Arguments to create many HouseRules.
     * @example
     * // Create many HouseRules
     * const houseRule = await prisma.houseRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HouseRules and only return the `id`
     * const houseRuleWithIdOnly = await prisma.houseRule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HouseRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, HouseRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HouseRulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HouseRule.
     * @param {HouseRuleDeleteArgs} args - Arguments to delete one HouseRule.
     * @example
     * // Delete one HouseRule
     * const HouseRule = await prisma.houseRule.delete({
     *   where: {
     *     // ... filter to delete one HouseRule
     *   }
     * })
     * 
     */
    delete<T extends HouseRuleDeleteArgs>(args: SelectSubset<T, HouseRuleDeleteArgs<ExtArgs>>): Prisma__HouseRuleClient<$Result.GetResult<Prisma.$HouseRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HouseRule.
     * @param {HouseRuleUpdateArgs} args - Arguments to update one HouseRule.
     * @example
     * // Update one HouseRule
     * const houseRule = await prisma.houseRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HouseRuleUpdateArgs>(args: SelectSubset<T, HouseRuleUpdateArgs<ExtArgs>>): Prisma__HouseRuleClient<$Result.GetResult<Prisma.$HouseRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HouseRules.
     * @param {HouseRuleDeleteManyArgs} args - Arguments to filter HouseRules to delete.
     * @example
     * // Delete a few HouseRules
     * const { count } = await prisma.houseRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HouseRuleDeleteManyArgs>(args?: SelectSubset<T, HouseRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HouseRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HouseRules
     * const houseRule = await prisma.houseRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HouseRuleUpdateManyArgs>(args: SelectSubset<T, HouseRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HouseRule.
     * @param {HouseRuleUpsertArgs} args - Arguments to update or create a HouseRule.
     * @example
     * // Update or create a HouseRule
     * const houseRule = await prisma.houseRule.upsert({
     *   create: {
     *     // ... data to create a HouseRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HouseRule we want to update
     *   }
     * })
     */
    upsert<T extends HouseRuleUpsertArgs>(args: SelectSubset<T, HouseRuleUpsertArgs<ExtArgs>>): Prisma__HouseRuleClient<$Result.GetResult<Prisma.$HouseRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HouseRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseRuleCountArgs} args - Arguments to filter HouseRules to count.
     * @example
     * // Count the number of HouseRules
     * const count = await prisma.houseRule.count({
     *   where: {
     *     // ... the filter for the HouseRules we want to count
     *   }
     * })
    **/
    count<T extends HouseRuleCountArgs>(
      args?: Subset<T, HouseRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HouseRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HouseRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HouseRuleAggregateArgs>(args: Subset<T, HouseRuleAggregateArgs>): Prisma.PrismaPromise<GetHouseRuleAggregateType<T>>

    /**
     * Group by HouseRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HouseRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HouseRuleGroupByArgs['orderBy'] }
        : { orderBy?: HouseRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HouseRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHouseRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HouseRule model
   */
  readonly fields: HouseRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HouseRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HouseRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HouseRule model
   */ 
  interface HouseRuleFieldRefs {
    readonly id: FieldRef<"HouseRule", 'String'>
    readonly title: FieldRef<"HouseRule", 'String'>
    readonly description: FieldRef<"HouseRule", 'String'>
    readonly category: FieldRef<"HouseRule", 'String'>
    readonly ruleText: FieldRef<"HouseRule", 'String'>
    readonly pageReference: FieldRef<"HouseRule", 'String'>
    readonly replaces: FieldRef<"HouseRule", 'String'>
    readonly isActive: FieldRef<"HouseRule", 'Boolean'>
    readonly campaignId: FieldRef<"HouseRule", 'String'>
    readonly createdAt: FieldRef<"HouseRule", 'DateTime'>
    readonly updatedAt: FieldRef<"HouseRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HouseRule findUnique
   */
  export type HouseRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseRule
     */
    select?: HouseRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseRuleInclude<ExtArgs> | null
    /**
     * Filter, which HouseRule to fetch.
     */
    where: HouseRuleWhereUniqueInput
  }

  /**
   * HouseRule findUniqueOrThrow
   */
  export type HouseRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseRule
     */
    select?: HouseRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseRuleInclude<ExtArgs> | null
    /**
     * Filter, which HouseRule to fetch.
     */
    where: HouseRuleWhereUniqueInput
  }

  /**
   * HouseRule findFirst
   */
  export type HouseRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseRule
     */
    select?: HouseRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseRuleInclude<ExtArgs> | null
    /**
     * Filter, which HouseRule to fetch.
     */
    where?: HouseRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HouseRules to fetch.
     */
    orderBy?: HouseRuleOrderByWithRelationInput | HouseRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HouseRules.
     */
    cursor?: HouseRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HouseRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HouseRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HouseRules.
     */
    distinct?: HouseRuleScalarFieldEnum | HouseRuleScalarFieldEnum[]
  }

  /**
   * HouseRule findFirstOrThrow
   */
  export type HouseRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseRule
     */
    select?: HouseRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseRuleInclude<ExtArgs> | null
    /**
     * Filter, which HouseRule to fetch.
     */
    where?: HouseRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HouseRules to fetch.
     */
    orderBy?: HouseRuleOrderByWithRelationInput | HouseRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HouseRules.
     */
    cursor?: HouseRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HouseRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HouseRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HouseRules.
     */
    distinct?: HouseRuleScalarFieldEnum | HouseRuleScalarFieldEnum[]
  }

  /**
   * HouseRule findMany
   */
  export type HouseRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseRule
     */
    select?: HouseRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseRuleInclude<ExtArgs> | null
    /**
     * Filter, which HouseRules to fetch.
     */
    where?: HouseRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HouseRules to fetch.
     */
    orderBy?: HouseRuleOrderByWithRelationInput | HouseRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HouseRules.
     */
    cursor?: HouseRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HouseRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HouseRules.
     */
    skip?: number
    distinct?: HouseRuleScalarFieldEnum | HouseRuleScalarFieldEnum[]
  }

  /**
   * HouseRule create
   */
  export type HouseRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseRule
     */
    select?: HouseRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a HouseRule.
     */
    data: XOR<HouseRuleCreateInput, HouseRuleUncheckedCreateInput>
  }

  /**
   * HouseRule createMany
   */
  export type HouseRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HouseRules.
     */
    data: HouseRuleCreateManyInput | HouseRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HouseRule createManyAndReturn
   */
  export type HouseRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseRule
     */
    select?: HouseRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HouseRules.
     */
    data: HouseRuleCreateManyInput | HouseRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HouseRule update
   */
  export type HouseRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseRule
     */
    select?: HouseRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a HouseRule.
     */
    data: XOR<HouseRuleUpdateInput, HouseRuleUncheckedUpdateInput>
    /**
     * Choose, which HouseRule to update.
     */
    where: HouseRuleWhereUniqueInput
  }

  /**
   * HouseRule updateMany
   */
  export type HouseRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HouseRules.
     */
    data: XOR<HouseRuleUpdateManyMutationInput, HouseRuleUncheckedUpdateManyInput>
    /**
     * Filter which HouseRules to update
     */
    where?: HouseRuleWhereInput
  }

  /**
   * HouseRule upsert
   */
  export type HouseRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseRule
     */
    select?: HouseRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the HouseRule to update in case it exists.
     */
    where: HouseRuleWhereUniqueInput
    /**
     * In case the HouseRule found by the `where` argument doesn't exist, create a new HouseRule with this data.
     */
    create: XOR<HouseRuleCreateInput, HouseRuleUncheckedCreateInput>
    /**
     * In case the HouseRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HouseRuleUpdateInput, HouseRuleUncheckedUpdateInput>
  }

  /**
   * HouseRule delete
   */
  export type HouseRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseRule
     */
    select?: HouseRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseRuleInclude<ExtArgs> | null
    /**
     * Filter which HouseRule to delete.
     */
    where: HouseRuleWhereUniqueInput
  }

  /**
   * HouseRule deleteMany
   */
  export type HouseRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HouseRules to delete
     */
    where?: HouseRuleWhereInput
  }

  /**
   * HouseRule without action
   */
  export type HouseRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HouseRule
     */
    select?: HouseRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HouseRuleInclude<ExtArgs> | null
  }


  /**
   * Model Handout
   */

  export type AggregateHandout = {
    _count: HandoutCountAggregateOutputType | null
    _min: HandoutMinAggregateOutputType | null
    _max: HandoutMaxAggregateOutputType | null
  }

  export type HandoutMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    imageUrl: string | null
    fileUrl: string | null
    isPlayerVisible: boolean | null
    authorId: string | null
    campaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HandoutMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    imageUrl: string | null
    fileUrl: string | null
    isPlayerVisible: boolean | null
    authorId: string | null
    campaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HandoutCountAggregateOutputType = {
    id: number
    title: number
    description: number
    content: number
    imageUrl: number
    fileUrl: number
    isPlayerVisible: number
    recipients: number
    authorId: number
    campaignId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HandoutMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    imageUrl?: true
    fileUrl?: true
    isPlayerVisible?: true
    authorId?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HandoutMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    imageUrl?: true
    fileUrl?: true
    isPlayerVisible?: true
    authorId?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HandoutCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    imageUrl?: true
    fileUrl?: true
    isPlayerVisible?: true
    recipients?: true
    authorId?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HandoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Handout to aggregate.
     */
    where?: HandoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Handouts to fetch.
     */
    orderBy?: HandoutOrderByWithRelationInput | HandoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HandoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Handouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Handouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Handouts
    **/
    _count?: true | HandoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HandoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HandoutMaxAggregateInputType
  }

  export type GetHandoutAggregateType<T extends HandoutAggregateArgs> = {
        [P in keyof T & keyof AggregateHandout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHandout[P]>
      : GetScalarType<T[P], AggregateHandout[P]>
  }




  export type HandoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HandoutWhereInput
    orderBy?: HandoutOrderByWithAggregationInput | HandoutOrderByWithAggregationInput[]
    by: HandoutScalarFieldEnum[] | HandoutScalarFieldEnum
    having?: HandoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HandoutCountAggregateInputType | true
    _min?: HandoutMinAggregateInputType
    _max?: HandoutMaxAggregateInputType
  }

  export type HandoutGroupByOutputType = {
    id: string
    title: string
    description: string | null
    content: string | null
    imageUrl: string | null
    fileUrl: string | null
    isPlayerVisible: boolean
    recipients: string[]
    authorId: string
    campaignId: string
    createdAt: Date
    updatedAt: Date
    _count: HandoutCountAggregateOutputType | null
    _min: HandoutMinAggregateOutputType | null
    _max: HandoutMaxAggregateOutputType | null
  }

  type GetHandoutGroupByPayload<T extends HandoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HandoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HandoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HandoutGroupByOutputType[P]>
            : GetScalarType<T[P], HandoutGroupByOutputType[P]>
        }
      >
    >


  export type HandoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    imageUrl?: boolean
    fileUrl?: boolean
    isPlayerVisible?: boolean
    recipients?: boolean
    authorId?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["handout"]>

  export type HandoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    imageUrl?: boolean
    fileUrl?: boolean
    isPlayerVisible?: boolean
    recipients?: boolean
    authorId?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["handout"]>

  export type HandoutSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    imageUrl?: boolean
    fileUrl?: boolean
    isPlayerVisible?: boolean
    recipients?: boolean
    authorId?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HandoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type HandoutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $HandoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Handout"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      content: string | null
      imageUrl: string | null
      fileUrl: string | null
      isPlayerVisible: boolean
      recipients: string[]
      authorId: string
      campaignId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["handout"]>
    composites: {}
  }

  type HandoutGetPayload<S extends boolean | null | undefined | HandoutDefaultArgs> = $Result.GetResult<Prisma.$HandoutPayload, S>

  type HandoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HandoutFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HandoutCountAggregateInputType | true
    }

  export interface HandoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Handout'], meta: { name: 'Handout' } }
    /**
     * Find zero or one Handout that matches the filter.
     * @param {HandoutFindUniqueArgs} args - Arguments to find a Handout
     * @example
     * // Get one Handout
     * const handout = await prisma.handout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HandoutFindUniqueArgs>(args: SelectSubset<T, HandoutFindUniqueArgs<ExtArgs>>): Prisma__HandoutClient<$Result.GetResult<Prisma.$HandoutPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Handout that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HandoutFindUniqueOrThrowArgs} args - Arguments to find a Handout
     * @example
     * // Get one Handout
     * const handout = await prisma.handout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HandoutFindUniqueOrThrowArgs>(args: SelectSubset<T, HandoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HandoutClient<$Result.GetResult<Prisma.$HandoutPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Handout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandoutFindFirstArgs} args - Arguments to find a Handout
     * @example
     * // Get one Handout
     * const handout = await prisma.handout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HandoutFindFirstArgs>(args?: SelectSubset<T, HandoutFindFirstArgs<ExtArgs>>): Prisma__HandoutClient<$Result.GetResult<Prisma.$HandoutPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Handout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandoutFindFirstOrThrowArgs} args - Arguments to find a Handout
     * @example
     * // Get one Handout
     * const handout = await prisma.handout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HandoutFindFirstOrThrowArgs>(args?: SelectSubset<T, HandoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__HandoutClient<$Result.GetResult<Prisma.$HandoutPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Handouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Handouts
     * const handouts = await prisma.handout.findMany()
     * 
     * // Get first 10 Handouts
     * const handouts = await prisma.handout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const handoutWithIdOnly = await prisma.handout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HandoutFindManyArgs>(args?: SelectSubset<T, HandoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HandoutPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Handout.
     * @param {HandoutCreateArgs} args - Arguments to create a Handout.
     * @example
     * // Create one Handout
     * const Handout = await prisma.handout.create({
     *   data: {
     *     // ... data to create a Handout
     *   }
     * })
     * 
     */
    create<T extends HandoutCreateArgs>(args: SelectSubset<T, HandoutCreateArgs<ExtArgs>>): Prisma__HandoutClient<$Result.GetResult<Prisma.$HandoutPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Handouts.
     * @param {HandoutCreateManyArgs} args - Arguments to create many Handouts.
     * @example
     * // Create many Handouts
     * const handout = await prisma.handout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HandoutCreateManyArgs>(args?: SelectSubset<T, HandoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Handouts and returns the data saved in the database.
     * @param {HandoutCreateManyAndReturnArgs} args - Arguments to create many Handouts.
     * @example
     * // Create many Handouts
     * const handout = await prisma.handout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Handouts and only return the `id`
     * const handoutWithIdOnly = await prisma.handout.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HandoutCreateManyAndReturnArgs>(args?: SelectSubset<T, HandoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HandoutPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Handout.
     * @param {HandoutDeleteArgs} args - Arguments to delete one Handout.
     * @example
     * // Delete one Handout
     * const Handout = await prisma.handout.delete({
     *   where: {
     *     // ... filter to delete one Handout
     *   }
     * })
     * 
     */
    delete<T extends HandoutDeleteArgs>(args: SelectSubset<T, HandoutDeleteArgs<ExtArgs>>): Prisma__HandoutClient<$Result.GetResult<Prisma.$HandoutPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Handout.
     * @param {HandoutUpdateArgs} args - Arguments to update one Handout.
     * @example
     * // Update one Handout
     * const handout = await prisma.handout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HandoutUpdateArgs>(args: SelectSubset<T, HandoutUpdateArgs<ExtArgs>>): Prisma__HandoutClient<$Result.GetResult<Prisma.$HandoutPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Handouts.
     * @param {HandoutDeleteManyArgs} args - Arguments to filter Handouts to delete.
     * @example
     * // Delete a few Handouts
     * const { count } = await prisma.handout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HandoutDeleteManyArgs>(args?: SelectSubset<T, HandoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Handouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Handouts
     * const handout = await prisma.handout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HandoutUpdateManyArgs>(args: SelectSubset<T, HandoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Handout.
     * @param {HandoutUpsertArgs} args - Arguments to update or create a Handout.
     * @example
     * // Update or create a Handout
     * const handout = await prisma.handout.upsert({
     *   create: {
     *     // ... data to create a Handout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Handout we want to update
     *   }
     * })
     */
    upsert<T extends HandoutUpsertArgs>(args: SelectSubset<T, HandoutUpsertArgs<ExtArgs>>): Prisma__HandoutClient<$Result.GetResult<Prisma.$HandoutPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Handouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandoutCountArgs} args - Arguments to filter Handouts to count.
     * @example
     * // Count the number of Handouts
     * const count = await prisma.handout.count({
     *   where: {
     *     // ... the filter for the Handouts we want to count
     *   }
     * })
    **/
    count<T extends HandoutCountArgs>(
      args?: Subset<T, HandoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HandoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Handout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HandoutAggregateArgs>(args: Subset<T, HandoutAggregateArgs>): Prisma.PrismaPromise<GetHandoutAggregateType<T>>

    /**
     * Group by Handout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HandoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HandoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HandoutGroupByArgs['orderBy'] }
        : { orderBy?: HandoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HandoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHandoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Handout model
   */
  readonly fields: HandoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Handout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HandoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Handout model
   */ 
  interface HandoutFieldRefs {
    readonly id: FieldRef<"Handout", 'String'>
    readonly title: FieldRef<"Handout", 'String'>
    readonly description: FieldRef<"Handout", 'String'>
    readonly content: FieldRef<"Handout", 'String'>
    readonly imageUrl: FieldRef<"Handout", 'String'>
    readonly fileUrl: FieldRef<"Handout", 'String'>
    readonly isPlayerVisible: FieldRef<"Handout", 'Boolean'>
    readonly recipients: FieldRef<"Handout", 'String[]'>
    readonly authorId: FieldRef<"Handout", 'String'>
    readonly campaignId: FieldRef<"Handout", 'String'>
    readonly createdAt: FieldRef<"Handout", 'DateTime'>
    readonly updatedAt: FieldRef<"Handout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Handout findUnique
   */
  export type HandoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Handout
     */
    select?: HandoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoutInclude<ExtArgs> | null
    /**
     * Filter, which Handout to fetch.
     */
    where: HandoutWhereUniqueInput
  }

  /**
   * Handout findUniqueOrThrow
   */
  export type HandoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Handout
     */
    select?: HandoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoutInclude<ExtArgs> | null
    /**
     * Filter, which Handout to fetch.
     */
    where: HandoutWhereUniqueInput
  }

  /**
   * Handout findFirst
   */
  export type HandoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Handout
     */
    select?: HandoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoutInclude<ExtArgs> | null
    /**
     * Filter, which Handout to fetch.
     */
    where?: HandoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Handouts to fetch.
     */
    orderBy?: HandoutOrderByWithRelationInput | HandoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Handouts.
     */
    cursor?: HandoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Handouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Handouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Handouts.
     */
    distinct?: HandoutScalarFieldEnum | HandoutScalarFieldEnum[]
  }

  /**
   * Handout findFirstOrThrow
   */
  export type HandoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Handout
     */
    select?: HandoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoutInclude<ExtArgs> | null
    /**
     * Filter, which Handout to fetch.
     */
    where?: HandoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Handouts to fetch.
     */
    orderBy?: HandoutOrderByWithRelationInput | HandoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Handouts.
     */
    cursor?: HandoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Handouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Handouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Handouts.
     */
    distinct?: HandoutScalarFieldEnum | HandoutScalarFieldEnum[]
  }

  /**
   * Handout findMany
   */
  export type HandoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Handout
     */
    select?: HandoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoutInclude<ExtArgs> | null
    /**
     * Filter, which Handouts to fetch.
     */
    where?: HandoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Handouts to fetch.
     */
    orderBy?: HandoutOrderByWithRelationInput | HandoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Handouts.
     */
    cursor?: HandoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Handouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Handouts.
     */
    skip?: number
    distinct?: HandoutScalarFieldEnum | HandoutScalarFieldEnum[]
  }

  /**
   * Handout create
   */
  export type HandoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Handout
     */
    select?: HandoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoutInclude<ExtArgs> | null
    /**
     * The data needed to create a Handout.
     */
    data: XOR<HandoutCreateInput, HandoutUncheckedCreateInput>
  }

  /**
   * Handout createMany
   */
  export type HandoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Handouts.
     */
    data: HandoutCreateManyInput | HandoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Handout createManyAndReturn
   */
  export type HandoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Handout
     */
    select?: HandoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Handouts.
     */
    data: HandoutCreateManyInput | HandoutCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Handout update
   */
  export type HandoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Handout
     */
    select?: HandoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoutInclude<ExtArgs> | null
    /**
     * The data needed to update a Handout.
     */
    data: XOR<HandoutUpdateInput, HandoutUncheckedUpdateInput>
    /**
     * Choose, which Handout to update.
     */
    where: HandoutWhereUniqueInput
  }

  /**
   * Handout updateMany
   */
  export type HandoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Handouts.
     */
    data: XOR<HandoutUpdateManyMutationInput, HandoutUncheckedUpdateManyInput>
    /**
     * Filter which Handouts to update
     */
    where?: HandoutWhereInput
  }

  /**
   * Handout upsert
   */
  export type HandoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Handout
     */
    select?: HandoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoutInclude<ExtArgs> | null
    /**
     * The filter to search for the Handout to update in case it exists.
     */
    where: HandoutWhereUniqueInput
    /**
     * In case the Handout found by the `where` argument doesn't exist, create a new Handout with this data.
     */
    create: XOR<HandoutCreateInput, HandoutUncheckedCreateInput>
    /**
     * In case the Handout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HandoutUpdateInput, HandoutUncheckedUpdateInput>
  }

  /**
   * Handout delete
   */
  export type HandoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Handout
     */
    select?: HandoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoutInclude<ExtArgs> | null
    /**
     * Filter which Handout to delete.
     */
    where: HandoutWhereUniqueInput
  }

  /**
   * Handout deleteMany
   */
  export type HandoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Handouts to delete
     */
    where?: HandoutWhereInput
  }

  /**
   * Handout without action
   */
  export type HandoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Handout
     */
    select?: HandoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HandoutInclude<ExtArgs> | null
  }


  /**
   * Model SessionNote
   */

  export type AggregateSessionNote = {
    _count: SessionNoteCountAggregateOutputType | null
    _min: SessionNoteMinAggregateOutputType | null
    _max: SessionNoteMaxAggregateOutputType | null
  }

  export type SessionNoteMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    noteType: string | null
    isPublic: boolean | null
    authorId: string | null
    campaignId: string | null
    sessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionNoteMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    noteType: string | null
    isPublic: boolean | null
    authorId: string | null
    campaignId: string | null
    sessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionNoteCountAggregateOutputType = {
    id: number
    title: number
    content: number
    noteType: number
    tags: number
    isPublic: number
    authorId: number
    campaignId: number
    sessionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionNoteMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    noteType?: true
    isPublic?: true
    authorId?: true
    campaignId?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionNoteMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    noteType?: true
    isPublic?: true
    authorId?: true
    campaignId?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionNoteCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    noteType?: true
    tags?: true
    isPublic?: true
    authorId?: true
    campaignId?: true
    sessionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionNote to aggregate.
     */
    where?: SessionNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionNotes to fetch.
     */
    orderBy?: SessionNoteOrderByWithRelationInput | SessionNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionNotes
    **/
    _count?: true | SessionNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionNoteMaxAggregateInputType
  }

  export type GetSessionNoteAggregateType<T extends SessionNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionNote[P]>
      : GetScalarType<T[P], AggregateSessionNote[P]>
  }




  export type SessionNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionNoteWhereInput
    orderBy?: SessionNoteOrderByWithAggregationInput | SessionNoteOrderByWithAggregationInput[]
    by: SessionNoteScalarFieldEnum[] | SessionNoteScalarFieldEnum
    having?: SessionNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionNoteCountAggregateInputType | true
    _min?: SessionNoteMinAggregateInputType
    _max?: SessionNoteMaxAggregateInputType
  }

  export type SessionNoteGroupByOutputType = {
    id: string
    title: string | null
    content: string
    noteType: string
    tags: string[]
    isPublic: boolean
    authorId: string
    campaignId: string
    sessionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SessionNoteCountAggregateOutputType | null
    _min: SessionNoteMinAggregateOutputType | null
    _max: SessionNoteMaxAggregateOutputType | null
  }

  type GetSessionNoteGroupByPayload<T extends SessionNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionNoteGroupByOutputType[P]>
            : GetScalarType<T[P], SessionNoteGroupByOutputType[P]>
        }
      >
    >


  export type SessionNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    noteType?: boolean
    tags?: boolean
    isPublic?: boolean
    authorId?: boolean
    campaignId?: boolean
    sessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    session?: boolean | SessionNote$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["sessionNote"]>

  export type SessionNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    noteType?: boolean
    tags?: boolean
    isPublic?: boolean
    authorId?: boolean
    campaignId?: boolean
    sessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    session?: boolean | SessionNote$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["sessionNote"]>

  export type SessionNoteSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    noteType?: boolean
    tags?: boolean
    isPublic?: boolean
    authorId?: boolean
    campaignId?: boolean
    sessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    session?: boolean | SessionNote$sessionArgs<ExtArgs>
  }
  export type SessionNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    session?: boolean | SessionNote$sessionArgs<ExtArgs>
  }

  export type $SessionNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionNote"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      campaign: Prisma.$CampaignPayload<ExtArgs>
      session: Prisma.$SessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      content: string
      noteType: string
      tags: string[]
      isPublic: boolean
      authorId: string
      campaignId: string
      sessionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sessionNote"]>
    composites: {}
  }

  type SessionNoteGetPayload<S extends boolean | null | undefined | SessionNoteDefaultArgs> = $Result.GetResult<Prisma.$SessionNotePayload, S>

  type SessionNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionNoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionNoteCountAggregateInputType | true
    }

  export interface SessionNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionNote'], meta: { name: 'SessionNote' } }
    /**
     * Find zero or one SessionNote that matches the filter.
     * @param {SessionNoteFindUniqueArgs} args - Arguments to find a SessionNote
     * @example
     * // Get one SessionNote
     * const sessionNote = await prisma.sessionNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionNoteFindUniqueArgs>(args: SelectSubset<T, SessionNoteFindUniqueArgs<ExtArgs>>): Prisma__SessionNoteClient<$Result.GetResult<Prisma.$SessionNotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SessionNote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionNoteFindUniqueOrThrowArgs} args - Arguments to find a SessionNote
     * @example
     * // Get one SessionNote
     * const sessionNote = await prisma.sessionNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionNoteClient<$Result.GetResult<Prisma.$SessionNotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SessionNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionNoteFindFirstArgs} args - Arguments to find a SessionNote
     * @example
     * // Get one SessionNote
     * const sessionNote = await prisma.sessionNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionNoteFindFirstArgs>(args?: SelectSubset<T, SessionNoteFindFirstArgs<ExtArgs>>): Prisma__SessionNoteClient<$Result.GetResult<Prisma.$SessionNotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SessionNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionNoteFindFirstOrThrowArgs} args - Arguments to find a SessionNote
     * @example
     * // Get one SessionNote
     * const sessionNote = await prisma.sessionNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionNoteClient<$Result.GetResult<Prisma.$SessionNotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SessionNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionNotes
     * const sessionNotes = await prisma.sessionNote.findMany()
     * 
     * // Get first 10 SessionNotes
     * const sessionNotes = await prisma.sessionNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionNoteWithIdOnly = await prisma.sessionNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionNoteFindManyArgs>(args?: SelectSubset<T, SessionNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionNotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SessionNote.
     * @param {SessionNoteCreateArgs} args - Arguments to create a SessionNote.
     * @example
     * // Create one SessionNote
     * const SessionNote = await prisma.sessionNote.create({
     *   data: {
     *     // ... data to create a SessionNote
     *   }
     * })
     * 
     */
    create<T extends SessionNoteCreateArgs>(args: SelectSubset<T, SessionNoteCreateArgs<ExtArgs>>): Prisma__SessionNoteClient<$Result.GetResult<Prisma.$SessionNotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SessionNotes.
     * @param {SessionNoteCreateManyArgs} args - Arguments to create many SessionNotes.
     * @example
     * // Create many SessionNotes
     * const sessionNote = await prisma.sessionNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionNoteCreateManyArgs>(args?: SelectSubset<T, SessionNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionNotes and returns the data saved in the database.
     * @param {SessionNoteCreateManyAndReturnArgs} args - Arguments to create many SessionNotes.
     * @example
     * // Create many SessionNotes
     * const sessionNote = await prisma.sessionNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionNotes and only return the `id`
     * const sessionNoteWithIdOnly = await prisma.sessionNote.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionNotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SessionNote.
     * @param {SessionNoteDeleteArgs} args - Arguments to delete one SessionNote.
     * @example
     * // Delete one SessionNote
     * const SessionNote = await prisma.sessionNote.delete({
     *   where: {
     *     // ... filter to delete one SessionNote
     *   }
     * })
     * 
     */
    delete<T extends SessionNoteDeleteArgs>(args: SelectSubset<T, SessionNoteDeleteArgs<ExtArgs>>): Prisma__SessionNoteClient<$Result.GetResult<Prisma.$SessionNotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SessionNote.
     * @param {SessionNoteUpdateArgs} args - Arguments to update one SessionNote.
     * @example
     * // Update one SessionNote
     * const sessionNote = await prisma.sessionNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionNoteUpdateArgs>(args: SelectSubset<T, SessionNoteUpdateArgs<ExtArgs>>): Prisma__SessionNoteClient<$Result.GetResult<Prisma.$SessionNotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SessionNotes.
     * @param {SessionNoteDeleteManyArgs} args - Arguments to filter SessionNotes to delete.
     * @example
     * // Delete a few SessionNotes
     * const { count } = await prisma.sessionNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionNoteDeleteManyArgs>(args?: SelectSubset<T, SessionNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionNotes
     * const sessionNote = await prisma.sessionNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionNoteUpdateManyArgs>(args: SelectSubset<T, SessionNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SessionNote.
     * @param {SessionNoteUpsertArgs} args - Arguments to update or create a SessionNote.
     * @example
     * // Update or create a SessionNote
     * const sessionNote = await prisma.sessionNote.upsert({
     *   create: {
     *     // ... data to create a SessionNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionNote we want to update
     *   }
     * })
     */
    upsert<T extends SessionNoteUpsertArgs>(args: SelectSubset<T, SessionNoteUpsertArgs<ExtArgs>>): Prisma__SessionNoteClient<$Result.GetResult<Prisma.$SessionNotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SessionNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionNoteCountArgs} args - Arguments to filter SessionNotes to count.
     * @example
     * // Count the number of SessionNotes
     * const count = await prisma.sessionNote.count({
     *   where: {
     *     // ... the filter for the SessionNotes we want to count
     *   }
     * })
    **/
    count<T extends SessionNoteCountArgs>(
      args?: Subset<T, SessionNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionNoteAggregateArgs>(args: Subset<T, SessionNoteAggregateArgs>): Prisma.PrismaPromise<GetSessionNoteAggregateType<T>>

    /**
     * Group by SessionNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionNoteGroupByArgs['orderBy'] }
        : { orderBy?: SessionNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionNote model
   */
  readonly fields: SessionNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    session<T extends SessionNote$sessionArgs<ExtArgs> = {}>(args?: Subset<T, SessionNote$sessionArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionNote model
   */ 
  interface SessionNoteFieldRefs {
    readonly id: FieldRef<"SessionNote", 'String'>
    readonly title: FieldRef<"SessionNote", 'String'>
    readonly content: FieldRef<"SessionNote", 'String'>
    readonly noteType: FieldRef<"SessionNote", 'String'>
    readonly tags: FieldRef<"SessionNote", 'String[]'>
    readonly isPublic: FieldRef<"SessionNote", 'Boolean'>
    readonly authorId: FieldRef<"SessionNote", 'String'>
    readonly campaignId: FieldRef<"SessionNote", 'String'>
    readonly sessionId: FieldRef<"SessionNote", 'String'>
    readonly createdAt: FieldRef<"SessionNote", 'DateTime'>
    readonly updatedAt: FieldRef<"SessionNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessionNote findUnique
   */
  export type SessionNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionNote
     */
    select?: SessionNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionNoteInclude<ExtArgs> | null
    /**
     * Filter, which SessionNote to fetch.
     */
    where: SessionNoteWhereUniqueInput
  }

  /**
   * SessionNote findUniqueOrThrow
   */
  export type SessionNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionNote
     */
    select?: SessionNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionNoteInclude<ExtArgs> | null
    /**
     * Filter, which SessionNote to fetch.
     */
    where: SessionNoteWhereUniqueInput
  }

  /**
   * SessionNote findFirst
   */
  export type SessionNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionNote
     */
    select?: SessionNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionNoteInclude<ExtArgs> | null
    /**
     * Filter, which SessionNote to fetch.
     */
    where?: SessionNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionNotes to fetch.
     */
    orderBy?: SessionNoteOrderByWithRelationInput | SessionNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionNotes.
     */
    cursor?: SessionNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionNotes.
     */
    distinct?: SessionNoteScalarFieldEnum | SessionNoteScalarFieldEnum[]
  }

  /**
   * SessionNote findFirstOrThrow
   */
  export type SessionNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionNote
     */
    select?: SessionNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionNoteInclude<ExtArgs> | null
    /**
     * Filter, which SessionNote to fetch.
     */
    where?: SessionNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionNotes to fetch.
     */
    orderBy?: SessionNoteOrderByWithRelationInput | SessionNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionNotes.
     */
    cursor?: SessionNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionNotes.
     */
    distinct?: SessionNoteScalarFieldEnum | SessionNoteScalarFieldEnum[]
  }

  /**
   * SessionNote findMany
   */
  export type SessionNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionNote
     */
    select?: SessionNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionNoteInclude<ExtArgs> | null
    /**
     * Filter, which SessionNotes to fetch.
     */
    where?: SessionNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionNotes to fetch.
     */
    orderBy?: SessionNoteOrderByWithRelationInput | SessionNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionNotes.
     */
    cursor?: SessionNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionNotes.
     */
    skip?: number
    distinct?: SessionNoteScalarFieldEnum | SessionNoteScalarFieldEnum[]
  }

  /**
   * SessionNote create
   */
  export type SessionNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionNote
     */
    select?: SessionNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionNote.
     */
    data: XOR<SessionNoteCreateInput, SessionNoteUncheckedCreateInput>
  }

  /**
   * SessionNote createMany
   */
  export type SessionNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionNotes.
     */
    data: SessionNoteCreateManyInput | SessionNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionNote createManyAndReturn
   */
  export type SessionNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionNote
     */
    select?: SessionNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SessionNotes.
     */
    data: SessionNoteCreateManyInput | SessionNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionNote update
   */
  export type SessionNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionNote
     */
    select?: SessionNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionNote.
     */
    data: XOR<SessionNoteUpdateInput, SessionNoteUncheckedUpdateInput>
    /**
     * Choose, which SessionNote to update.
     */
    where: SessionNoteWhereUniqueInput
  }

  /**
   * SessionNote updateMany
   */
  export type SessionNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionNotes.
     */
    data: XOR<SessionNoteUpdateManyMutationInput, SessionNoteUncheckedUpdateManyInput>
    /**
     * Filter which SessionNotes to update
     */
    where?: SessionNoteWhereInput
  }

  /**
   * SessionNote upsert
   */
  export type SessionNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionNote
     */
    select?: SessionNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionNote to update in case it exists.
     */
    where: SessionNoteWhereUniqueInput
    /**
     * In case the SessionNote found by the `where` argument doesn't exist, create a new SessionNote with this data.
     */
    create: XOR<SessionNoteCreateInput, SessionNoteUncheckedCreateInput>
    /**
     * In case the SessionNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionNoteUpdateInput, SessionNoteUncheckedUpdateInput>
  }

  /**
   * SessionNote delete
   */
  export type SessionNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionNote
     */
    select?: SessionNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionNoteInclude<ExtArgs> | null
    /**
     * Filter which SessionNote to delete.
     */
    where: SessionNoteWhereUniqueInput
  }

  /**
   * SessionNote deleteMany
   */
  export type SessionNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionNotes to delete
     */
    where?: SessionNoteWhereInput
  }

  /**
   * SessionNote.session
   */
  export type SessionNote$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
  }

  /**
   * SessionNote without action
   */
  export type SessionNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionNote
     */
    select?: SessionNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionNoteInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    displayName: 'displayName',
    avatar: 'avatar',
    timezone: 'timezone',
    subscriptionTier: 'subscriptionTier',
    cognitoUserId: 'cognitoUserId',
    emailVerified: 'emailVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    maxPlayers: 'maxPlayers',
    isPublic: 'isPublic',
    allowedBooks: 'allowedBooks',
    houseRules: 'houseRules',
    gamemasterId: 'gamemasterId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const CampaignMemberScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    userId: 'userId',
    role: 'role',
    isActive: 'isActive',
    joinedAt: 'joinedAt'
  };

  export type CampaignMemberScalarFieldEnum = (typeof CampaignMemberScalarFieldEnum)[keyof typeof CampaignMemberScalarFieldEnum]


  export const CharacterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    credits: 'credits',
    notes: 'notes',
    portrait: 'portrait',
    homeworld: 'homeworld',
    age: 'age',
    gender: 'gender',
    species: 'species',
    playerId: 'playerId',
    campaignId: 'campaignId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CharacterScalarFieldEnum = (typeof CharacterScalarFieldEnum)[keyof typeof CharacterScalarFieldEnum]


  export const CharacteristicsScalarFieldEnum: {
    id: 'id',
    strength: 'strength',
    dexterity: 'dexterity',
    endurance: 'endurance',
    intelligence: 'intelligence',
    education: 'education',
    socialStanding: 'socialStanding',
    physicalDamage: 'physicalDamage',
    mentalDamage: 'mentalDamage',
    characterId: 'characterId'
  };

  export type CharacteristicsScalarFieldEnum = (typeof CharacteristicsScalarFieldEnum)[keyof typeof CharacteristicsScalarFieldEnum]


  export const CharacterSkillScalarFieldEnum: {
    id: 'id',
    name: 'name',
    level: 'level',
    specialization: 'specialization',
    characterId: 'characterId'
  };

  export type CharacterSkillScalarFieldEnum = (typeof CharacterSkillScalarFieldEnum)[keyof typeof CharacterSkillScalarFieldEnum]


  export const CharacterEquipmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    weight: 'weight',
    cost: 'cost',
    quantity: 'quantity',
    equipped: 'equipped',
    category: 'category',
    subcategory: 'subcategory',
    weaponType: 'weaponType',
    damage: 'damage',
    range: 'range',
    armorValue: 'armorValue',
    armorType: 'armorType',
    characterId: 'characterId'
  };

  export type CharacterEquipmentScalarFieldEnum = (typeof CharacterEquipmentScalarFieldEnum)[keyof typeof CharacterEquipmentScalarFieldEnum]


  export const LifeEventScalarFieldEnum: {
    id: 'id',
    age: 'age',
    event: 'event',
    description: 'description',
    effects: 'effects',
    career: 'career',
    rank: 'rank',
    skills: 'skills',
    characterId: 'characterId'
  };

  export type LifeEventScalarFieldEnum = (typeof LifeEventScalarFieldEnum)[keyof typeof LifeEventScalarFieldEnum]


  export const StarSystemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    hexLocation: 'hexLocation',
    sector: 'sector',
    subsector: 'subsector',
    allegiance: 'allegiance',
    starType: 'starType',
    gasGiants: 'gasGiants',
    jumpRoutes: 'jumpRoutes',
    campaignId: 'campaignId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StarSystemScalarFieldEnum = (typeof StarSystemScalarFieldEnum)[keyof typeof StarSystemScalarFieldEnum]


  export const PlanetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    uwp: 'uwp',
    size: 'size',
    atmosphere: 'atmosphere',
    hydrographics: 'hydrographics',
    population: 'population',
    government: 'government',
    lawLevel: 'lawLevel',
    techLevel: 'techLevel',
    starport: 'starport',
    tradeCodes: 'tradeCodes',
    bases: 'bases',
    gasGiant: 'gasGiant',
    description: 'description',
    notes: 'notes',
    starSystemId: 'starSystemId'
  };

  export type PlanetScalarFieldEnum = (typeof PlanetScalarFieldEnum)[keyof typeof PlanetScalarFieldEnum]


  export const StarshipScalarFieldEnum: {
    id: 'id',
    name: 'name',
    class: 'class',
    hullCode: 'hullCode',
    tonnage: 'tonnage',
    jumpDrive: 'jumpDrive',
    maneuverDrive: 'maneuverDrive',
    powerPlant: 'powerPlant',
    crew: 'crew',
    passengers: 'passengers',
    cargo: 'cargo',
    fuel: 'fuel',
    armor: 'armor',
    weapons: 'weapons',
    status: 'status',
    location: 'location',
    owner: 'owner',
    campaignId: 'campaignId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StarshipScalarFieldEnum = (typeof StarshipScalarFieldEnum)[keyof typeof StarshipScalarFieldEnum]


  export const TradeGoodScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    basePrice: 'basePrice',
    availability: 'availability',
    legality: 'legality',
    dtm: 'dtm',
    planetId: 'planetId'
  };

  export type TradeGoodScalarFieldEnum = (typeof TradeGoodScalarFieldEnum)[keyof typeof TradeGoodScalarFieldEnum]


  export const TradeRouteScalarFieldEnum: {
    id: 'id',
    name: 'name',
    distance: 'distance',
    difficulty: 'difficulty',
    originId: 'originId',
    destinationId: 'destinationId',
    cargoTypes: 'cargoTypes',
    profitMargin: 'profitMargin'
  };

  export type TradeRouteScalarFieldEnum = (typeof TradeRouteScalarFieldEnum)[keyof typeof TradeRouteScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    scheduledFor: 'scheduledFor',
    duration: 'duration',
    notes: 'notes',
    status: 'status',
    campaignId: 'campaignId',
    participants: 'participants',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const EncounterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    encounterType: 'encounterType',
    difficulty: 'difficulty',
    location: 'location',
    environment: 'environment',
    npcs: 'npcs',
    rewards: 'rewards',
    status: 'status',
    outcome: 'outcome',
    campaignId: 'campaignId',
    sessionId: 'sessionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EncounterScalarFieldEnum = (typeof EncounterScalarFieldEnum)[keyof typeof EncounterScalarFieldEnum]


  export const CombatSessionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    round: 'round',
    phase: 'phase',
    status: 'status',
    initiative: 'initiative',
    encounterId: 'encounterId',
    sessionId: 'sessionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CombatSessionScalarFieldEnum = (typeof CombatSessionScalarFieldEnum)[keyof typeof CombatSessionScalarFieldEnum]


  export const CombatActionScalarFieldEnum: {
    id: 'id',
    actionType: 'actionType',
    description: 'description',
    target: 'target',
    result: 'result',
    diceRolled: 'diceRolled',
    rollResult: 'rollResult',
    modifiers: 'modifiers',
    characterId: 'characterId',
    combatSessionId: 'combatSessionId',
    round: 'round',
    timestamp: 'timestamp'
  };

  export type CombatActionScalarFieldEnum = (typeof CombatActionScalarFieldEnum)[keyof typeof CombatActionScalarFieldEnum]


  export const DiceRollScalarFieldEnum: {
    id: 'id',
    dice: 'dice',
    result: 'result',
    individual: 'individual',
    modifiers: 'modifiers',
    description: 'description',
    isPublic: 'isPublic',
    isGMOnly: 'isGMOnly',
    rollerId: 'rollerId',
    campaignId: 'campaignId',
    character: 'character',
    skill: 'skill',
    timestamp: 'timestamp'
  };

  export type DiceRollScalarFieldEnum = (typeof DiceRollScalarFieldEnum)[keyof typeof DiceRollScalarFieldEnum]


  export const CustomContentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    contentType: 'contentType',
    category: 'category',
    data: 'data',
    tags: 'tags',
    isPublic: 'isPublic',
    isOfficial: 'isOfficial',
    authorId: 'authorId',
    campaignId: 'campaignId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomContentScalarFieldEnum = (typeof CustomContentScalarFieldEnum)[keyof typeof CustomContentScalarFieldEnum]


  export const HouseRuleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    ruleText: 'ruleText',
    pageReference: 'pageReference',
    replaces: 'replaces',
    isActive: 'isActive',
    campaignId: 'campaignId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HouseRuleScalarFieldEnum = (typeof HouseRuleScalarFieldEnum)[keyof typeof HouseRuleScalarFieldEnum]


  export const HandoutScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    content: 'content',
    imageUrl: 'imageUrl',
    fileUrl: 'fileUrl',
    isPlayerVisible: 'isPlayerVisible',
    recipients: 'recipients',
    authorId: 'authorId',
    campaignId: 'campaignId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HandoutScalarFieldEnum = (typeof HandoutScalarFieldEnum)[keyof typeof HandoutScalarFieldEnum]


  export const SessionNoteScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    noteType: 'noteType',
    tags: 'tags',
    isPublic: 'isPublic',
    authorId: 'authorId',
    campaignId: 'campaignId',
    sessionId: 'sessionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionNoteScalarFieldEnum = (typeof SessionNoteScalarFieldEnum)[keyof typeof SessionNoteScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'SubscriptionTier'
   */
  export type EnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier'>
    


  /**
   * Reference to a field of type 'SubscriptionTier[]'
   */
  export type ListEnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'CampaignRole'
   */
  export type EnumCampaignRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignRole'>
    


  /**
   * Reference to a field of type 'CampaignRole[]'
   */
  export type ListEnumCampaignRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignRole[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'SessionStatus'
   */
  export type EnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus'>
    


  /**
   * Reference to a field of type 'SessionStatus[]'
   */
  export type ListEnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    displayName?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    subscriptionTier?: EnumSubscriptionTierFilter<"User"> | $Enums.SubscriptionTier
    cognitoUserId?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    ownedCampaigns?: CampaignListRelationFilter
    campaignMembers?: CampaignMemberListRelationFilter
    characters?: CharacterListRelationFilter
    diceRolls?: DiceRollListRelationFilter
    customContent?: CustomContentListRelationFilter
    sessionNotes?: SessionNoteListRelationFilter
    handouts?: HandoutListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    timezone?: SortOrder
    subscriptionTier?: SortOrder
    cognitoUserId?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    ownedCampaigns?: CampaignOrderByRelationAggregateInput
    campaignMembers?: CampaignMemberOrderByRelationAggregateInput
    characters?: CharacterOrderByRelationAggregateInput
    diceRolls?: DiceRollOrderByRelationAggregateInput
    customContent?: CustomContentOrderByRelationAggregateInput
    sessionNotes?: SessionNoteOrderByRelationAggregateInput
    handouts?: HandoutOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    cognitoUserId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    displayName?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    subscriptionTier?: EnumSubscriptionTierFilter<"User"> | $Enums.SubscriptionTier
    emailVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    ownedCampaigns?: CampaignListRelationFilter
    campaignMembers?: CampaignMemberListRelationFilter
    characters?: CharacterListRelationFilter
    diceRolls?: DiceRollListRelationFilter
    customContent?: CustomContentListRelationFilter
    sessionNotes?: SessionNoteListRelationFilter
    handouts?: HandoutListRelationFilter
  }, "id" | "email" | "cognitoUserId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    displayName?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    timezone?: SortOrder
    subscriptionTier?: SortOrder
    cognitoUserId?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    displayName?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    timezone?: StringWithAggregatesFilter<"User"> | string
    subscriptionTier?: EnumSubscriptionTierWithAggregatesFilter<"User"> | $Enums.SubscriptionTier
    cognitoUserId?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    maxPlayers?: IntNullableFilter<"Campaign"> | number | null
    isPublic?: BoolFilter<"Campaign"> | boolean
    allowedBooks?: StringNullableListFilter<"Campaign">
    houseRules?: JsonNullableFilter<"Campaign">
    gamemasterId?: StringFilter<"Campaign"> | string
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    gamemaster?: XOR<UserRelationFilter, UserWhereInput>
    members?: CampaignMemberListRelationFilter
    characters?: CharacterListRelationFilter
    sessions?: SessionListRelationFilter
    diceRolls?: DiceRollListRelationFilter
    encounters?: EncounterListRelationFilter
    starSystems?: StarSystemListRelationFilter
    starships?: StarshipListRelationFilter
    customContent?: CustomContentListRelationFilter
    houseRulesData?: HouseRuleListRelationFilter
    handouts?: HandoutListRelationFilter
    sessionNotes?: SessionNoteListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    maxPlayers?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    allowedBooks?: SortOrder
    houseRules?: SortOrderInput | SortOrder
    gamemasterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gamemaster?: UserOrderByWithRelationInput
    members?: CampaignMemberOrderByRelationAggregateInput
    characters?: CharacterOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    diceRolls?: DiceRollOrderByRelationAggregateInput
    encounters?: EncounterOrderByRelationAggregateInput
    starSystems?: StarSystemOrderByRelationAggregateInput
    starships?: StarshipOrderByRelationAggregateInput
    customContent?: CustomContentOrderByRelationAggregateInput
    houseRulesData?: HouseRuleOrderByRelationAggregateInput
    handouts?: HandoutOrderByRelationAggregateInput
    sessionNotes?: SessionNoteOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    maxPlayers?: IntNullableFilter<"Campaign"> | number | null
    isPublic?: BoolFilter<"Campaign"> | boolean
    allowedBooks?: StringNullableListFilter<"Campaign">
    houseRules?: JsonNullableFilter<"Campaign">
    gamemasterId?: StringFilter<"Campaign"> | string
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    gamemaster?: XOR<UserRelationFilter, UserWhereInput>
    members?: CampaignMemberListRelationFilter
    characters?: CharacterListRelationFilter
    sessions?: SessionListRelationFilter
    diceRolls?: DiceRollListRelationFilter
    encounters?: EncounterListRelationFilter
    starSystems?: StarSystemListRelationFilter
    starships?: StarshipListRelationFilter
    customContent?: CustomContentListRelationFilter
    houseRulesData?: HouseRuleListRelationFilter
    handouts?: HandoutListRelationFilter
    sessionNotes?: SessionNoteListRelationFilter
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    maxPlayers?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    allowedBooks?: SortOrder
    houseRules?: SortOrderInput | SortOrder
    gamemasterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    name?: StringWithAggregatesFilter<"Campaign"> | string
    description?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    maxPlayers?: IntNullableWithAggregatesFilter<"Campaign"> | number | null
    isPublic?: BoolWithAggregatesFilter<"Campaign"> | boolean
    allowedBooks?: StringNullableListFilter<"Campaign">
    houseRules?: JsonNullableWithAggregatesFilter<"Campaign">
    gamemasterId?: StringWithAggregatesFilter<"Campaign"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
  }

  export type CampaignMemberWhereInput = {
    AND?: CampaignMemberWhereInput | CampaignMemberWhereInput[]
    OR?: CampaignMemberWhereInput[]
    NOT?: CampaignMemberWhereInput | CampaignMemberWhereInput[]
    id?: StringFilter<"CampaignMember"> | string
    campaignId?: StringFilter<"CampaignMember"> | string
    userId?: StringFilter<"CampaignMember"> | string
    role?: EnumCampaignRoleFilter<"CampaignMember"> | $Enums.CampaignRole
    isActive?: BoolFilter<"CampaignMember"> | boolean
    joinedAt?: DateTimeFilter<"CampaignMember"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CampaignMemberOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CampaignMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId_userId?: CampaignMemberCampaignIdUserIdCompoundUniqueInput
    AND?: CampaignMemberWhereInput | CampaignMemberWhereInput[]
    OR?: CampaignMemberWhereInput[]
    NOT?: CampaignMemberWhereInput | CampaignMemberWhereInput[]
    campaignId?: StringFilter<"CampaignMember"> | string
    userId?: StringFilter<"CampaignMember"> | string
    role?: EnumCampaignRoleFilter<"CampaignMember"> | $Enums.CampaignRole
    isActive?: BoolFilter<"CampaignMember"> | boolean
    joinedAt?: DateTimeFilter<"CampaignMember"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "campaignId_userId">

  export type CampaignMemberOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
    _count?: CampaignMemberCountOrderByAggregateInput
    _max?: CampaignMemberMaxOrderByAggregateInput
    _min?: CampaignMemberMinOrderByAggregateInput
  }

  export type CampaignMemberScalarWhereWithAggregatesInput = {
    AND?: CampaignMemberScalarWhereWithAggregatesInput | CampaignMemberScalarWhereWithAggregatesInput[]
    OR?: CampaignMemberScalarWhereWithAggregatesInput[]
    NOT?: CampaignMemberScalarWhereWithAggregatesInput | CampaignMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignMember"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignMember"> | string
    userId?: StringWithAggregatesFilter<"CampaignMember"> | string
    role?: EnumCampaignRoleWithAggregatesFilter<"CampaignMember"> | $Enums.CampaignRole
    isActive?: BoolWithAggregatesFilter<"CampaignMember"> | boolean
    joinedAt?: DateTimeWithAggregatesFilter<"CampaignMember"> | Date | string
  }

  export type CharacterWhereInput = {
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    id?: StringFilter<"Character"> | string
    name?: StringFilter<"Character"> | string
    credits?: IntFilter<"Character"> | number
    notes?: StringNullableFilter<"Character"> | string | null
    portrait?: StringNullableFilter<"Character"> | string | null
    homeworld?: StringNullableFilter<"Character"> | string | null
    age?: IntNullableFilter<"Character"> | number | null
    gender?: StringNullableFilter<"Character"> | string | null
    species?: StringNullableFilter<"Character"> | string | null
    playerId?: StringFilter<"Character"> | string
    campaignId?: StringFilter<"Character"> | string
    createdAt?: DateTimeFilter<"Character"> | Date | string
    updatedAt?: DateTimeFilter<"Character"> | Date | string
    player?: XOR<UserRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    characteristics?: XOR<CharacteristicsNullableRelationFilter, CharacteristicsWhereInput> | null
    skills?: CharacterSkillListRelationFilter
    equipment?: CharacterEquipmentListRelationFilter
    lifeEvents?: LifeEventListRelationFilter
    combatActions?: CombatActionListRelationFilter
  }

  export type CharacterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    credits?: SortOrder
    notes?: SortOrderInput | SortOrder
    portrait?: SortOrderInput | SortOrder
    homeworld?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    species?: SortOrderInput | SortOrder
    playerId?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    player?: UserOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
    characteristics?: CharacteristicsOrderByWithRelationInput
    skills?: CharacterSkillOrderByRelationAggregateInput
    equipment?: CharacterEquipmentOrderByRelationAggregateInput
    lifeEvents?: LifeEventOrderByRelationAggregateInput
    combatActions?: CombatActionOrderByRelationAggregateInput
  }

  export type CharacterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_campaignId_name?: CharacterPlayerIdCampaignIdNameCompoundUniqueInput
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    name?: StringFilter<"Character"> | string
    credits?: IntFilter<"Character"> | number
    notes?: StringNullableFilter<"Character"> | string | null
    portrait?: StringNullableFilter<"Character"> | string | null
    homeworld?: StringNullableFilter<"Character"> | string | null
    age?: IntNullableFilter<"Character"> | number | null
    gender?: StringNullableFilter<"Character"> | string | null
    species?: StringNullableFilter<"Character"> | string | null
    playerId?: StringFilter<"Character"> | string
    campaignId?: StringFilter<"Character"> | string
    createdAt?: DateTimeFilter<"Character"> | Date | string
    updatedAt?: DateTimeFilter<"Character"> | Date | string
    player?: XOR<UserRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    characteristics?: XOR<CharacteristicsNullableRelationFilter, CharacteristicsWhereInput> | null
    skills?: CharacterSkillListRelationFilter
    equipment?: CharacterEquipmentListRelationFilter
    lifeEvents?: LifeEventListRelationFilter
    combatActions?: CombatActionListRelationFilter
  }, "id" | "playerId_campaignId_name">

  export type CharacterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    credits?: SortOrder
    notes?: SortOrderInput | SortOrder
    portrait?: SortOrderInput | SortOrder
    homeworld?: SortOrderInput | SortOrder
    age?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    species?: SortOrderInput | SortOrder
    playerId?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CharacterCountOrderByAggregateInput
    _avg?: CharacterAvgOrderByAggregateInput
    _max?: CharacterMaxOrderByAggregateInput
    _min?: CharacterMinOrderByAggregateInput
    _sum?: CharacterSumOrderByAggregateInput
  }

  export type CharacterScalarWhereWithAggregatesInput = {
    AND?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    OR?: CharacterScalarWhereWithAggregatesInput[]
    NOT?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Character"> | string
    name?: StringWithAggregatesFilter<"Character"> | string
    credits?: IntWithAggregatesFilter<"Character"> | number
    notes?: StringNullableWithAggregatesFilter<"Character"> | string | null
    portrait?: StringNullableWithAggregatesFilter<"Character"> | string | null
    homeworld?: StringNullableWithAggregatesFilter<"Character"> | string | null
    age?: IntNullableWithAggregatesFilter<"Character"> | number | null
    gender?: StringNullableWithAggregatesFilter<"Character"> | string | null
    species?: StringNullableWithAggregatesFilter<"Character"> | string | null
    playerId?: StringWithAggregatesFilter<"Character"> | string
    campaignId?: StringWithAggregatesFilter<"Character"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Character"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Character"> | Date | string
  }

  export type CharacteristicsWhereInput = {
    AND?: CharacteristicsWhereInput | CharacteristicsWhereInput[]
    OR?: CharacteristicsWhereInput[]
    NOT?: CharacteristicsWhereInput | CharacteristicsWhereInput[]
    id?: StringFilter<"Characteristics"> | string
    strength?: IntFilter<"Characteristics"> | number
    dexterity?: IntFilter<"Characteristics"> | number
    endurance?: IntFilter<"Characteristics"> | number
    intelligence?: IntFilter<"Characteristics"> | number
    education?: IntFilter<"Characteristics"> | number
    socialStanding?: IntFilter<"Characteristics"> | number
    physicalDamage?: IntNullableFilter<"Characteristics"> | number | null
    mentalDamage?: IntNullableFilter<"Characteristics"> | number | null
    characterId?: StringFilter<"Characteristics"> | string
    character?: XOR<CharacterRelationFilter, CharacterWhereInput>
  }

  export type CharacteristicsOrderByWithRelationInput = {
    id?: SortOrder
    strength?: SortOrder
    dexterity?: SortOrder
    endurance?: SortOrder
    intelligence?: SortOrder
    education?: SortOrder
    socialStanding?: SortOrder
    physicalDamage?: SortOrderInput | SortOrder
    mentalDamage?: SortOrderInput | SortOrder
    characterId?: SortOrder
    character?: CharacterOrderByWithRelationInput
  }

  export type CharacteristicsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    characterId?: string
    AND?: CharacteristicsWhereInput | CharacteristicsWhereInput[]
    OR?: CharacteristicsWhereInput[]
    NOT?: CharacteristicsWhereInput | CharacteristicsWhereInput[]
    strength?: IntFilter<"Characteristics"> | number
    dexterity?: IntFilter<"Characteristics"> | number
    endurance?: IntFilter<"Characteristics"> | number
    intelligence?: IntFilter<"Characteristics"> | number
    education?: IntFilter<"Characteristics"> | number
    socialStanding?: IntFilter<"Characteristics"> | number
    physicalDamage?: IntNullableFilter<"Characteristics"> | number | null
    mentalDamage?: IntNullableFilter<"Characteristics"> | number | null
    character?: XOR<CharacterRelationFilter, CharacterWhereInput>
  }, "id" | "characterId">

  export type CharacteristicsOrderByWithAggregationInput = {
    id?: SortOrder
    strength?: SortOrder
    dexterity?: SortOrder
    endurance?: SortOrder
    intelligence?: SortOrder
    education?: SortOrder
    socialStanding?: SortOrder
    physicalDamage?: SortOrderInput | SortOrder
    mentalDamage?: SortOrderInput | SortOrder
    characterId?: SortOrder
    _count?: CharacteristicsCountOrderByAggregateInput
    _avg?: CharacteristicsAvgOrderByAggregateInput
    _max?: CharacteristicsMaxOrderByAggregateInput
    _min?: CharacteristicsMinOrderByAggregateInput
    _sum?: CharacteristicsSumOrderByAggregateInput
  }

  export type CharacteristicsScalarWhereWithAggregatesInput = {
    AND?: CharacteristicsScalarWhereWithAggregatesInput | CharacteristicsScalarWhereWithAggregatesInput[]
    OR?: CharacteristicsScalarWhereWithAggregatesInput[]
    NOT?: CharacteristicsScalarWhereWithAggregatesInput | CharacteristicsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Characteristics"> | string
    strength?: IntWithAggregatesFilter<"Characteristics"> | number
    dexterity?: IntWithAggregatesFilter<"Characteristics"> | number
    endurance?: IntWithAggregatesFilter<"Characteristics"> | number
    intelligence?: IntWithAggregatesFilter<"Characteristics"> | number
    education?: IntWithAggregatesFilter<"Characteristics"> | number
    socialStanding?: IntWithAggregatesFilter<"Characteristics"> | number
    physicalDamage?: IntNullableWithAggregatesFilter<"Characteristics"> | number | null
    mentalDamage?: IntNullableWithAggregatesFilter<"Characteristics"> | number | null
    characterId?: StringWithAggregatesFilter<"Characteristics"> | string
  }

  export type CharacterSkillWhereInput = {
    AND?: CharacterSkillWhereInput | CharacterSkillWhereInput[]
    OR?: CharacterSkillWhereInput[]
    NOT?: CharacterSkillWhereInput | CharacterSkillWhereInput[]
    id?: StringFilter<"CharacterSkill"> | string
    name?: StringFilter<"CharacterSkill"> | string
    level?: IntFilter<"CharacterSkill"> | number
    specialization?: StringNullableFilter<"CharacterSkill"> | string | null
    characterId?: StringFilter<"CharacterSkill"> | string
    character?: XOR<CharacterRelationFilter, CharacterWhereInput>
  }

  export type CharacterSkillOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    specialization?: SortOrderInput | SortOrder
    characterId?: SortOrder
    character?: CharacterOrderByWithRelationInput
  }

  export type CharacterSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    characterId_name_specialization?: CharacterSkillCharacterIdNameSpecializationCompoundUniqueInput
    AND?: CharacterSkillWhereInput | CharacterSkillWhereInput[]
    OR?: CharacterSkillWhereInput[]
    NOT?: CharacterSkillWhereInput | CharacterSkillWhereInput[]
    name?: StringFilter<"CharacterSkill"> | string
    level?: IntFilter<"CharacterSkill"> | number
    specialization?: StringNullableFilter<"CharacterSkill"> | string | null
    characterId?: StringFilter<"CharacterSkill"> | string
    character?: XOR<CharacterRelationFilter, CharacterWhereInput>
  }, "id" | "characterId_name_specialization">

  export type CharacterSkillOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    specialization?: SortOrderInput | SortOrder
    characterId?: SortOrder
    _count?: CharacterSkillCountOrderByAggregateInput
    _avg?: CharacterSkillAvgOrderByAggregateInput
    _max?: CharacterSkillMaxOrderByAggregateInput
    _min?: CharacterSkillMinOrderByAggregateInput
    _sum?: CharacterSkillSumOrderByAggregateInput
  }

  export type CharacterSkillScalarWhereWithAggregatesInput = {
    AND?: CharacterSkillScalarWhereWithAggregatesInput | CharacterSkillScalarWhereWithAggregatesInput[]
    OR?: CharacterSkillScalarWhereWithAggregatesInput[]
    NOT?: CharacterSkillScalarWhereWithAggregatesInput | CharacterSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacterSkill"> | string
    name?: StringWithAggregatesFilter<"CharacterSkill"> | string
    level?: IntWithAggregatesFilter<"CharacterSkill"> | number
    specialization?: StringNullableWithAggregatesFilter<"CharacterSkill"> | string | null
    characterId?: StringWithAggregatesFilter<"CharacterSkill"> | string
  }

  export type CharacterEquipmentWhereInput = {
    AND?: CharacterEquipmentWhereInput | CharacterEquipmentWhereInput[]
    OR?: CharacterEquipmentWhereInput[]
    NOT?: CharacterEquipmentWhereInput | CharacterEquipmentWhereInput[]
    id?: StringFilter<"CharacterEquipment"> | string
    name?: StringFilter<"CharacterEquipment"> | string
    description?: StringNullableFilter<"CharacterEquipment"> | string | null
    weight?: FloatNullableFilter<"CharacterEquipment"> | number | null
    cost?: IntNullableFilter<"CharacterEquipment"> | number | null
    quantity?: IntFilter<"CharacterEquipment"> | number
    equipped?: BoolFilter<"CharacterEquipment"> | boolean
    category?: StringNullableFilter<"CharacterEquipment"> | string | null
    subcategory?: StringNullableFilter<"CharacterEquipment"> | string | null
    weaponType?: StringNullableFilter<"CharacterEquipment"> | string | null
    damage?: StringNullableFilter<"CharacterEquipment"> | string | null
    range?: StringNullableFilter<"CharacterEquipment"> | string | null
    armorValue?: IntNullableFilter<"CharacterEquipment"> | number | null
    armorType?: StringNullableFilter<"CharacterEquipment"> | string | null
    characterId?: StringFilter<"CharacterEquipment"> | string
    character?: XOR<CharacterRelationFilter, CharacterWhereInput>
  }

  export type CharacterEquipmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    quantity?: SortOrder
    equipped?: SortOrder
    category?: SortOrderInput | SortOrder
    subcategory?: SortOrderInput | SortOrder
    weaponType?: SortOrderInput | SortOrder
    damage?: SortOrderInput | SortOrder
    range?: SortOrderInput | SortOrder
    armorValue?: SortOrderInput | SortOrder
    armorType?: SortOrderInput | SortOrder
    characterId?: SortOrder
    character?: CharacterOrderByWithRelationInput
  }

  export type CharacterEquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CharacterEquipmentWhereInput | CharacterEquipmentWhereInput[]
    OR?: CharacterEquipmentWhereInput[]
    NOT?: CharacterEquipmentWhereInput | CharacterEquipmentWhereInput[]
    name?: StringFilter<"CharacterEquipment"> | string
    description?: StringNullableFilter<"CharacterEquipment"> | string | null
    weight?: FloatNullableFilter<"CharacterEquipment"> | number | null
    cost?: IntNullableFilter<"CharacterEquipment"> | number | null
    quantity?: IntFilter<"CharacterEquipment"> | number
    equipped?: BoolFilter<"CharacterEquipment"> | boolean
    category?: StringNullableFilter<"CharacterEquipment"> | string | null
    subcategory?: StringNullableFilter<"CharacterEquipment"> | string | null
    weaponType?: StringNullableFilter<"CharacterEquipment"> | string | null
    damage?: StringNullableFilter<"CharacterEquipment"> | string | null
    range?: StringNullableFilter<"CharacterEquipment"> | string | null
    armorValue?: IntNullableFilter<"CharacterEquipment"> | number | null
    armorType?: StringNullableFilter<"CharacterEquipment"> | string | null
    characterId?: StringFilter<"CharacterEquipment"> | string
    character?: XOR<CharacterRelationFilter, CharacterWhereInput>
  }, "id">

  export type CharacterEquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    quantity?: SortOrder
    equipped?: SortOrder
    category?: SortOrderInput | SortOrder
    subcategory?: SortOrderInput | SortOrder
    weaponType?: SortOrderInput | SortOrder
    damage?: SortOrderInput | SortOrder
    range?: SortOrderInput | SortOrder
    armorValue?: SortOrderInput | SortOrder
    armorType?: SortOrderInput | SortOrder
    characterId?: SortOrder
    _count?: CharacterEquipmentCountOrderByAggregateInput
    _avg?: CharacterEquipmentAvgOrderByAggregateInput
    _max?: CharacterEquipmentMaxOrderByAggregateInput
    _min?: CharacterEquipmentMinOrderByAggregateInput
    _sum?: CharacterEquipmentSumOrderByAggregateInput
  }

  export type CharacterEquipmentScalarWhereWithAggregatesInput = {
    AND?: CharacterEquipmentScalarWhereWithAggregatesInput | CharacterEquipmentScalarWhereWithAggregatesInput[]
    OR?: CharacterEquipmentScalarWhereWithAggregatesInput[]
    NOT?: CharacterEquipmentScalarWhereWithAggregatesInput | CharacterEquipmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacterEquipment"> | string
    name?: StringWithAggregatesFilter<"CharacterEquipment"> | string
    description?: StringNullableWithAggregatesFilter<"CharacterEquipment"> | string | null
    weight?: FloatNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    cost?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    quantity?: IntWithAggregatesFilter<"CharacterEquipment"> | number
    equipped?: BoolWithAggregatesFilter<"CharacterEquipment"> | boolean
    category?: StringNullableWithAggregatesFilter<"CharacterEquipment"> | string | null
    subcategory?: StringNullableWithAggregatesFilter<"CharacterEquipment"> | string | null
    weaponType?: StringNullableWithAggregatesFilter<"CharacterEquipment"> | string | null
    damage?: StringNullableWithAggregatesFilter<"CharacterEquipment"> | string | null
    range?: StringNullableWithAggregatesFilter<"CharacterEquipment"> | string | null
    armorValue?: IntNullableWithAggregatesFilter<"CharacterEquipment"> | number | null
    armorType?: StringNullableWithAggregatesFilter<"CharacterEquipment"> | string | null
    characterId?: StringWithAggregatesFilter<"CharacterEquipment"> | string
  }

  export type LifeEventWhereInput = {
    AND?: LifeEventWhereInput | LifeEventWhereInput[]
    OR?: LifeEventWhereInput[]
    NOT?: LifeEventWhereInput | LifeEventWhereInput[]
    id?: StringFilter<"LifeEvent"> | string
    age?: IntFilter<"LifeEvent"> | number
    event?: StringFilter<"LifeEvent"> | string
    description?: StringNullableFilter<"LifeEvent"> | string | null
    effects?: JsonNullableFilter<"LifeEvent">
    career?: StringNullableFilter<"LifeEvent"> | string | null
    rank?: StringNullableFilter<"LifeEvent"> | string | null
    skills?: StringNullableListFilter<"LifeEvent">
    characterId?: StringFilter<"LifeEvent"> | string
    character?: XOR<CharacterRelationFilter, CharacterWhereInput>
  }

  export type LifeEventOrderByWithRelationInput = {
    id?: SortOrder
    age?: SortOrder
    event?: SortOrder
    description?: SortOrderInput | SortOrder
    effects?: SortOrderInput | SortOrder
    career?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    skills?: SortOrder
    characterId?: SortOrder
    character?: CharacterOrderByWithRelationInput
  }

  export type LifeEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LifeEventWhereInput | LifeEventWhereInput[]
    OR?: LifeEventWhereInput[]
    NOT?: LifeEventWhereInput | LifeEventWhereInput[]
    age?: IntFilter<"LifeEvent"> | number
    event?: StringFilter<"LifeEvent"> | string
    description?: StringNullableFilter<"LifeEvent"> | string | null
    effects?: JsonNullableFilter<"LifeEvent">
    career?: StringNullableFilter<"LifeEvent"> | string | null
    rank?: StringNullableFilter<"LifeEvent"> | string | null
    skills?: StringNullableListFilter<"LifeEvent">
    characterId?: StringFilter<"LifeEvent"> | string
    character?: XOR<CharacterRelationFilter, CharacterWhereInput>
  }, "id">

  export type LifeEventOrderByWithAggregationInput = {
    id?: SortOrder
    age?: SortOrder
    event?: SortOrder
    description?: SortOrderInput | SortOrder
    effects?: SortOrderInput | SortOrder
    career?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    skills?: SortOrder
    characterId?: SortOrder
    _count?: LifeEventCountOrderByAggregateInput
    _avg?: LifeEventAvgOrderByAggregateInput
    _max?: LifeEventMaxOrderByAggregateInput
    _min?: LifeEventMinOrderByAggregateInput
    _sum?: LifeEventSumOrderByAggregateInput
  }

  export type LifeEventScalarWhereWithAggregatesInput = {
    AND?: LifeEventScalarWhereWithAggregatesInput | LifeEventScalarWhereWithAggregatesInput[]
    OR?: LifeEventScalarWhereWithAggregatesInput[]
    NOT?: LifeEventScalarWhereWithAggregatesInput | LifeEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LifeEvent"> | string
    age?: IntWithAggregatesFilter<"LifeEvent"> | number
    event?: StringWithAggregatesFilter<"LifeEvent"> | string
    description?: StringNullableWithAggregatesFilter<"LifeEvent"> | string | null
    effects?: JsonNullableWithAggregatesFilter<"LifeEvent">
    career?: StringNullableWithAggregatesFilter<"LifeEvent"> | string | null
    rank?: StringNullableWithAggregatesFilter<"LifeEvent"> | string | null
    skills?: StringNullableListFilter<"LifeEvent">
    characterId?: StringWithAggregatesFilter<"LifeEvent"> | string
  }

  export type StarSystemWhereInput = {
    AND?: StarSystemWhereInput | StarSystemWhereInput[]
    OR?: StarSystemWhereInput[]
    NOT?: StarSystemWhereInput | StarSystemWhereInput[]
    id?: StringFilter<"StarSystem"> | string
    name?: StringFilter<"StarSystem"> | string
    hexLocation?: StringFilter<"StarSystem"> | string
    sector?: StringFilter<"StarSystem"> | string
    subsector?: StringNullableFilter<"StarSystem"> | string | null
    allegiance?: StringNullableFilter<"StarSystem"> | string | null
    starType?: StringNullableFilter<"StarSystem"> | string | null
    gasGiants?: IntFilter<"StarSystem"> | number
    jumpRoutes?: StringNullableListFilter<"StarSystem">
    campaignId?: StringNullableFilter<"StarSystem"> | string | null
    createdAt?: DateTimeFilter<"StarSystem"> | Date | string
    updatedAt?: DateTimeFilter<"StarSystem"> | Date | string
    campaign?: XOR<CampaignNullableRelationFilter, CampaignWhereInput> | null
    planets?: PlanetListRelationFilter
    tradeRoutes?: TradeRouteListRelationFilter
    tradeRoutesDestination?: TradeRouteListRelationFilter
  }

  export type StarSystemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    hexLocation?: SortOrder
    sector?: SortOrder
    subsector?: SortOrderInput | SortOrder
    allegiance?: SortOrderInput | SortOrder
    starType?: SortOrderInput | SortOrder
    gasGiants?: SortOrder
    jumpRoutes?: SortOrder
    campaignId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    planets?: PlanetOrderByRelationAggregateInput
    tradeRoutes?: TradeRouteOrderByRelationAggregateInput
    tradeRoutesDestination?: TradeRouteOrderByRelationAggregateInput
  }

  export type StarSystemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId_hexLocation?: StarSystemCampaignIdHexLocationCompoundUniqueInput
    AND?: StarSystemWhereInput | StarSystemWhereInput[]
    OR?: StarSystemWhereInput[]
    NOT?: StarSystemWhereInput | StarSystemWhereInput[]
    name?: StringFilter<"StarSystem"> | string
    hexLocation?: StringFilter<"StarSystem"> | string
    sector?: StringFilter<"StarSystem"> | string
    subsector?: StringNullableFilter<"StarSystem"> | string | null
    allegiance?: StringNullableFilter<"StarSystem"> | string | null
    starType?: StringNullableFilter<"StarSystem"> | string | null
    gasGiants?: IntFilter<"StarSystem"> | number
    jumpRoutes?: StringNullableListFilter<"StarSystem">
    campaignId?: StringNullableFilter<"StarSystem"> | string | null
    createdAt?: DateTimeFilter<"StarSystem"> | Date | string
    updatedAt?: DateTimeFilter<"StarSystem"> | Date | string
    campaign?: XOR<CampaignNullableRelationFilter, CampaignWhereInput> | null
    planets?: PlanetListRelationFilter
    tradeRoutes?: TradeRouteListRelationFilter
    tradeRoutesDestination?: TradeRouteListRelationFilter
  }, "id" | "campaignId_hexLocation">

  export type StarSystemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    hexLocation?: SortOrder
    sector?: SortOrder
    subsector?: SortOrderInput | SortOrder
    allegiance?: SortOrderInput | SortOrder
    starType?: SortOrderInput | SortOrder
    gasGiants?: SortOrder
    jumpRoutes?: SortOrder
    campaignId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StarSystemCountOrderByAggregateInput
    _avg?: StarSystemAvgOrderByAggregateInput
    _max?: StarSystemMaxOrderByAggregateInput
    _min?: StarSystemMinOrderByAggregateInput
    _sum?: StarSystemSumOrderByAggregateInput
  }

  export type StarSystemScalarWhereWithAggregatesInput = {
    AND?: StarSystemScalarWhereWithAggregatesInput | StarSystemScalarWhereWithAggregatesInput[]
    OR?: StarSystemScalarWhereWithAggregatesInput[]
    NOT?: StarSystemScalarWhereWithAggregatesInput | StarSystemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StarSystem"> | string
    name?: StringWithAggregatesFilter<"StarSystem"> | string
    hexLocation?: StringWithAggregatesFilter<"StarSystem"> | string
    sector?: StringWithAggregatesFilter<"StarSystem"> | string
    subsector?: StringNullableWithAggregatesFilter<"StarSystem"> | string | null
    allegiance?: StringNullableWithAggregatesFilter<"StarSystem"> | string | null
    starType?: StringNullableWithAggregatesFilter<"StarSystem"> | string | null
    gasGiants?: IntWithAggregatesFilter<"StarSystem"> | number
    jumpRoutes?: StringNullableListFilter<"StarSystem">
    campaignId?: StringNullableWithAggregatesFilter<"StarSystem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StarSystem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StarSystem"> | Date | string
  }

  export type PlanetWhereInput = {
    AND?: PlanetWhereInput | PlanetWhereInput[]
    OR?: PlanetWhereInput[]
    NOT?: PlanetWhereInput | PlanetWhereInput[]
    id?: StringFilter<"Planet"> | string
    name?: StringFilter<"Planet"> | string
    uwp?: StringFilter<"Planet"> | string
    size?: IntFilter<"Planet"> | number
    atmosphere?: IntFilter<"Planet"> | number
    hydrographics?: IntFilter<"Planet"> | number
    population?: IntFilter<"Planet"> | number
    government?: IntFilter<"Planet"> | number
    lawLevel?: IntFilter<"Planet"> | number
    techLevel?: IntFilter<"Planet"> | number
    starport?: StringFilter<"Planet"> | string
    tradeCodes?: StringNullableListFilter<"Planet">
    bases?: StringNullableListFilter<"Planet">
    gasGiant?: BoolFilter<"Planet"> | boolean
    description?: StringNullableFilter<"Planet"> | string | null
    notes?: StringNullableFilter<"Planet"> | string | null
    starSystemId?: StringFilter<"Planet"> | string
    starSystem?: XOR<StarSystemRelationFilter, StarSystemWhereInput>
    tradeGoods?: TradeGoodListRelationFilter
  }

  export type PlanetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    uwp?: SortOrder
    size?: SortOrder
    atmosphere?: SortOrder
    hydrographics?: SortOrder
    population?: SortOrder
    government?: SortOrder
    lawLevel?: SortOrder
    techLevel?: SortOrder
    starport?: SortOrder
    tradeCodes?: SortOrder
    bases?: SortOrder
    gasGiant?: SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    starSystemId?: SortOrder
    starSystem?: StarSystemOrderByWithRelationInput
    tradeGoods?: TradeGoodOrderByRelationAggregateInput
  }

  export type PlanetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanetWhereInput | PlanetWhereInput[]
    OR?: PlanetWhereInput[]
    NOT?: PlanetWhereInput | PlanetWhereInput[]
    name?: StringFilter<"Planet"> | string
    uwp?: StringFilter<"Planet"> | string
    size?: IntFilter<"Planet"> | number
    atmosphere?: IntFilter<"Planet"> | number
    hydrographics?: IntFilter<"Planet"> | number
    population?: IntFilter<"Planet"> | number
    government?: IntFilter<"Planet"> | number
    lawLevel?: IntFilter<"Planet"> | number
    techLevel?: IntFilter<"Planet"> | number
    starport?: StringFilter<"Planet"> | string
    tradeCodes?: StringNullableListFilter<"Planet">
    bases?: StringNullableListFilter<"Planet">
    gasGiant?: BoolFilter<"Planet"> | boolean
    description?: StringNullableFilter<"Planet"> | string | null
    notes?: StringNullableFilter<"Planet"> | string | null
    starSystemId?: StringFilter<"Planet"> | string
    starSystem?: XOR<StarSystemRelationFilter, StarSystemWhereInput>
    tradeGoods?: TradeGoodListRelationFilter
  }, "id">

  export type PlanetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    uwp?: SortOrder
    size?: SortOrder
    atmosphere?: SortOrder
    hydrographics?: SortOrder
    population?: SortOrder
    government?: SortOrder
    lawLevel?: SortOrder
    techLevel?: SortOrder
    starport?: SortOrder
    tradeCodes?: SortOrder
    bases?: SortOrder
    gasGiant?: SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    starSystemId?: SortOrder
    _count?: PlanetCountOrderByAggregateInput
    _avg?: PlanetAvgOrderByAggregateInput
    _max?: PlanetMaxOrderByAggregateInput
    _min?: PlanetMinOrderByAggregateInput
    _sum?: PlanetSumOrderByAggregateInput
  }

  export type PlanetScalarWhereWithAggregatesInput = {
    AND?: PlanetScalarWhereWithAggregatesInput | PlanetScalarWhereWithAggregatesInput[]
    OR?: PlanetScalarWhereWithAggregatesInput[]
    NOT?: PlanetScalarWhereWithAggregatesInput | PlanetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Planet"> | string
    name?: StringWithAggregatesFilter<"Planet"> | string
    uwp?: StringWithAggregatesFilter<"Planet"> | string
    size?: IntWithAggregatesFilter<"Planet"> | number
    atmosphere?: IntWithAggregatesFilter<"Planet"> | number
    hydrographics?: IntWithAggregatesFilter<"Planet"> | number
    population?: IntWithAggregatesFilter<"Planet"> | number
    government?: IntWithAggregatesFilter<"Planet"> | number
    lawLevel?: IntWithAggregatesFilter<"Planet"> | number
    techLevel?: IntWithAggregatesFilter<"Planet"> | number
    starport?: StringWithAggregatesFilter<"Planet"> | string
    tradeCodes?: StringNullableListFilter<"Planet">
    bases?: StringNullableListFilter<"Planet">
    gasGiant?: BoolWithAggregatesFilter<"Planet"> | boolean
    description?: StringNullableWithAggregatesFilter<"Planet"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Planet"> | string | null
    starSystemId?: StringWithAggregatesFilter<"Planet"> | string
  }

  export type StarshipWhereInput = {
    AND?: StarshipWhereInput | StarshipWhereInput[]
    OR?: StarshipWhereInput[]
    NOT?: StarshipWhereInput | StarshipWhereInput[]
    id?: StringFilter<"Starship"> | string
    name?: StringFilter<"Starship"> | string
    class?: StringFilter<"Starship"> | string
    hullCode?: StringNullableFilter<"Starship"> | string | null
    tonnage?: IntFilter<"Starship"> | number
    jumpDrive?: IntFilter<"Starship"> | number
    maneuverDrive?: IntFilter<"Starship"> | number
    powerPlant?: IntFilter<"Starship"> | number
    crew?: IntFilter<"Starship"> | number
    passengers?: IntFilter<"Starship"> | number
    cargo?: IntFilter<"Starship"> | number
    fuel?: IntFilter<"Starship"> | number
    armor?: IntFilter<"Starship"> | number
    weapons?: JsonNullableFilter<"Starship">
    status?: StringFilter<"Starship"> | string
    location?: StringNullableFilter<"Starship"> | string | null
    owner?: StringNullableFilter<"Starship"> | string | null
    campaignId?: StringNullableFilter<"Starship"> | string | null
    createdAt?: DateTimeFilter<"Starship"> | Date | string
    updatedAt?: DateTimeFilter<"Starship"> | Date | string
    campaign?: XOR<CampaignNullableRelationFilter, CampaignWhereInput> | null
  }

  export type StarshipOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    class?: SortOrder
    hullCode?: SortOrderInput | SortOrder
    tonnage?: SortOrder
    jumpDrive?: SortOrder
    maneuverDrive?: SortOrder
    powerPlant?: SortOrder
    crew?: SortOrder
    passengers?: SortOrder
    cargo?: SortOrder
    fuel?: SortOrder
    armor?: SortOrder
    weapons?: SortOrderInput | SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    owner?: SortOrderInput | SortOrder
    campaignId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type StarshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StarshipWhereInput | StarshipWhereInput[]
    OR?: StarshipWhereInput[]
    NOT?: StarshipWhereInput | StarshipWhereInput[]
    name?: StringFilter<"Starship"> | string
    class?: StringFilter<"Starship"> | string
    hullCode?: StringNullableFilter<"Starship"> | string | null
    tonnage?: IntFilter<"Starship"> | number
    jumpDrive?: IntFilter<"Starship"> | number
    maneuverDrive?: IntFilter<"Starship"> | number
    powerPlant?: IntFilter<"Starship"> | number
    crew?: IntFilter<"Starship"> | number
    passengers?: IntFilter<"Starship"> | number
    cargo?: IntFilter<"Starship"> | number
    fuel?: IntFilter<"Starship"> | number
    armor?: IntFilter<"Starship"> | number
    weapons?: JsonNullableFilter<"Starship">
    status?: StringFilter<"Starship"> | string
    location?: StringNullableFilter<"Starship"> | string | null
    owner?: StringNullableFilter<"Starship"> | string | null
    campaignId?: StringNullableFilter<"Starship"> | string | null
    createdAt?: DateTimeFilter<"Starship"> | Date | string
    updatedAt?: DateTimeFilter<"Starship"> | Date | string
    campaign?: XOR<CampaignNullableRelationFilter, CampaignWhereInput> | null
  }, "id">

  export type StarshipOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    class?: SortOrder
    hullCode?: SortOrderInput | SortOrder
    tonnage?: SortOrder
    jumpDrive?: SortOrder
    maneuverDrive?: SortOrder
    powerPlant?: SortOrder
    crew?: SortOrder
    passengers?: SortOrder
    cargo?: SortOrder
    fuel?: SortOrder
    armor?: SortOrder
    weapons?: SortOrderInput | SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    owner?: SortOrderInput | SortOrder
    campaignId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StarshipCountOrderByAggregateInput
    _avg?: StarshipAvgOrderByAggregateInput
    _max?: StarshipMaxOrderByAggregateInput
    _min?: StarshipMinOrderByAggregateInput
    _sum?: StarshipSumOrderByAggregateInput
  }

  export type StarshipScalarWhereWithAggregatesInput = {
    AND?: StarshipScalarWhereWithAggregatesInput | StarshipScalarWhereWithAggregatesInput[]
    OR?: StarshipScalarWhereWithAggregatesInput[]
    NOT?: StarshipScalarWhereWithAggregatesInput | StarshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Starship"> | string
    name?: StringWithAggregatesFilter<"Starship"> | string
    class?: StringWithAggregatesFilter<"Starship"> | string
    hullCode?: StringNullableWithAggregatesFilter<"Starship"> | string | null
    tonnage?: IntWithAggregatesFilter<"Starship"> | number
    jumpDrive?: IntWithAggregatesFilter<"Starship"> | number
    maneuverDrive?: IntWithAggregatesFilter<"Starship"> | number
    powerPlant?: IntWithAggregatesFilter<"Starship"> | number
    crew?: IntWithAggregatesFilter<"Starship"> | number
    passengers?: IntWithAggregatesFilter<"Starship"> | number
    cargo?: IntWithAggregatesFilter<"Starship"> | number
    fuel?: IntWithAggregatesFilter<"Starship"> | number
    armor?: IntWithAggregatesFilter<"Starship"> | number
    weapons?: JsonNullableWithAggregatesFilter<"Starship">
    status?: StringWithAggregatesFilter<"Starship"> | string
    location?: StringNullableWithAggregatesFilter<"Starship"> | string | null
    owner?: StringNullableWithAggregatesFilter<"Starship"> | string | null
    campaignId?: StringNullableWithAggregatesFilter<"Starship"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Starship"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Starship"> | Date | string
  }

  export type TradeGoodWhereInput = {
    AND?: TradeGoodWhereInput | TradeGoodWhereInput[]
    OR?: TradeGoodWhereInput[]
    NOT?: TradeGoodWhereInput | TradeGoodWhereInput[]
    id?: StringFilter<"TradeGood"> | string
    name?: StringFilter<"TradeGood"> | string
    category?: StringFilter<"TradeGood"> | string
    basePrice?: IntFilter<"TradeGood"> | number
    availability?: StringNullableFilter<"TradeGood"> | string | null
    legality?: StringNullableFilter<"TradeGood"> | string | null
    dtm?: IntFilter<"TradeGood"> | number
    planetId?: StringNullableFilter<"TradeGood"> | string | null
    planet?: XOR<PlanetNullableRelationFilter, PlanetWhereInput> | null
  }

  export type TradeGoodOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    basePrice?: SortOrder
    availability?: SortOrderInput | SortOrder
    legality?: SortOrderInput | SortOrder
    dtm?: SortOrder
    planetId?: SortOrderInput | SortOrder
    planet?: PlanetOrderByWithRelationInput
  }

  export type TradeGoodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TradeGoodWhereInput | TradeGoodWhereInput[]
    OR?: TradeGoodWhereInput[]
    NOT?: TradeGoodWhereInput | TradeGoodWhereInput[]
    name?: StringFilter<"TradeGood"> | string
    category?: StringFilter<"TradeGood"> | string
    basePrice?: IntFilter<"TradeGood"> | number
    availability?: StringNullableFilter<"TradeGood"> | string | null
    legality?: StringNullableFilter<"TradeGood"> | string | null
    dtm?: IntFilter<"TradeGood"> | number
    planetId?: StringNullableFilter<"TradeGood"> | string | null
    planet?: XOR<PlanetNullableRelationFilter, PlanetWhereInput> | null
  }, "id">

  export type TradeGoodOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    basePrice?: SortOrder
    availability?: SortOrderInput | SortOrder
    legality?: SortOrderInput | SortOrder
    dtm?: SortOrder
    planetId?: SortOrderInput | SortOrder
    _count?: TradeGoodCountOrderByAggregateInput
    _avg?: TradeGoodAvgOrderByAggregateInput
    _max?: TradeGoodMaxOrderByAggregateInput
    _min?: TradeGoodMinOrderByAggregateInput
    _sum?: TradeGoodSumOrderByAggregateInput
  }

  export type TradeGoodScalarWhereWithAggregatesInput = {
    AND?: TradeGoodScalarWhereWithAggregatesInput | TradeGoodScalarWhereWithAggregatesInput[]
    OR?: TradeGoodScalarWhereWithAggregatesInput[]
    NOT?: TradeGoodScalarWhereWithAggregatesInput | TradeGoodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TradeGood"> | string
    name?: StringWithAggregatesFilter<"TradeGood"> | string
    category?: StringWithAggregatesFilter<"TradeGood"> | string
    basePrice?: IntWithAggregatesFilter<"TradeGood"> | number
    availability?: StringNullableWithAggregatesFilter<"TradeGood"> | string | null
    legality?: StringNullableWithAggregatesFilter<"TradeGood"> | string | null
    dtm?: IntWithAggregatesFilter<"TradeGood"> | number
    planetId?: StringNullableWithAggregatesFilter<"TradeGood"> | string | null
  }

  export type TradeRouteWhereInput = {
    AND?: TradeRouteWhereInput | TradeRouteWhereInput[]
    OR?: TradeRouteWhereInput[]
    NOT?: TradeRouteWhereInput | TradeRouteWhereInput[]
    id?: StringFilter<"TradeRoute"> | string
    name?: StringFilter<"TradeRoute"> | string
    distance?: IntFilter<"TradeRoute"> | number
    difficulty?: IntFilter<"TradeRoute"> | number
    originId?: StringFilter<"TradeRoute"> | string
    destinationId?: StringFilter<"TradeRoute"> | string
    cargoTypes?: StringNullableListFilter<"TradeRoute">
    profitMargin?: FloatNullableFilter<"TradeRoute"> | number | null
    origin?: XOR<StarSystemRelationFilter, StarSystemWhereInput>
    destination?: XOR<StarSystemRelationFilter, StarSystemWhereInput>
  }

  export type TradeRouteOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    distance?: SortOrder
    difficulty?: SortOrder
    originId?: SortOrder
    destinationId?: SortOrder
    cargoTypes?: SortOrder
    profitMargin?: SortOrderInput | SortOrder
    origin?: StarSystemOrderByWithRelationInput
    destination?: StarSystemOrderByWithRelationInput
  }

  export type TradeRouteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    originId_destinationId?: TradeRouteOriginIdDestinationIdCompoundUniqueInput
    AND?: TradeRouteWhereInput | TradeRouteWhereInput[]
    OR?: TradeRouteWhereInput[]
    NOT?: TradeRouteWhereInput | TradeRouteWhereInput[]
    name?: StringFilter<"TradeRoute"> | string
    distance?: IntFilter<"TradeRoute"> | number
    difficulty?: IntFilter<"TradeRoute"> | number
    originId?: StringFilter<"TradeRoute"> | string
    destinationId?: StringFilter<"TradeRoute"> | string
    cargoTypes?: StringNullableListFilter<"TradeRoute">
    profitMargin?: FloatNullableFilter<"TradeRoute"> | number | null
    origin?: XOR<StarSystemRelationFilter, StarSystemWhereInput>
    destination?: XOR<StarSystemRelationFilter, StarSystemWhereInput>
  }, "id" | "originId_destinationId">

  export type TradeRouteOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    distance?: SortOrder
    difficulty?: SortOrder
    originId?: SortOrder
    destinationId?: SortOrder
    cargoTypes?: SortOrder
    profitMargin?: SortOrderInput | SortOrder
    _count?: TradeRouteCountOrderByAggregateInput
    _avg?: TradeRouteAvgOrderByAggregateInput
    _max?: TradeRouteMaxOrderByAggregateInput
    _min?: TradeRouteMinOrderByAggregateInput
    _sum?: TradeRouteSumOrderByAggregateInput
  }

  export type TradeRouteScalarWhereWithAggregatesInput = {
    AND?: TradeRouteScalarWhereWithAggregatesInput | TradeRouteScalarWhereWithAggregatesInput[]
    OR?: TradeRouteScalarWhereWithAggregatesInput[]
    NOT?: TradeRouteScalarWhereWithAggregatesInput | TradeRouteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TradeRoute"> | string
    name?: StringWithAggregatesFilter<"TradeRoute"> | string
    distance?: IntWithAggregatesFilter<"TradeRoute"> | number
    difficulty?: IntWithAggregatesFilter<"TradeRoute"> | number
    originId?: StringWithAggregatesFilter<"TradeRoute"> | string
    destinationId?: StringWithAggregatesFilter<"TradeRoute"> | string
    cargoTypes?: StringNullableListFilter<"TradeRoute">
    profitMargin?: FloatNullableWithAggregatesFilter<"TradeRoute"> | number | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    name?: StringFilter<"Session"> | string
    scheduledFor?: DateTimeNullableFilter<"Session"> | Date | string | null
    duration?: IntNullableFilter<"Session"> | number | null
    notes?: StringNullableFilter<"Session"> | string | null
    status?: EnumSessionStatusFilter<"Session"> | $Enums.SessionStatus
    campaignId?: StringFilter<"Session"> | string
    participants?: StringNullableListFilter<"Session">
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    encounters?: EncounterListRelationFilter
    combatSessions?: CombatSessionListRelationFilter
    sessionNotes?: SessionNoteListRelationFilter
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    campaignId?: SortOrder
    participants?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    encounters?: EncounterOrderByRelationAggregateInput
    combatSessions?: CombatSessionOrderByRelationAggregateInput
    sessionNotes?: SessionNoteOrderByRelationAggregateInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    name?: StringFilter<"Session"> | string
    scheduledFor?: DateTimeNullableFilter<"Session"> | Date | string | null
    duration?: IntNullableFilter<"Session"> | number | null
    notes?: StringNullableFilter<"Session"> | string | null
    status?: EnumSessionStatusFilter<"Session"> | $Enums.SessionStatus
    campaignId?: StringFilter<"Session"> | string
    participants?: StringNullableListFilter<"Session">
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    encounters?: EncounterListRelationFilter
    combatSessions?: CombatSessionListRelationFilter
    sessionNotes?: SessionNoteListRelationFilter
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    campaignId?: SortOrder
    participants?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    name?: StringWithAggregatesFilter<"Session"> | string
    scheduledFor?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"Session"> | number | null
    notes?: StringNullableWithAggregatesFilter<"Session"> | string | null
    status?: EnumSessionStatusWithAggregatesFilter<"Session"> | $Enums.SessionStatus
    campaignId?: StringWithAggregatesFilter<"Session"> | string
    participants?: StringNullableListFilter<"Session">
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type EncounterWhereInput = {
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    id?: StringFilter<"Encounter"> | string
    name?: StringFilter<"Encounter"> | string
    description?: StringNullableFilter<"Encounter"> | string | null
    encounterType?: StringFilter<"Encounter"> | string
    difficulty?: IntNullableFilter<"Encounter"> | number | null
    location?: StringNullableFilter<"Encounter"> | string | null
    environment?: JsonNullableFilter<"Encounter">
    npcs?: JsonNullableFilter<"Encounter">
    rewards?: JsonNullableFilter<"Encounter">
    status?: StringFilter<"Encounter"> | string
    outcome?: StringNullableFilter<"Encounter"> | string | null
    campaignId?: StringFilter<"Encounter"> | string
    sessionId?: StringNullableFilter<"Encounter"> | string | null
    createdAt?: DateTimeFilter<"Encounter"> | Date | string
    updatedAt?: DateTimeFilter<"Encounter"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    session?: XOR<SessionNullableRelationFilter, SessionWhereInput> | null
    combatSessions?: CombatSessionListRelationFilter
  }

  export type EncounterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    encounterType?: SortOrder
    difficulty?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    environment?: SortOrderInput | SortOrder
    npcs?: SortOrderInput | SortOrder
    rewards?: SortOrderInput | SortOrder
    status?: SortOrder
    outcome?: SortOrderInput | SortOrder
    campaignId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    session?: SessionOrderByWithRelationInput
    combatSessions?: CombatSessionOrderByRelationAggregateInput
  }

  export type EncounterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    name?: StringFilter<"Encounter"> | string
    description?: StringNullableFilter<"Encounter"> | string | null
    encounterType?: StringFilter<"Encounter"> | string
    difficulty?: IntNullableFilter<"Encounter"> | number | null
    location?: StringNullableFilter<"Encounter"> | string | null
    environment?: JsonNullableFilter<"Encounter">
    npcs?: JsonNullableFilter<"Encounter">
    rewards?: JsonNullableFilter<"Encounter">
    status?: StringFilter<"Encounter"> | string
    outcome?: StringNullableFilter<"Encounter"> | string | null
    campaignId?: StringFilter<"Encounter"> | string
    sessionId?: StringNullableFilter<"Encounter"> | string | null
    createdAt?: DateTimeFilter<"Encounter"> | Date | string
    updatedAt?: DateTimeFilter<"Encounter"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    session?: XOR<SessionNullableRelationFilter, SessionWhereInput> | null
    combatSessions?: CombatSessionListRelationFilter
  }, "id">

  export type EncounterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    encounterType?: SortOrder
    difficulty?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    environment?: SortOrderInput | SortOrder
    npcs?: SortOrderInput | SortOrder
    rewards?: SortOrderInput | SortOrder
    status?: SortOrder
    outcome?: SortOrderInput | SortOrder
    campaignId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EncounterCountOrderByAggregateInput
    _avg?: EncounterAvgOrderByAggregateInput
    _max?: EncounterMaxOrderByAggregateInput
    _min?: EncounterMinOrderByAggregateInput
    _sum?: EncounterSumOrderByAggregateInput
  }

  export type EncounterScalarWhereWithAggregatesInput = {
    AND?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    OR?: EncounterScalarWhereWithAggregatesInput[]
    NOT?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Encounter"> | string
    name?: StringWithAggregatesFilter<"Encounter"> | string
    description?: StringNullableWithAggregatesFilter<"Encounter"> | string | null
    encounterType?: StringWithAggregatesFilter<"Encounter"> | string
    difficulty?: IntNullableWithAggregatesFilter<"Encounter"> | number | null
    location?: StringNullableWithAggregatesFilter<"Encounter"> | string | null
    environment?: JsonNullableWithAggregatesFilter<"Encounter">
    npcs?: JsonNullableWithAggregatesFilter<"Encounter">
    rewards?: JsonNullableWithAggregatesFilter<"Encounter">
    status?: StringWithAggregatesFilter<"Encounter"> | string
    outcome?: StringNullableWithAggregatesFilter<"Encounter"> | string | null
    campaignId?: StringWithAggregatesFilter<"Encounter"> | string
    sessionId?: StringNullableWithAggregatesFilter<"Encounter"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Encounter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Encounter"> | Date | string
  }

  export type CombatSessionWhereInput = {
    AND?: CombatSessionWhereInput | CombatSessionWhereInput[]
    OR?: CombatSessionWhereInput[]
    NOT?: CombatSessionWhereInput | CombatSessionWhereInput[]
    id?: StringFilter<"CombatSession"> | string
    name?: StringNullableFilter<"CombatSession"> | string | null
    round?: IntFilter<"CombatSession"> | number
    phase?: StringFilter<"CombatSession"> | string
    status?: StringFilter<"CombatSession"> | string
    initiative?: JsonNullableFilter<"CombatSession">
    encounterId?: StringNullableFilter<"CombatSession"> | string | null
    sessionId?: StringNullableFilter<"CombatSession"> | string | null
    createdAt?: DateTimeFilter<"CombatSession"> | Date | string
    updatedAt?: DateTimeFilter<"CombatSession"> | Date | string
    encounter?: XOR<EncounterNullableRelationFilter, EncounterWhereInput> | null
    session?: XOR<SessionNullableRelationFilter, SessionWhereInput> | null
    actions?: CombatActionListRelationFilter
  }

  export type CombatSessionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    round?: SortOrder
    phase?: SortOrder
    status?: SortOrder
    initiative?: SortOrderInput | SortOrder
    encounterId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
    session?: SessionOrderByWithRelationInput
    actions?: CombatActionOrderByRelationAggregateInput
  }

  export type CombatSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CombatSessionWhereInput | CombatSessionWhereInput[]
    OR?: CombatSessionWhereInput[]
    NOT?: CombatSessionWhereInput | CombatSessionWhereInput[]
    name?: StringNullableFilter<"CombatSession"> | string | null
    round?: IntFilter<"CombatSession"> | number
    phase?: StringFilter<"CombatSession"> | string
    status?: StringFilter<"CombatSession"> | string
    initiative?: JsonNullableFilter<"CombatSession">
    encounterId?: StringNullableFilter<"CombatSession"> | string | null
    sessionId?: StringNullableFilter<"CombatSession"> | string | null
    createdAt?: DateTimeFilter<"CombatSession"> | Date | string
    updatedAt?: DateTimeFilter<"CombatSession"> | Date | string
    encounter?: XOR<EncounterNullableRelationFilter, EncounterWhereInput> | null
    session?: XOR<SessionNullableRelationFilter, SessionWhereInput> | null
    actions?: CombatActionListRelationFilter
  }, "id">

  export type CombatSessionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    round?: SortOrder
    phase?: SortOrder
    status?: SortOrder
    initiative?: SortOrderInput | SortOrder
    encounterId?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CombatSessionCountOrderByAggregateInput
    _avg?: CombatSessionAvgOrderByAggregateInput
    _max?: CombatSessionMaxOrderByAggregateInput
    _min?: CombatSessionMinOrderByAggregateInput
    _sum?: CombatSessionSumOrderByAggregateInput
  }

  export type CombatSessionScalarWhereWithAggregatesInput = {
    AND?: CombatSessionScalarWhereWithAggregatesInput | CombatSessionScalarWhereWithAggregatesInput[]
    OR?: CombatSessionScalarWhereWithAggregatesInput[]
    NOT?: CombatSessionScalarWhereWithAggregatesInput | CombatSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CombatSession"> | string
    name?: StringNullableWithAggregatesFilter<"CombatSession"> | string | null
    round?: IntWithAggregatesFilter<"CombatSession"> | number
    phase?: StringWithAggregatesFilter<"CombatSession"> | string
    status?: StringWithAggregatesFilter<"CombatSession"> | string
    initiative?: JsonNullableWithAggregatesFilter<"CombatSession">
    encounterId?: StringNullableWithAggregatesFilter<"CombatSession"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"CombatSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CombatSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CombatSession"> | Date | string
  }

  export type CombatActionWhereInput = {
    AND?: CombatActionWhereInput | CombatActionWhereInput[]
    OR?: CombatActionWhereInput[]
    NOT?: CombatActionWhereInput | CombatActionWhereInput[]
    id?: StringFilter<"CombatAction"> | string
    actionType?: StringFilter<"CombatAction"> | string
    description?: StringNullableFilter<"CombatAction"> | string | null
    target?: StringNullableFilter<"CombatAction"> | string | null
    result?: JsonNullableFilter<"CombatAction">
    diceRolled?: StringNullableFilter<"CombatAction"> | string | null
    rollResult?: IntNullableFilter<"CombatAction"> | number | null
    modifiers?: JsonNullableFilter<"CombatAction">
    characterId?: StringNullableFilter<"CombatAction"> | string | null
    combatSessionId?: StringFilter<"CombatAction"> | string
    round?: IntFilter<"CombatAction"> | number
    timestamp?: DateTimeFilter<"CombatAction"> | Date | string
    character?: XOR<CharacterNullableRelationFilter, CharacterWhereInput> | null
    combatSession?: XOR<CombatSessionRelationFilter, CombatSessionWhereInput>
  }

  export type CombatActionOrderByWithRelationInput = {
    id?: SortOrder
    actionType?: SortOrder
    description?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    diceRolled?: SortOrderInput | SortOrder
    rollResult?: SortOrderInput | SortOrder
    modifiers?: SortOrderInput | SortOrder
    characterId?: SortOrderInput | SortOrder
    combatSessionId?: SortOrder
    round?: SortOrder
    timestamp?: SortOrder
    character?: CharacterOrderByWithRelationInput
    combatSession?: CombatSessionOrderByWithRelationInput
  }

  export type CombatActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CombatActionWhereInput | CombatActionWhereInput[]
    OR?: CombatActionWhereInput[]
    NOT?: CombatActionWhereInput | CombatActionWhereInput[]
    actionType?: StringFilter<"CombatAction"> | string
    description?: StringNullableFilter<"CombatAction"> | string | null
    target?: StringNullableFilter<"CombatAction"> | string | null
    result?: JsonNullableFilter<"CombatAction">
    diceRolled?: StringNullableFilter<"CombatAction"> | string | null
    rollResult?: IntNullableFilter<"CombatAction"> | number | null
    modifiers?: JsonNullableFilter<"CombatAction">
    characterId?: StringNullableFilter<"CombatAction"> | string | null
    combatSessionId?: StringFilter<"CombatAction"> | string
    round?: IntFilter<"CombatAction"> | number
    timestamp?: DateTimeFilter<"CombatAction"> | Date | string
    character?: XOR<CharacterNullableRelationFilter, CharacterWhereInput> | null
    combatSession?: XOR<CombatSessionRelationFilter, CombatSessionWhereInput>
  }, "id">

  export type CombatActionOrderByWithAggregationInput = {
    id?: SortOrder
    actionType?: SortOrder
    description?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    diceRolled?: SortOrderInput | SortOrder
    rollResult?: SortOrderInput | SortOrder
    modifiers?: SortOrderInput | SortOrder
    characterId?: SortOrderInput | SortOrder
    combatSessionId?: SortOrder
    round?: SortOrder
    timestamp?: SortOrder
    _count?: CombatActionCountOrderByAggregateInput
    _avg?: CombatActionAvgOrderByAggregateInput
    _max?: CombatActionMaxOrderByAggregateInput
    _min?: CombatActionMinOrderByAggregateInput
    _sum?: CombatActionSumOrderByAggregateInput
  }

  export type CombatActionScalarWhereWithAggregatesInput = {
    AND?: CombatActionScalarWhereWithAggregatesInput | CombatActionScalarWhereWithAggregatesInput[]
    OR?: CombatActionScalarWhereWithAggregatesInput[]
    NOT?: CombatActionScalarWhereWithAggregatesInput | CombatActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CombatAction"> | string
    actionType?: StringWithAggregatesFilter<"CombatAction"> | string
    description?: StringNullableWithAggregatesFilter<"CombatAction"> | string | null
    target?: StringNullableWithAggregatesFilter<"CombatAction"> | string | null
    result?: JsonNullableWithAggregatesFilter<"CombatAction">
    diceRolled?: StringNullableWithAggregatesFilter<"CombatAction"> | string | null
    rollResult?: IntNullableWithAggregatesFilter<"CombatAction"> | number | null
    modifiers?: JsonNullableWithAggregatesFilter<"CombatAction">
    characterId?: StringNullableWithAggregatesFilter<"CombatAction"> | string | null
    combatSessionId?: StringWithAggregatesFilter<"CombatAction"> | string
    round?: IntWithAggregatesFilter<"CombatAction"> | number
    timestamp?: DateTimeWithAggregatesFilter<"CombatAction"> | Date | string
  }

  export type DiceRollWhereInput = {
    AND?: DiceRollWhereInput | DiceRollWhereInput[]
    OR?: DiceRollWhereInput[]
    NOT?: DiceRollWhereInput | DiceRollWhereInput[]
    id?: StringFilter<"DiceRoll"> | string
    dice?: StringFilter<"DiceRoll"> | string
    result?: IntFilter<"DiceRoll"> | number
    individual?: IntNullableListFilter<"DiceRoll">
    modifiers?: StringNullableListFilter<"DiceRoll">
    description?: StringNullableFilter<"DiceRoll"> | string | null
    isPublic?: BoolFilter<"DiceRoll"> | boolean
    isGMOnly?: BoolFilter<"DiceRoll"> | boolean
    rollerId?: StringFilter<"DiceRoll"> | string
    campaignId?: StringFilter<"DiceRoll"> | string
    character?: StringNullableFilter<"DiceRoll"> | string | null
    skill?: StringNullableFilter<"DiceRoll"> | string | null
    timestamp?: DateTimeFilter<"DiceRoll"> | Date | string
    roller?: XOR<UserRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type DiceRollOrderByWithRelationInput = {
    id?: SortOrder
    dice?: SortOrder
    result?: SortOrder
    individual?: SortOrder
    modifiers?: SortOrder
    description?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    isGMOnly?: SortOrder
    rollerId?: SortOrder
    campaignId?: SortOrder
    character?: SortOrderInput | SortOrder
    skill?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    roller?: UserOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
  }

  export type DiceRollWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DiceRollWhereInput | DiceRollWhereInput[]
    OR?: DiceRollWhereInput[]
    NOT?: DiceRollWhereInput | DiceRollWhereInput[]
    dice?: StringFilter<"DiceRoll"> | string
    result?: IntFilter<"DiceRoll"> | number
    individual?: IntNullableListFilter<"DiceRoll">
    modifiers?: StringNullableListFilter<"DiceRoll">
    description?: StringNullableFilter<"DiceRoll"> | string | null
    isPublic?: BoolFilter<"DiceRoll"> | boolean
    isGMOnly?: BoolFilter<"DiceRoll"> | boolean
    rollerId?: StringFilter<"DiceRoll"> | string
    campaignId?: StringFilter<"DiceRoll"> | string
    character?: StringNullableFilter<"DiceRoll"> | string | null
    skill?: StringNullableFilter<"DiceRoll"> | string | null
    timestamp?: DateTimeFilter<"DiceRoll"> | Date | string
    roller?: XOR<UserRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type DiceRollOrderByWithAggregationInput = {
    id?: SortOrder
    dice?: SortOrder
    result?: SortOrder
    individual?: SortOrder
    modifiers?: SortOrder
    description?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    isGMOnly?: SortOrder
    rollerId?: SortOrder
    campaignId?: SortOrder
    character?: SortOrderInput | SortOrder
    skill?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: DiceRollCountOrderByAggregateInput
    _avg?: DiceRollAvgOrderByAggregateInput
    _max?: DiceRollMaxOrderByAggregateInput
    _min?: DiceRollMinOrderByAggregateInput
    _sum?: DiceRollSumOrderByAggregateInput
  }

  export type DiceRollScalarWhereWithAggregatesInput = {
    AND?: DiceRollScalarWhereWithAggregatesInput | DiceRollScalarWhereWithAggregatesInput[]
    OR?: DiceRollScalarWhereWithAggregatesInput[]
    NOT?: DiceRollScalarWhereWithAggregatesInput | DiceRollScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DiceRoll"> | string
    dice?: StringWithAggregatesFilter<"DiceRoll"> | string
    result?: IntWithAggregatesFilter<"DiceRoll"> | number
    individual?: IntNullableListFilter<"DiceRoll">
    modifiers?: StringNullableListFilter<"DiceRoll">
    description?: StringNullableWithAggregatesFilter<"DiceRoll"> | string | null
    isPublic?: BoolWithAggregatesFilter<"DiceRoll"> | boolean
    isGMOnly?: BoolWithAggregatesFilter<"DiceRoll"> | boolean
    rollerId?: StringWithAggregatesFilter<"DiceRoll"> | string
    campaignId?: StringWithAggregatesFilter<"DiceRoll"> | string
    character?: StringNullableWithAggregatesFilter<"DiceRoll"> | string | null
    skill?: StringNullableWithAggregatesFilter<"DiceRoll"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"DiceRoll"> | Date | string
  }

  export type CustomContentWhereInput = {
    AND?: CustomContentWhereInput | CustomContentWhereInput[]
    OR?: CustomContentWhereInput[]
    NOT?: CustomContentWhereInput | CustomContentWhereInput[]
    id?: StringFilter<"CustomContent"> | string
    title?: StringFilter<"CustomContent"> | string
    description?: StringNullableFilter<"CustomContent"> | string | null
    contentType?: StringFilter<"CustomContent"> | string
    category?: StringNullableFilter<"CustomContent"> | string | null
    data?: JsonFilter<"CustomContent">
    tags?: StringNullableListFilter<"CustomContent">
    isPublic?: BoolFilter<"CustomContent"> | boolean
    isOfficial?: BoolFilter<"CustomContent"> | boolean
    authorId?: StringFilter<"CustomContent"> | string
    campaignId?: StringNullableFilter<"CustomContent"> | string | null
    createdAt?: DateTimeFilter<"CustomContent"> | Date | string
    updatedAt?: DateTimeFilter<"CustomContent"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignNullableRelationFilter, CampaignWhereInput> | null
  }

  export type CustomContentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    contentType?: SortOrder
    category?: SortOrderInput | SortOrder
    data?: SortOrder
    tags?: SortOrder
    isPublic?: SortOrder
    isOfficial?: SortOrder
    authorId?: SortOrder
    campaignId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CustomContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomContentWhereInput | CustomContentWhereInput[]
    OR?: CustomContentWhereInput[]
    NOT?: CustomContentWhereInput | CustomContentWhereInput[]
    title?: StringFilter<"CustomContent"> | string
    description?: StringNullableFilter<"CustomContent"> | string | null
    contentType?: StringFilter<"CustomContent"> | string
    category?: StringNullableFilter<"CustomContent"> | string | null
    data?: JsonFilter<"CustomContent">
    tags?: StringNullableListFilter<"CustomContent">
    isPublic?: BoolFilter<"CustomContent"> | boolean
    isOfficial?: BoolFilter<"CustomContent"> | boolean
    authorId?: StringFilter<"CustomContent"> | string
    campaignId?: StringNullableFilter<"CustomContent"> | string | null
    createdAt?: DateTimeFilter<"CustomContent"> | Date | string
    updatedAt?: DateTimeFilter<"CustomContent"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignNullableRelationFilter, CampaignWhereInput> | null
  }, "id">

  export type CustomContentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    contentType?: SortOrder
    category?: SortOrderInput | SortOrder
    data?: SortOrder
    tags?: SortOrder
    isPublic?: SortOrder
    isOfficial?: SortOrder
    authorId?: SortOrder
    campaignId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomContentCountOrderByAggregateInput
    _max?: CustomContentMaxOrderByAggregateInput
    _min?: CustomContentMinOrderByAggregateInput
  }

  export type CustomContentScalarWhereWithAggregatesInput = {
    AND?: CustomContentScalarWhereWithAggregatesInput | CustomContentScalarWhereWithAggregatesInput[]
    OR?: CustomContentScalarWhereWithAggregatesInput[]
    NOT?: CustomContentScalarWhereWithAggregatesInput | CustomContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomContent"> | string
    title?: StringWithAggregatesFilter<"CustomContent"> | string
    description?: StringNullableWithAggregatesFilter<"CustomContent"> | string | null
    contentType?: StringWithAggregatesFilter<"CustomContent"> | string
    category?: StringNullableWithAggregatesFilter<"CustomContent"> | string | null
    data?: JsonWithAggregatesFilter<"CustomContent">
    tags?: StringNullableListFilter<"CustomContent">
    isPublic?: BoolWithAggregatesFilter<"CustomContent"> | boolean
    isOfficial?: BoolWithAggregatesFilter<"CustomContent"> | boolean
    authorId?: StringWithAggregatesFilter<"CustomContent"> | string
    campaignId?: StringNullableWithAggregatesFilter<"CustomContent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CustomContent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomContent"> | Date | string
  }

  export type HouseRuleWhereInput = {
    AND?: HouseRuleWhereInput | HouseRuleWhereInput[]
    OR?: HouseRuleWhereInput[]
    NOT?: HouseRuleWhereInput | HouseRuleWhereInput[]
    id?: StringFilter<"HouseRule"> | string
    title?: StringFilter<"HouseRule"> | string
    description?: StringFilter<"HouseRule"> | string
    category?: StringFilter<"HouseRule"> | string
    ruleText?: StringFilter<"HouseRule"> | string
    pageReference?: StringNullableFilter<"HouseRule"> | string | null
    replaces?: StringNullableFilter<"HouseRule"> | string | null
    isActive?: BoolFilter<"HouseRule"> | boolean
    campaignId?: StringFilter<"HouseRule"> | string
    createdAt?: DateTimeFilter<"HouseRule"> | Date | string
    updatedAt?: DateTimeFilter<"HouseRule"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type HouseRuleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    ruleText?: SortOrder
    pageReference?: SortOrderInput | SortOrder
    replaces?: SortOrderInput | SortOrder
    isActive?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type HouseRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HouseRuleWhereInput | HouseRuleWhereInput[]
    OR?: HouseRuleWhereInput[]
    NOT?: HouseRuleWhereInput | HouseRuleWhereInput[]
    title?: StringFilter<"HouseRule"> | string
    description?: StringFilter<"HouseRule"> | string
    category?: StringFilter<"HouseRule"> | string
    ruleText?: StringFilter<"HouseRule"> | string
    pageReference?: StringNullableFilter<"HouseRule"> | string | null
    replaces?: StringNullableFilter<"HouseRule"> | string | null
    isActive?: BoolFilter<"HouseRule"> | boolean
    campaignId?: StringFilter<"HouseRule"> | string
    createdAt?: DateTimeFilter<"HouseRule"> | Date | string
    updatedAt?: DateTimeFilter<"HouseRule"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type HouseRuleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    ruleText?: SortOrder
    pageReference?: SortOrderInput | SortOrder
    replaces?: SortOrderInput | SortOrder
    isActive?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HouseRuleCountOrderByAggregateInput
    _max?: HouseRuleMaxOrderByAggregateInput
    _min?: HouseRuleMinOrderByAggregateInput
  }

  export type HouseRuleScalarWhereWithAggregatesInput = {
    AND?: HouseRuleScalarWhereWithAggregatesInput | HouseRuleScalarWhereWithAggregatesInput[]
    OR?: HouseRuleScalarWhereWithAggregatesInput[]
    NOT?: HouseRuleScalarWhereWithAggregatesInput | HouseRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HouseRule"> | string
    title?: StringWithAggregatesFilter<"HouseRule"> | string
    description?: StringWithAggregatesFilter<"HouseRule"> | string
    category?: StringWithAggregatesFilter<"HouseRule"> | string
    ruleText?: StringWithAggregatesFilter<"HouseRule"> | string
    pageReference?: StringNullableWithAggregatesFilter<"HouseRule"> | string | null
    replaces?: StringNullableWithAggregatesFilter<"HouseRule"> | string | null
    isActive?: BoolWithAggregatesFilter<"HouseRule"> | boolean
    campaignId?: StringWithAggregatesFilter<"HouseRule"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HouseRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HouseRule"> | Date | string
  }

  export type HandoutWhereInput = {
    AND?: HandoutWhereInput | HandoutWhereInput[]
    OR?: HandoutWhereInput[]
    NOT?: HandoutWhereInput | HandoutWhereInput[]
    id?: StringFilter<"Handout"> | string
    title?: StringFilter<"Handout"> | string
    description?: StringNullableFilter<"Handout"> | string | null
    content?: StringNullableFilter<"Handout"> | string | null
    imageUrl?: StringNullableFilter<"Handout"> | string | null
    fileUrl?: StringNullableFilter<"Handout"> | string | null
    isPlayerVisible?: BoolFilter<"Handout"> | boolean
    recipients?: StringNullableListFilter<"Handout">
    authorId?: StringFilter<"Handout"> | string
    campaignId?: StringFilter<"Handout"> | string
    createdAt?: DateTimeFilter<"Handout"> | Date | string
    updatedAt?: DateTimeFilter<"Handout"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type HandoutOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    isPlayerVisible?: SortOrder
    recipients?: SortOrder
    authorId?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
  }

  export type HandoutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HandoutWhereInput | HandoutWhereInput[]
    OR?: HandoutWhereInput[]
    NOT?: HandoutWhereInput | HandoutWhereInput[]
    title?: StringFilter<"Handout"> | string
    description?: StringNullableFilter<"Handout"> | string | null
    content?: StringNullableFilter<"Handout"> | string | null
    imageUrl?: StringNullableFilter<"Handout"> | string | null
    fileUrl?: StringNullableFilter<"Handout"> | string | null
    isPlayerVisible?: BoolFilter<"Handout"> | boolean
    recipients?: StringNullableListFilter<"Handout">
    authorId?: StringFilter<"Handout"> | string
    campaignId?: StringFilter<"Handout"> | string
    createdAt?: DateTimeFilter<"Handout"> | Date | string
    updatedAt?: DateTimeFilter<"Handout"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type HandoutOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    isPlayerVisible?: SortOrder
    recipients?: SortOrder
    authorId?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HandoutCountOrderByAggregateInput
    _max?: HandoutMaxOrderByAggregateInput
    _min?: HandoutMinOrderByAggregateInput
  }

  export type HandoutScalarWhereWithAggregatesInput = {
    AND?: HandoutScalarWhereWithAggregatesInput | HandoutScalarWhereWithAggregatesInput[]
    OR?: HandoutScalarWhereWithAggregatesInput[]
    NOT?: HandoutScalarWhereWithAggregatesInput | HandoutScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Handout"> | string
    title?: StringWithAggregatesFilter<"Handout"> | string
    description?: StringNullableWithAggregatesFilter<"Handout"> | string | null
    content?: StringNullableWithAggregatesFilter<"Handout"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Handout"> | string | null
    fileUrl?: StringNullableWithAggregatesFilter<"Handout"> | string | null
    isPlayerVisible?: BoolWithAggregatesFilter<"Handout"> | boolean
    recipients?: StringNullableListFilter<"Handout">
    authorId?: StringWithAggregatesFilter<"Handout"> | string
    campaignId?: StringWithAggregatesFilter<"Handout"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Handout"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Handout"> | Date | string
  }

  export type SessionNoteWhereInput = {
    AND?: SessionNoteWhereInput | SessionNoteWhereInput[]
    OR?: SessionNoteWhereInput[]
    NOT?: SessionNoteWhereInput | SessionNoteWhereInput[]
    id?: StringFilter<"SessionNote"> | string
    title?: StringNullableFilter<"SessionNote"> | string | null
    content?: StringFilter<"SessionNote"> | string
    noteType?: StringFilter<"SessionNote"> | string
    tags?: StringNullableListFilter<"SessionNote">
    isPublic?: BoolFilter<"SessionNote"> | boolean
    authorId?: StringFilter<"SessionNote"> | string
    campaignId?: StringFilter<"SessionNote"> | string
    sessionId?: StringNullableFilter<"SessionNote"> | string | null
    createdAt?: DateTimeFilter<"SessionNote"> | Date | string
    updatedAt?: DateTimeFilter<"SessionNote"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    session?: XOR<SessionNullableRelationFilter, SessionWhereInput> | null
  }

  export type SessionNoteOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    noteType?: SortOrder
    tags?: SortOrder
    isPublic?: SortOrder
    authorId?: SortOrder
    campaignId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
    session?: SessionOrderByWithRelationInput
  }

  export type SessionNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionNoteWhereInput | SessionNoteWhereInput[]
    OR?: SessionNoteWhereInput[]
    NOT?: SessionNoteWhereInput | SessionNoteWhereInput[]
    title?: StringNullableFilter<"SessionNote"> | string | null
    content?: StringFilter<"SessionNote"> | string
    noteType?: StringFilter<"SessionNote"> | string
    tags?: StringNullableListFilter<"SessionNote">
    isPublic?: BoolFilter<"SessionNote"> | boolean
    authorId?: StringFilter<"SessionNote"> | string
    campaignId?: StringFilter<"SessionNote"> | string
    sessionId?: StringNullableFilter<"SessionNote"> | string | null
    createdAt?: DateTimeFilter<"SessionNote"> | Date | string
    updatedAt?: DateTimeFilter<"SessionNote"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    session?: XOR<SessionNullableRelationFilter, SessionWhereInput> | null
  }, "id">

  export type SessionNoteOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    noteType?: SortOrder
    tags?: SortOrder
    isPublic?: SortOrder
    authorId?: SortOrder
    campaignId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionNoteCountOrderByAggregateInput
    _max?: SessionNoteMaxOrderByAggregateInput
    _min?: SessionNoteMinOrderByAggregateInput
  }

  export type SessionNoteScalarWhereWithAggregatesInput = {
    AND?: SessionNoteScalarWhereWithAggregatesInput | SessionNoteScalarWhereWithAggregatesInput[]
    OR?: SessionNoteScalarWhereWithAggregatesInput[]
    NOT?: SessionNoteScalarWhereWithAggregatesInput | SessionNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SessionNote"> | string
    title?: StringNullableWithAggregatesFilter<"SessionNote"> | string | null
    content?: StringWithAggregatesFilter<"SessionNote"> | string
    noteType?: StringWithAggregatesFilter<"SessionNote"> | string
    tags?: StringNullableListFilter<"SessionNote">
    isPublic?: BoolWithAggregatesFilter<"SessionNote"> | boolean
    authorId?: StringWithAggregatesFilter<"SessionNote"> | string
    campaignId?: StringWithAggregatesFilter<"SessionNote"> | string
    sessionId?: StringNullableWithAggregatesFilter<"SessionNote"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SessionNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SessionNote"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    displayName?: string | null
    avatar?: string | null
    timezone?: string
    subscriptionTier?: $Enums.SubscriptionTier
    cognitoUserId: string
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ownedCampaigns?: CampaignCreateNestedManyWithoutGamemasterInput
    campaignMembers?: CampaignMemberCreateNestedManyWithoutUserInput
    characters?: CharacterCreateNestedManyWithoutPlayerInput
    diceRolls?: DiceRollCreateNestedManyWithoutRollerInput
    customContent?: CustomContentCreateNestedManyWithoutAuthorInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutAuthorInput
    handouts?: HandoutCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    displayName?: string | null
    avatar?: string | null
    timezone?: string
    subscriptionTier?: $Enums.SubscriptionTier
    cognitoUserId: string
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ownedCampaigns?: CampaignUncheckedCreateNestedManyWithoutGamemasterInput
    campaignMembers?: CampaignMemberUncheckedCreateNestedManyWithoutUserInput
    characters?: CharacterUncheckedCreateNestedManyWithoutPlayerInput
    diceRolls?: DiceRollUncheckedCreateNestedManyWithoutRollerInput
    customContent?: CustomContentUncheckedCreateNestedManyWithoutAuthorInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutAuthorInput
    handouts?: HandoutUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownedCampaigns?: CampaignUpdateManyWithoutGamemasterNestedInput
    campaignMembers?: CampaignMemberUpdateManyWithoutUserNestedInput
    characters?: CharacterUpdateManyWithoutPlayerNestedInput
    diceRolls?: DiceRollUpdateManyWithoutRollerNestedInput
    customContent?: CustomContentUpdateManyWithoutAuthorNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutAuthorNestedInput
    handouts?: HandoutUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownedCampaigns?: CampaignUncheckedUpdateManyWithoutGamemasterNestedInput
    campaignMembers?: CampaignMemberUncheckedUpdateManyWithoutUserNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutPlayerNestedInput
    diceRolls?: DiceRollUncheckedUpdateManyWithoutRollerNestedInput
    customContent?: CustomContentUncheckedUpdateManyWithoutAuthorNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutAuthorNestedInput
    handouts?: HandoutUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    displayName?: string | null
    avatar?: string | null
    timezone?: string
    subscriptionTier?: $Enums.SubscriptionTier
    cognitoUserId: string
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    gamemaster: UserCreateNestedOneWithoutOwnedCampaignsInput
    members?: CampaignMemberCreateNestedManyWithoutCampaignInput
    characters?: CharacterCreateNestedManyWithoutCampaignInput
    sessions?: SessionCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemCreateNestedManyWithoutCampaignInput
    starships?: StarshipCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleCreateNestedManyWithoutCampaignInput
    handouts?: HandoutCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CampaignMemberUncheckedCreateNestedManyWithoutCampaignInput
    characters?: CharacterUncheckedCreateNestedManyWithoutCampaignInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemUncheckedCreateNestedManyWithoutCampaignInput
    starships?: StarshipUncheckedCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentUncheckedCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleUncheckedCreateNestedManyWithoutCampaignInput
    handouts?: HandoutUncheckedCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamemaster?: UserUpdateOneRequiredWithoutOwnedCampaignsNestedInput
    members?: CampaignMemberUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CampaignMemberUncheckedUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUncheckedUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUncheckedUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUncheckedUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUncheckedUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUncheckedUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMemberCreateInput = {
    id?: string
    role?: $Enums.CampaignRole
    isActive?: boolean
    joinedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutCampaignMembersInput
  }

  export type CampaignMemberUncheckedCreateInput = {
    id?: string
    campaignId: string
    userId: string
    role?: $Enums.CampaignRole
    isActive?: boolean
    joinedAt?: Date | string
  }

  export type CampaignMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumCampaignRoleFieldUpdateOperationsInput | $Enums.CampaignRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignMembersNestedInput
  }

  export type CampaignMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumCampaignRoleFieldUpdateOperationsInput | $Enums.CampaignRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMemberCreateManyInput = {
    id?: string
    campaignId: string
    userId: string
    role?: $Enums.CampaignRole
    isActive?: boolean
    joinedAt?: Date | string
  }

  export type CampaignMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumCampaignRoleFieldUpdateOperationsInput | $Enums.CampaignRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumCampaignRoleFieldUpdateOperationsInput | $Enums.CampaignRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterCreateInput = {
    id?: string
    name: string
    credits?: number
    notes?: string | null
    portrait?: string | null
    homeworld?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: UserCreateNestedOneWithoutCharactersInput
    campaign: CampaignCreateNestedOneWithoutCharactersInput
    characteristics?: CharacteristicsCreateNestedOneWithoutCharacterInput
    skills?: CharacterSkillCreateNestedManyWithoutCharacterInput
    equipment?: CharacterEquipmentCreateNestedManyWithoutCharacterInput
    lifeEvents?: LifeEventCreateNestedManyWithoutCharacterInput
    combatActions?: CombatActionCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateInput = {
    id?: string
    name: string
    credits?: number
    notes?: string | null
    portrait?: string | null
    homeworld?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    playerId: string
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    characteristics?: CharacteristicsUncheckedCreateNestedOneWithoutCharacterInput
    skills?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    equipment?: CharacterEquipmentUncheckedCreateNestedManyWithoutCharacterInput
    lifeEvents?: LifeEventUncheckedCreateNestedManyWithoutCharacterInput
    combatActions?: CombatActionUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: UserUpdateOneRequiredWithoutCharactersNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutCharactersNestedInput
    characteristics?: CharacteristicsUpdateOneWithoutCharacterNestedInput
    skills?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    equipment?: CharacterEquipmentUpdateManyWithoutCharacterNestedInput
    lifeEvents?: LifeEventUpdateManyWithoutCharacterNestedInput
    combatActions?: CombatActionUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    playerId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characteristics?: CharacteristicsUncheckedUpdateOneWithoutCharacterNestedInput
    skills?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    equipment?: CharacterEquipmentUncheckedUpdateManyWithoutCharacterNestedInput
    lifeEvents?: LifeEventUncheckedUpdateManyWithoutCharacterNestedInput
    combatActions?: CombatActionUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterCreateManyInput = {
    id?: string
    name: string
    credits?: number
    notes?: string | null
    portrait?: string | null
    homeworld?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    playerId: string
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    playerId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacteristicsCreateInput = {
    id?: string
    strength?: number
    dexterity?: number
    endurance?: number
    intelligence?: number
    education?: number
    socialStanding?: number
    physicalDamage?: number | null
    mentalDamage?: number | null
    character: CharacterCreateNestedOneWithoutCharacteristicsInput
  }

  export type CharacteristicsUncheckedCreateInput = {
    id?: string
    strength?: number
    dexterity?: number
    endurance?: number
    intelligence?: number
    education?: number
    socialStanding?: number
    physicalDamage?: number | null
    mentalDamage?: number | null
    characterId: string
  }

  export type CharacteristicsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    endurance?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    education?: IntFieldUpdateOperationsInput | number
    socialStanding?: IntFieldUpdateOperationsInput | number
    physicalDamage?: NullableIntFieldUpdateOperationsInput | number | null
    mentalDamage?: NullableIntFieldUpdateOperationsInput | number | null
    character?: CharacterUpdateOneRequiredWithoutCharacteristicsNestedInput
  }

  export type CharacteristicsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    endurance?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    education?: IntFieldUpdateOperationsInput | number
    socialStanding?: IntFieldUpdateOperationsInput | number
    physicalDamage?: NullableIntFieldUpdateOperationsInput | number | null
    mentalDamage?: NullableIntFieldUpdateOperationsInput | number | null
    characterId?: StringFieldUpdateOperationsInput | string
  }

  export type CharacteristicsCreateManyInput = {
    id?: string
    strength?: number
    dexterity?: number
    endurance?: number
    intelligence?: number
    education?: number
    socialStanding?: number
    physicalDamage?: number | null
    mentalDamage?: number | null
    characterId: string
  }

  export type CharacteristicsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    endurance?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    education?: IntFieldUpdateOperationsInput | number
    socialStanding?: IntFieldUpdateOperationsInput | number
    physicalDamage?: NullableIntFieldUpdateOperationsInput | number | null
    mentalDamage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacteristicsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    endurance?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    education?: IntFieldUpdateOperationsInput | number
    socialStanding?: IntFieldUpdateOperationsInput | number
    physicalDamage?: NullableIntFieldUpdateOperationsInput | number | null
    mentalDamage?: NullableIntFieldUpdateOperationsInput | number | null
    characterId?: StringFieldUpdateOperationsInput | string
  }

  export type CharacterSkillCreateInput = {
    id?: string
    name: string
    level?: number
    specialization?: string | null
    character: CharacterCreateNestedOneWithoutSkillsInput
  }

  export type CharacterSkillUncheckedCreateInput = {
    id?: string
    name: string
    level?: number
    specialization?: string | null
    characterId: string
  }

  export type CharacterSkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type CharacterSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    characterId?: StringFieldUpdateOperationsInput | string
  }

  export type CharacterSkillCreateManyInput = {
    id?: string
    name: string
    level?: number
    specialization?: string | null
    characterId: string
  }

  export type CharacterSkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    characterId?: StringFieldUpdateOperationsInput | string
  }

  export type CharacterEquipmentCreateInput = {
    id?: string
    name: string
    description?: string | null
    weight?: number | null
    cost?: number | null
    quantity?: number
    equipped?: boolean
    category?: string | null
    subcategory?: string | null
    weaponType?: string | null
    damage?: string | null
    range?: string | null
    armorValue?: number | null
    armorType?: string | null
    character: CharacterCreateNestedOneWithoutEquipmentInput
  }

  export type CharacterEquipmentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    weight?: number | null
    cost?: number | null
    quantity?: number
    equipped?: boolean
    category?: string | null
    subcategory?: string | null
    weaponType?: string | null
    damage?: string | null
    range?: string | null
    armorValue?: number | null
    armorType?: string | null
    characterId: string
  }

  export type CharacterEquipmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    cost?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    equipped?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    damage?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    armorValue?: NullableIntFieldUpdateOperationsInput | number | null
    armorType?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUpdateOneRequiredWithoutEquipmentNestedInput
  }

  export type CharacterEquipmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    cost?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    equipped?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    damage?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    armorValue?: NullableIntFieldUpdateOperationsInput | number | null
    armorType?: NullableStringFieldUpdateOperationsInput | string | null
    characterId?: StringFieldUpdateOperationsInput | string
  }

  export type CharacterEquipmentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    weight?: number | null
    cost?: number | null
    quantity?: number
    equipped?: boolean
    category?: string | null
    subcategory?: string | null
    weaponType?: string | null
    damage?: string | null
    range?: string | null
    armorValue?: number | null
    armorType?: string | null
    characterId: string
  }

  export type CharacterEquipmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    cost?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    equipped?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    damage?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    armorValue?: NullableIntFieldUpdateOperationsInput | number | null
    armorType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterEquipmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    cost?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    equipped?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    damage?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    armorValue?: NullableIntFieldUpdateOperationsInput | number | null
    armorType?: NullableStringFieldUpdateOperationsInput | string | null
    characterId?: StringFieldUpdateOperationsInput | string
  }

  export type LifeEventCreateInput = {
    id?: string
    age: number
    event: string
    description?: string | null
    effects?: NullableJsonNullValueInput | InputJsonValue
    career?: string | null
    rank?: string | null
    skills?: LifeEventCreateskillsInput | string[]
    character: CharacterCreateNestedOneWithoutLifeEventsInput
  }

  export type LifeEventUncheckedCreateInput = {
    id?: string
    age: number
    event: string
    description?: string | null
    effects?: NullableJsonNullValueInput | InputJsonValue
    career?: string | null
    rank?: string | null
    skills?: LifeEventCreateskillsInput | string[]
    characterId: string
  }

  export type LifeEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effects?: NullableJsonNullValueInput | InputJsonValue
    career?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LifeEventUpdateskillsInput | string[]
    character?: CharacterUpdateOneRequiredWithoutLifeEventsNestedInput
  }

  export type LifeEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effects?: NullableJsonNullValueInput | InputJsonValue
    career?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LifeEventUpdateskillsInput | string[]
    characterId?: StringFieldUpdateOperationsInput | string
  }

  export type LifeEventCreateManyInput = {
    id?: string
    age: number
    event: string
    description?: string | null
    effects?: NullableJsonNullValueInput | InputJsonValue
    career?: string | null
    rank?: string | null
    skills?: LifeEventCreateskillsInput | string[]
    characterId: string
  }

  export type LifeEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effects?: NullableJsonNullValueInput | InputJsonValue
    career?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LifeEventUpdateskillsInput | string[]
  }

  export type LifeEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effects?: NullableJsonNullValueInput | InputJsonValue
    career?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LifeEventUpdateskillsInput | string[]
    characterId?: StringFieldUpdateOperationsInput | string
  }

  export type StarSystemCreateInput = {
    id?: string
    name: string
    hexLocation: string
    sector: string
    subsector?: string | null
    allegiance?: string | null
    starType?: string | null
    gasGiants?: number
    jumpRoutes?: StarSystemCreatejumpRoutesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutStarSystemsInput
    planets?: PlanetCreateNestedManyWithoutStarSystemInput
    tradeRoutes?: TradeRouteCreateNestedManyWithoutOriginInput
    tradeRoutesDestination?: TradeRouteCreateNestedManyWithoutDestinationInput
  }

  export type StarSystemUncheckedCreateInput = {
    id?: string
    name: string
    hexLocation: string
    sector: string
    subsector?: string | null
    allegiance?: string | null
    starType?: string | null
    gasGiants?: number
    jumpRoutes?: StarSystemCreatejumpRoutesInput | string[]
    campaignId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planets?: PlanetUncheckedCreateNestedManyWithoutStarSystemInput
    tradeRoutes?: TradeRouteUncheckedCreateNestedManyWithoutOriginInput
    tradeRoutesDestination?: TradeRouteUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type StarSystemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hexLocation?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    subsector?: NullableStringFieldUpdateOperationsInput | string | null
    allegiance?: NullableStringFieldUpdateOperationsInput | string | null
    starType?: NullableStringFieldUpdateOperationsInput | string | null
    gasGiants?: IntFieldUpdateOperationsInput | number
    jumpRoutes?: StarSystemUpdatejumpRoutesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutStarSystemsNestedInput
    planets?: PlanetUpdateManyWithoutStarSystemNestedInput
    tradeRoutes?: TradeRouteUpdateManyWithoutOriginNestedInput
    tradeRoutesDestination?: TradeRouteUpdateManyWithoutDestinationNestedInput
  }

  export type StarSystemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hexLocation?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    subsector?: NullableStringFieldUpdateOperationsInput | string | null
    allegiance?: NullableStringFieldUpdateOperationsInput | string | null
    starType?: NullableStringFieldUpdateOperationsInput | string | null
    gasGiants?: IntFieldUpdateOperationsInput | number
    jumpRoutes?: StarSystemUpdatejumpRoutesInput | string[]
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planets?: PlanetUncheckedUpdateManyWithoutStarSystemNestedInput
    tradeRoutes?: TradeRouteUncheckedUpdateManyWithoutOriginNestedInput
    tradeRoutesDestination?: TradeRouteUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type StarSystemCreateManyInput = {
    id?: string
    name: string
    hexLocation: string
    sector: string
    subsector?: string | null
    allegiance?: string | null
    starType?: string | null
    gasGiants?: number
    jumpRoutes?: StarSystemCreatejumpRoutesInput | string[]
    campaignId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StarSystemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hexLocation?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    subsector?: NullableStringFieldUpdateOperationsInput | string | null
    allegiance?: NullableStringFieldUpdateOperationsInput | string | null
    starType?: NullableStringFieldUpdateOperationsInput | string | null
    gasGiants?: IntFieldUpdateOperationsInput | number
    jumpRoutes?: StarSystemUpdatejumpRoutesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StarSystemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hexLocation?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    subsector?: NullableStringFieldUpdateOperationsInput | string | null
    allegiance?: NullableStringFieldUpdateOperationsInput | string | null
    starType?: NullableStringFieldUpdateOperationsInput | string | null
    gasGiants?: IntFieldUpdateOperationsInput | number
    jumpRoutes?: StarSystemUpdatejumpRoutesInput | string[]
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanetCreateInput = {
    id?: string
    name: string
    uwp: string
    size: number
    atmosphere: number
    hydrographics: number
    population: number
    government: number
    lawLevel: number
    techLevel: number
    starport: string
    tradeCodes?: PlanetCreatetradeCodesInput | string[]
    bases?: PlanetCreatebasesInput | string[]
    gasGiant?: boolean
    description?: string | null
    notes?: string | null
    starSystem: StarSystemCreateNestedOneWithoutPlanetsInput
    tradeGoods?: TradeGoodCreateNestedManyWithoutPlanetInput
  }

  export type PlanetUncheckedCreateInput = {
    id?: string
    name: string
    uwp: string
    size: number
    atmosphere: number
    hydrographics: number
    population: number
    government: number
    lawLevel: number
    techLevel: number
    starport: string
    tradeCodes?: PlanetCreatetradeCodesInput | string[]
    bases?: PlanetCreatebasesInput | string[]
    gasGiant?: boolean
    description?: string | null
    notes?: string | null
    starSystemId: string
    tradeGoods?: TradeGoodUncheckedCreateNestedManyWithoutPlanetInput
  }

  export type PlanetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uwp?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    atmosphere?: IntFieldUpdateOperationsInput | number
    hydrographics?: IntFieldUpdateOperationsInput | number
    population?: IntFieldUpdateOperationsInput | number
    government?: IntFieldUpdateOperationsInput | number
    lawLevel?: IntFieldUpdateOperationsInput | number
    techLevel?: IntFieldUpdateOperationsInput | number
    starport?: StringFieldUpdateOperationsInput | string
    tradeCodes?: PlanetUpdatetradeCodesInput | string[]
    bases?: PlanetUpdatebasesInput | string[]
    gasGiant?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    starSystem?: StarSystemUpdateOneRequiredWithoutPlanetsNestedInput
    tradeGoods?: TradeGoodUpdateManyWithoutPlanetNestedInput
  }

  export type PlanetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uwp?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    atmosphere?: IntFieldUpdateOperationsInput | number
    hydrographics?: IntFieldUpdateOperationsInput | number
    population?: IntFieldUpdateOperationsInput | number
    government?: IntFieldUpdateOperationsInput | number
    lawLevel?: IntFieldUpdateOperationsInput | number
    techLevel?: IntFieldUpdateOperationsInput | number
    starport?: StringFieldUpdateOperationsInput | string
    tradeCodes?: PlanetUpdatetradeCodesInput | string[]
    bases?: PlanetUpdatebasesInput | string[]
    gasGiant?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    starSystemId?: StringFieldUpdateOperationsInput | string
    tradeGoods?: TradeGoodUncheckedUpdateManyWithoutPlanetNestedInput
  }

  export type PlanetCreateManyInput = {
    id?: string
    name: string
    uwp: string
    size: number
    atmosphere: number
    hydrographics: number
    population: number
    government: number
    lawLevel: number
    techLevel: number
    starport: string
    tradeCodes?: PlanetCreatetradeCodesInput | string[]
    bases?: PlanetCreatebasesInput | string[]
    gasGiant?: boolean
    description?: string | null
    notes?: string | null
    starSystemId: string
  }

  export type PlanetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uwp?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    atmosphere?: IntFieldUpdateOperationsInput | number
    hydrographics?: IntFieldUpdateOperationsInput | number
    population?: IntFieldUpdateOperationsInput | number
    government?: IntFieldUpdateOperationsInput | number
    lawLevel?: IntFieldUpdateOperationsInput | number
    techLevel?: IntFieldUpdateOperationsInput | number
    starport?: StringFieldUpdateOperationsInput | string
    tradeCodes?: PlanetUpdatetradeCodesInput | string[]
    bases?: PlanetUpdatebasesInput | string[]
    gasGiant?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlanetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uwp?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    atmosphere?: IntFieldUpdateOperationsInput | number
    hydrographics?: IntFieldUpdateOperationsInput | number
    population?: IntFieldUpdateOperationsInput | number
    government?: IntFieldUpdateOperationsInput | number
    lawLevel?: IntFieldUpdateOperationsInput | number
    techLevel?: IntFieldUpdateOperationsInput | number
    starport?: StringFieldUpdateOperationsInput | string
    tradeCodes?: PlanetUpdatetradeCodesInput | string[]
    bases?: PlanetUpdatebasesInput | string[]
    gasGiant?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    starSystemId?: StringFieldUpdateOperationsInput | string
  }

  export type StarshipCreateInput = {
    id?: string
    name: string
    class: string
    hullCode?: string | null
    tonnage: number
    jumpDrive?: number
    maneuverDrive?: number
    powerPlant?: number
    crew?: number
    passengers?: number
    cargo?: number
    fuel?: number
    armor?: number
    weapons?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    location?: string | null
    owner?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutStarshipsInput
  }

  export type StarshipUncheckedCreateInput = {
    id?: string
    name: string
    class: string
    hullCode?: string | null
    tonnage: number
    jumpDrive?: number
    maneuverDrive?: number
    powerPlant?: number
    crew?: number
    passengers?: number
    cargo?: number
    fuel?: number
    armor?: number
    weapons?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    location?: string | null
    owner?: string | null
    campaignId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StarshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    hullCode?: NullableStringFieldUpdateOperationsInput | string | null
    tonnage?: IntFieldUpdateOperationsInput | number
    jumpDrive?: IntFieldUpdateOperationsInput | number
    maneuverDrive?: IntFieldUpdateOperationsInput | number
    powerPlant?: IntFieldUpdateOperationsInput | number
    crew?: IntFieldUpdateOperationsInput | number
    passengers?: IntFieldUpdateOperationsInput | number
    cargo?: IntFieldUpdateOperationsInput | number
    fuel?: IntFieldUpdateOperationsInput | number
    armor?: IntFieldUpdateOperationsInput | number
    weapons?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutStarshipsNestedInput
  }

  export type StarshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    hullCode?: NullableStringFieldUpdateOperationsInput | string | null
    tonnage?: IntFieldUpdateOperationsInput | number
    jumpDrive?: IntFieldUpdateOperationsInput | number
    maneuverDrive?: IntFieldUpdateOperationsInput | number
    powerPlant?: IntFieldUpdateOperationsInput | number
    crew?: IntFieldUpdateOperationsInput | number
    passengers?: IntFieldUpdateOperationsInput | number
    cargo?: IntFieldUpdateOperationsInput | number
    fuel?: IntFieldUpdateOperationsInput | number
    armor?: IntFieldUpdateOperationsInput | number
    weapons?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StarshipCreateManyInput = {
    id?: string
    name: string
    class: string
    hullCode?: string | null
    tonnage: number
    jumpDrive?: number
    maneuverDrive?: number
    powerPlant?: number
    crew?: number
    passengers?: number
    cargo?: number
    fuel?: number
    armor?: number
    weapons?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    location?: string | null
    owner?: string | null
    campaignId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StarshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    hullCode?: NullableStringFieldUpdateOperationsInput | string | null
    tonnage?: IntFieldUpdateOperationsInput | number
    jumpDrive?: IntFieldUpdateOperationsInput | number
    maneuverDrive?: IntFieldUpdateOperationsInput | number
    powerPlant?: IntFieldUpdateOperationsInput | number
    crew?: IntFieldUpdateOperationsInput | number
    passengers?: IntFieldUpdateOperationsInput | number
    cargo?: IntFieldUpdateOperationsInput | number
    fuel?: IntFieldUpdateOperationsInput | number
    armor?: IntFieldUpdateOperationsInput | number
    weapons?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StarshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    hullCode?: NullableStringFieldUpdateOperationsInput | string | null
    tonnage?: IntFieldUpdateOperationsInput | number
    jumpDrive?: IntFieldUpdateOperationsInput | number
    maneuverDrive?: IntFieldUpdateOperationsInput | number
    powerPlant?: IntFieldUpdateOperationsInput | number
    crew?: IntFieldUpdateOperationsInput | number
    passengers?: IntFieldUpdateOperationsInput | number
    cargo?: IntFieldUpdateOperationsInput | number
    fuel?: IntFieldUpdateOperationsInput | number
    armor?: IntFieldUpdateOperationsInput | number
    weapons?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TradeGoodCreateInput = {
    id?: string
    name: string
    category: string
    basePrice: number
    availability?: string | null
    legality?: string | null
    dtm?: number
    planet?: PlanetCreateNestedOneWithoutTradeGoodsInput
  }

  export type TradeGoodUncheckedCreateInput = {
    id?: string
    name: string
    category: string
    basePrice: number
    availability?: string | null
    legality?: string | null
    dtm?: number
    planetId?: string | null
  }

  export type TradeGoodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    legality?: NullableStringFieldUpdateOperationsInput | string | null
    dtm?: IntFieldUpdateOperationsInput | number
    planet?: PlanetUpdateOneWithoutTradeGoodsNestedInput
  }

  export type TradeGoodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    legality?: NullableStringFieldUpdateOperationsInput | string | null
    dtm?: IntFieldUpdateOperationsInput | number
    planetId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TradeGoodCreateManyInput = {
    id?: string
    name: string
    category: string
    basePrice: number
    availability?: string | null
    legality?: string | null
    dtm?: number
    planetId?: string | null
  }

  export type TradeGoodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    legality?: NullableStringFieldUpdateOperationsInput | string | null
    dtm?: IntFieldUpdateOperationsInput | number
  }

  export type TradeGoodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    legality?: NullableStringFieldUpdateOperationsInput | string | null
    dtm?: IntFieldUpdateOperationsInput | number
    planetId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TradeRouteCreateInput = {
    id?: string
    name: string
    distance: number
    difficulty?: number
    cargoTypes?: TradeRouteCreatecargoTypesInput | string[]
    profitMargin?: number | null
    origin: StarSystemCreateNestedOneWithoutTradeRoutesInput
    destination: StarSystemCreateNestedOneWithoutTradeRoutesDestinationInput
  }

  export type TradeRouteUncheckedCreateInput = {
    id?: string
    name: string
    distance: number
    difficulty?: number
    originId: string
    destinationId: string
    cargoTypes?: TradeRouteCreatecargoTypesInput | string[]
    profitMargin?: number | null
  }

  export type TradeRouteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    distance?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    cargoTypes?: TradeRouteUpdatecargoTypesInput | string[]
    profitMargin?: NullableFloatFieldUpdateOperationsInput | number | null
    origin?: StarSystemUpdateOneRequiredWithoutTradeRoutesNestedInput
    destination?: StarSystemUpdateOneRequiredWithoutTradeRoutesDestinationNestedInput
  }

  export type TradeRouteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    distance?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    originId?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    cargoTypes?: TradeRouteUpdatecargoTypesInput | string[]
    profitMargin?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TradeRouteCreateManyInput = {
    id?: string
    name: string
    distance: number
    difficulty?: number
    originId: string
    destinationId: string
    cargoTypes?: TradeRouteCreatecargoTypesInput | string[]
    profitMargin?: number | null
  }

  export type TradeRouteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    distance?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    cargoTypes?: TradeRouteUpdatecargoTypesInput | string[]
    profitMargin?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TradeRouteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    distance?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    originId?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    cargoTypes?: TradeRouteUpdatecargoTypesInput | string[]
    profitMargin?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SessionCreateInput = {
    id?: string
    name: string
    scheduledFor?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.SessionStatus
    participants?: SessionCreateparticipantsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutSessionsInput
    encounters?: EncounterCreateNestedManyWithoutSessionInput
    combatSessions?: CombatSessionCreateNestedManyWithoutSessionInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    name: string
    scheduledFor?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.SessionStatus
    campaignId: string
    participants?: SessionCreateparticipantsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterUncheckedCreateNestedManyWithoutSessionInput
    combatSessions?: CombatSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    participants?: SessionUpdateparticipantsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutSessionsNestedInput
    encounters?: EncounterUpdateManyWithoutSessionNestedInput
    combatSessions?: CombatSessionUpdateManyWithoutSessionNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    campaignId?: StringFieldUpdateOperationsInput | string
    participants?: SessionUpdateparticipantsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUncheckedUpdateManyWithoutSessionNestedInput
    combatSessions?: CombatSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionCreateManyInput = {
    id?: string
    name: string
    scheduledFor?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.SessionStatus
    campaignId: string
    participants?: SessionCreateparticipantsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    participants?: SessionUpdateparticipantsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    campaignId?: StringFieldUpdateOperationsInput | string
    participants?: SessionUpdateparticipantsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterCreateInput = {
    id?: string
    name: string
    description?: string | null
    encounterType: string
    difficulty?: number | null
    location?: string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    outcome?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutEncountersInput
    session?: SessionCreateNestedOneWithoutEncountersInput
    combatSessions?: CombatSessionCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    encounterType: string
    difficulty?: number | null
    location?: string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    outcome?: string | null
    campaignId: string
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    combatSessions?: CombatSessionUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterType?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutEncountersNestedInput
    session?: SessionUpdateOneWithoutEncountersNestedInput
    combatSessions?: CombatSessionUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterType?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    combatSessions?: CombatSessionUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    encounterType: string
    difficulty?: number | null
    location?: string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    outcome?: string | null
    campaignId: string
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterType?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterType?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatSessionCreateInput = {
    id?: string
    name?: string | null
    round?: number
    phase?: string
    status?: string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter?: EncounterCreateNestedOneWithoutCombatSessionsInput
    session?: SessionCreateNestedOneWithoutCombatSessionsInput
    actions?: CombatActionCreateNestedManyWithoutCombatSessionInput
  }

  export type CombatSessionUncheckedCreateInput = {
    id?: string
    name?: string | null
    round?: number
    phase?: string
    status?: string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    encounterId?: string | null
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: CombatActionUncheckedCreateNestedManyWithoutCombatSessionInput
  }

  export type CombatSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneWithoutCombatSessionsNestedInput
    session?: SessionUpdateOneWithoutCombatSessionsNestedInput
    actions?: CombatActionUpdateManyWithoutCombatSessionNestedInput
  }

  export type CombatSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: CombatActionUncheckedUpdateManyWithoutCombatSessionNestedInput
  }

  export type CombatSessionCreateManyInput = {
    id?: string
    name?: string | null
    round?: number
    phase?: string
    status?: string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    encounterId?: string | null
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CombatSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatActionCreateInput = {
    id?: string
    actionType: string
    description?: string | null
    target?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    diceRolled?: string | null
    rollResult?: number | null
    modifiers?: NullableJsonNullValueInput | InputJsonValue
    round: number
    timestamp?: Date | string
    character?: CharacterCreateNestedOneWithoutCombatActionsInput
    combatSession: CombatSessionCreateNestedOneWithoutActionsInput
  }

  export type CombatActionUncheckedCreateInput = {
    id?: string
    actionType: string
    description?: string | null
    target?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    diceRolled?: string | null
    rollResult?: number | null
    modifiers?: NullableJsonNullValueInput | InputJsonValue
    characterId?: string | null
    combatSessionId: string
    round: number
    timestamp?: Date | string
  }

  export type CombatActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    diceRolled?: NullableStringFieldUpdateOperationsInput | string | null
    rollResult?: NullableIntFieldUpdateOperationsInput | number | null
    modifiers?: NullableJsonNullValueInput | InputJsonValue
    round?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneWithoutCombatActionsNestedInput
    combatSession?: CombatSessionUpdateOneRequiredWithoutActionsNestedInput
  }

  export type CombatActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    diceRolled?: NullableStringFieldUpdateOperationsInput | string | null
    rollResult?: NullableIntFieldUpdateOperationsInput | number | null
    modifiers?: NullableJsonNullValueInput | InputJsonValue
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    combatSessionId?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatActionCreateManyInput = {
    id?: string
    actionType: string
    description?: string | null
    target?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    diceRolled?: string | null
    rollResult?: number | null
    modifiers?: NullableJsonNullValueInput | InputJsonValue
    characterId?: string | null
    combatSessionId: string
    round: number
    timestamp?: Date | string
  }

  export type CombatActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    diceRolled?: NullableStringFieldUpdateOperationsInput | string | null
    rollResult?: NullableIntFieldUpdateOperationsInput | number | null
    modifiers?: NullableJsonNullValueInput | InputJsonValue
    round?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    diceRolled?: NullableStringFieldUpdateOperationsInput | string | null
    rollResult?: NullableIntFieldUpdateOperationsInput | number | null
    modifiers?: NullableJsonNullValueInput | InputJsonValue
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    combatSessionId?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiceRollCreateInput = {
    id?: string
    dice: string
    result: number
    individual?: DiceRollCreateindividualInput | number[]
    modifiers?: DiceRollCreatemodifiersInput | string[]
    description?: string | null
    isPublic?: boolean
    isGMOnly?: boolean
    character?: string | null
    skill?: string | null
    timestamp?: Date | string
    roller: UserCreateNestedOneWithoutDiceRollsInput
    campaign: CampaignCreateNestedOneWithoutDiceRollsInput
  }

  export type DiceRollUncheckedCreateInput = {
    id?: string
    dice: string
    result: number
    individual?: DiceRollCreateindividualInput | number[]
    modifiers?: DiceRollCreatemodifiersInput | string[]
    description?: string | null
    isPublic?: boolean
    isGMOnly?: boolean
    rollerId: string
    campaignId: string
    character?: string | null
    skill?: string | null
    timestamp?: Date | string
  }

  export type DiceRollUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dice?: StringFieldUpdateOperationsInput | string
    result?: IntFieldUpdateOperationsInput | number
    individual?: DiceRollUpdateindividualInput | number[]
    modifiers?: DiceRollUpdatemodifiersInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isGMOnly?: BoolFieldUpdateOperationsInput | boolean
    character?: NullableStringFieldUpdateOperationsInput | string | null
    skill?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    roller?: UserUpdateOneRequiredWithoutDiceRollsNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutDiceRollsNestedInput
  }

  export type DiceRollUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dice?: StringFieldUpdateOperationsInput | string
    result?: IntFieldUpdateOperationsInput | number
    individual?: DiceRollUpdateindividualInput | number[]
    modifiers?: DiceRollUpdatemodifiersInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isGMOnly?: BoolFieldUpdateOperationsInput | boolean
    rollerId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    character?: NullableStringFieldUpdateOperationsInput | string | null
    skill?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiceRollCreateManyInput = {
    id?: string
    dice: string
    result: number
    individual?: DiceRollCreateindividualInput | number[]
    modifiers?: DiceRollCreatemodifiersInput | string[]
    description?: string | null
    isPublic?: boolean
    isGMOnly?: boolean
    rollerId: string
    campaignId: string
    character?: string | null
    skill?: string | null
    timestamp?: Date | string
  }

  export type DiceRollUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dice?: StringFieldUpdateOperationsInput | string
    result?: IntFieldUpdateOperationsInput | number
    individual?: DiceRollUpdateindividualInput | number[]
    modifiers?: DiceRollUpdatemodifiersInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isGMOnly?: BoolFieldUpdateOperationsInput | boolean
    character?: NullableStringFieldUpdateOperationsInput | string | null
    skill?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiceRollUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dice?: StringFieldUpdateOperationsInput | string
    result?: IntFieldUpdateOperationsInput | number
    individual?: DiceRollUpdateindividualInput | number[]
    modifiers?: DiceRollUpdatemodifiersInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isGMOnly?: BoolFieldUpdateOperationsInput | boolean
    rollerId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    character?: NullableStringFieldUpdateOperationsInput | string | null
    skill?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomContentCreateInput = {
    id?: string
    title: string
    description?: string | null
    contentType: string
    category?: string | null
    data: JsonNullValueInput | InputJsonValue
    tags?: CustomContentCreatetagsInput | string[]
    isPublic?: boolean
    isOfficial?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutCustomContentInput
    campaign?: CampaignCreateNestedOneWithoutCustomContentInput
  }

  export type CustomContentUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    contentType: string
    category?: string | null
    data: JsonNullValueInput | InputJsonValue
    tags?: CustomContentCreatetagsInput | string[]
    isPublic?: boolean
    isOfficial?: boolean
    authorId: string
    campaignId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    tags?: CustomContentUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCustomContentNestedInput
    campaign?: CampaignUpdateOneWithoutCustomContentNestedInput
  }

  export type CustomContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    tags?: CustomContentUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomContentCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    contentType: string
    category?: string | null
    data: JsonNullValueInput | InputJsonValue
    tags?: CustomContentCreatetagsInput | string[]
    isPublic?: boolean
    isOfficial?: boolean
    authorId: string
    campaignId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    tags?: CustomContentUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    tags?: CustomContentUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HouseRuleCreateInput = {
    id?: string
    title: string
    description: string
    category: string
    ruleText: string
    pageReference?: string | null
    replaces?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutHouseRulesDataInput
  }

  export type HouseRuleUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    category: string
    ruleText: string
    pageReference?: string | null
    replaces?: string | null
    isActive?: boolean
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HouseRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    ruleText?: StringFieldUpdateOperationsInput | string
    pageReference?: NullableStringFieldUpdateOperationsInput | string | null
    replaces?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutHouseRulesDataNestedInput
  }

  export type HouseRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    ruleText?: StringFieldUpdateOperationsInput | string
    pageReference?: NullableStringFieldUpdateOperationsInput | string | null
    replaces?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HouseRuleCreateManyInput = {
    id?: string
    title: string
    description: string
    category: string
    ruleText: string
    pageReference?: string | null
    replaces?: string | null
    isActive?: boolean
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HouseRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    ruleText?: StringFieldUpdateOperationsInput | string
    pageReference?: NullableStringFieldUpdateOperationsInput | string | null
    replaces?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HouseRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    ruleText?: StringFieldUpdateOperationsInput | string
    pageReference?: NullableStringFieldUpdateOperationsInput | string | null
    replaces?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HandoutCreateInput = {
    id?: string
    title: string
    description?: string | null
    content?: string | null
    imageUrl?: string | null
    fileUrl?: string | null
    isPlayerVisible?: boolean
    recipients?: HandoutCreaterecipientsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutHandoutsInput
    campaign: CampaignCreateNestedOneWithoutHandoutsInput
  }

  export type HandoutUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    content?: string | null
    imageUrl?: string | null
    fileUrl?: string | null
    isPlayerVisible?: boolean
    recipients?: HandoutCreaterecipientsInput | string[]
    authorId: string
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HandoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPlayerVisible?: BoolFieldUpdateOperationsInput | boolean
    recipients?: HandoutUpdaterecipientsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutHandoutsNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutHandoutsNestedInput
  }

  export type HandoutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPlayerVisible?: BoolFieldUpdateOperationsInput | boolean
    recipients?: HandoutUpdaterecipientsInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HandoutCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    content?: string | null
    imageUrl?: string | null
    fileUrl?: string | null
    isPlayerVisible?: boolean
    recipients?: HandoutCreaterecipientsInput | string[]
    authorId: string
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HandoutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPlayerVisible?: BoolFieldUpdateOperationsInput | boolean
    recipients?: HandoutUpdaterecipientsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HandoutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPlayerVisible?: BoolFieldUpdateOperationsInput | boolean
    recipients?: HandoutUpdaterecipientsInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionNoteCreateInput = {
    id?: string
    title?: string | null
    content: string
    noteType?: string
    tags?: SessionNoteCreatetagsInput | string[]
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutSessionNotesInput
    campaign: CampaignCreateNestedOneWithoutSessionNotesInput
    session?: SessionCreateNestedOneWithoutSessionNotesInput
  }

  export type SessionNoteUncheckedCreateInput = {
    id?: string
    title?: string | null
    content: string
    noteType?: string
    tags?: SessionNoteCreatetagsInput | string[]
    isPublic?: boolean
    authorId: string
    campaignId: string
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    tags?: SessionNoteUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutSessionNotesNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutSessionNotesNestedInput
    session?: SessionUpdateOneWithoutSessionNotesNestedInput
  }

  export type SessionNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    tags?: SessionNoteUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionNoteCreateManyInput = {
    id?: string
    title?: string | null
    content: string
    noteType?: string
    tags?: SessionNoteCreatetagsInput | string[]
    isPublic?: boolean
    authorId: string
    campaignId: string
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    tags?: SessionNoteUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    tags?: SessionNoteUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type CampaignMemberListRelationFilter = {
    every?: CampaignMemberWhereInput
    some?: CampaignMemberWhereInput
    none?: CampaignMemberWhereInput
  }

  export type CharacterListRelationFilter = {
    every?: CharacterWhereInput
    some?: CharacterWhereInput
    none?: CharacterWhereInput
  }

  export type DiceRollListRelationFilter = {
    every?: DiceRollWhereInput
    some?: DiceRollWhereInput
    none?: DiceRollWhereInput
  }

  export type CustomContentListRelationFilter = {
    every?: CustomContentWhereInput
    some?: CustomContentWhereInput
    none?: CustomContentWhereInput
  }

  export type SessionNoteListRelationFilter = {
    every?: SessionNoteWhereInput
    some?: SessionNoteWhereInput
    none?: SessionNoteWhereInput
  }

  export type HandoutListRelationFilter = {
    every?: HandoutWhereInput
    some?: HandoutWhereInput
    none?: HandoutWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiceRollOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HandoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
    avatar?: SortOrder
    timezone?: SortOrder
    subscriptionTier?: SortOrder
    cognitoUserId?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
    avatar?: SortOrder
    timezone?: SortOrder
    subscriptionTier?: SortOrder
    cognitoUserId?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
    avatar?: SortOrder
    timezone?: SortOrder
    subscriptionTier?: SortOrder
    cognitoUserId?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type EncounterListRelationFilter = {
    every?: EncounterWhereInput
    some?: EncounterWhereInput
    none?: EncounterWhereInput
  }

  export type StarSystemListRelationFilter = {
    every?: StarSystemWhereInput
    some?: StarSystemWhereInput
    none?: StarSystemWhereInput
  }

  export type StarshipListRelationFilter = {
    every?: StarshipWhereInput
    some?: StarshipWhereInput
    none?: StarshipWhereInput
  }

  export type HouseRuleListRelationFilter = {
    every?: HouseRuleWhereInput
    some?: HouseRuleWhereInput
    none?: HouseRuleWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StarSystemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StarshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HouseRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    maxPlayers?: SortOrder
    isPublic?: SortOrder
    allowedBooks?: SortOrder
    houseRules?: SortOrder
    gamemasterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    maxPlayers?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    maxPlayers?: SortOrder
    isPublic?: SortOrder
    gamemasterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    maxPlayers?: SortOrder
    isPublic?: SortOrder
    gamemasterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    maxPlayers?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumCampaignRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignRole | EnumCampaignRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignRole[] | ListEnumCampaignRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignRole[] | ListEnumCampaignRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignRoleFilter<$PrismaModel> | $Enums.CampaignRole
  }

  export type CampaignRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type CampaignMemberCampaignIdUserIdCompoundUniqueInput = {
    campaignId: string
    userId: string
  }

  export type CampaignMemberCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
  }

  export type CampaignMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
  }

  export type CampaignMemberMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
  }

  export type EnumCampaignRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignRole | EnumCampaignRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignRole[] | ListEnumCampaignRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignRole[] | ListEnumCampaignRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignRoleWithAggregatesFilter<$PrismaModel> | $Enums.CampaignRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignRoleFilter<$PrismaModel>
    _max?: NestedEnumCampaignRoleFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CharacteristicsNullableRelationFilter = {
    is?: CharacteristicsWhereInput | null
    isNot?: CharacteristicsWhereInput | null
  }

  export type CharacterSkillListRelationFilter = {
    every?: CharacterSkillWhereInput
    some?: CharacterSkillWhereInput
    none?: CharacterSkillWhereInput
  }

  export type CharacterEquipmentListRelationFilter = {
    every?: CharacterEquipmentWhereInput
    some?: CharacterEquipmentWhereInput
    none?: CharacterEquipmentWhereInput
  }

  export type LifeEventListRelationFilter = {
    every?: LifeEventWhereInput
    some?: LifeEventWhereInput
    none?: LifeEventWhereInput
  }

  export type CombatActionListRelationFilter = {
    every?: CombatActionWhereInput
    some?: CombatActionWhereInput
    none?: CombatActionWhereInput
  }

  export type CharacterSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterEquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LifeEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CombatActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterPlayerIdCampaignIdNameCompoundUniqueInput = {
    playerId: string
    campaignId: string
    name: string
  }

  export type CharacterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    credits?: SortOrder
    notes?: SortOrder
    portrait?: SortOrder
    homeworld?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    species?: SortOrder
    playerId?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterAvgOrderByAggregateInput = {
    credits?: SortOrder
    age?: SortOrder
  }

  export type CharacterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    credits?: SortOrder
    notes?: SortOrder
    portrait?: SortOrder
    homeworld?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    species?: SortOrder
    playerId?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    credits?: SortOrder
    notes?: SortOrder
    portrait?: SortOrder
    homeworld?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    species?: SortOrder
    playerId?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterSumOrderByAggregateInput = {
    credits?: SortOrder
    age?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type CharacterRelationFilter = {
    is?: CharacterWhereInput
    isNot?: CharacterWhereInput
  }

  export type CharacteristicsCountOrderByAggregateInput = {
    id?: SortOrder
    strength?: SortOrder
    dexterity?: SortOrder
    endurance?: SortOrder
    intelligence?: SortOrder
    education?: SortOrder
    socialStanding?: SortOrder
    physicalDamage?: SortOrder
    mentalDamage?: SortOrder
    characterId?: SortOrder
  }

  export type CharacteristicsAvgOrderByAggregateInput = {
    strength?: SortOrder
    dexterity?: SortOrder
    endurance?: SortOrder
    intelligence?: SortOrder
    education?: SortOrder
    socialStanding?: SortOrder
    physicalDamage?: SortOrder
    mentalDamage?: SortOrder
  }

  export type CharacteristicsMaxOrderByAggregateInput = {
    id?: SortOrder
    strength?: SortOrder
    dexterity?: SortOrder
    endurance?: SortOrder
    intelligence?: SortOrder
    education?: SortOrder
    socialStanding?: SortOrder
    physicalDamage?: SortOrder
    mentalDamage?: SortOrder
    characterId?: SortOrder
  }

  export type CharacteristicsMinOrderByAggregateInput = {
    id?: SortOrder
    strength?: SortOrder
    dexterity?: SortOrder
    endurance?: SortOrder
    intelligence?: SortOrder
    education?: SortOrder
    socialStanding?: SortOrder
    physicalDamage?: SortOrder
    mentalDamage?: SortOrder
    characterId?: SortOrder
  }

  export type CharacteristicsSumOrderByAggregateInput = {
    strength?: SortOrder
    dexterity?: SortOrder
    endurance?: SortOrder
    intelligence?: SortOrder
    education?: SortOrder
    socialStanding?: SortOrder
    physicalDamage?: SortOrder
    mentalDamage?: SortOrder
  }

  export type CharacterSkillCharacterIdNameSpecializationCompoundUniqueInput = {
    characterId: string
    name: string
    specialization: string
  }

  export type CharacterSkillCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    specialization?: SortOrder
    characterId?: SortOrder
  }

  export type CharacterSkillAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type CharacterSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    specialization?: SortOrder
    characterId?: SortOrder
  }

  export type CharacterSkillMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    specialization?: SortOrder
    characterId?: SortOrder
  }

  export type CharacterSkillSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CharacterEquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    weight?: SortOrder
    cost?: SortOrder
    quantity?: SortOrder
    equipped?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    weaponType?: SortOrder
    damage?: SortOrder
    range?: SortOrder
    armorValue?: SortOrder
    armorType?: SortOrder
    characterId?: SortOrder
  }

  export type CharacterEquipmentAvgOrderByAggregateInput = {
    weight?: SortOrder
    cost?: SortOrder
    quantity?: SortOrder
    armorValue?: SortOrder
  }

  export type CharacterEquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    weight?: SortOrder
    cost?: SortOrder
    quantity?: SortOrder
    equipped?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    weaponType?: SortOrder
    damage?: SortOrder
    range?: SortOrder
    armorValue?: SortOrder
    armorType?: SortOrder
    characterId?: SortOrder
  }

  export type CharacterEquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    weight?: SortOrder
    cost?: SortOrder
    quantity?: SortOrder
    equipped?: SortOrder
    category?: SortOrder
    subcategory?: SortOrder
    weaponType?: SortOrder
    damage?: SortOrder
    range?: SortOrder
    armorValue?: SortOrder
    armorType?: SortOrder
    characterId?: SortOrder
  }

  export type CharacterEquipmentSumOrderByAggregateInput = {
    weight?: SortOrder
    cost?: SortOrder
    quantity?: SortOrder
    armorValue?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type LifeEventCountOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
    event?: SortOrder
    description?: SortOrder
    effects?: SortOrder
    career?: SortOrder
    rank?: SortOrder
    skills?: SortOrder
    characterId?: SortOrder
  }

  export type LifeEventAvgOrderByAggregateInput = {
    age?: SortOrder
  }

  export type LifeEventMaxOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
    event?: SortOrder
    description?: SortOrder
    career?: SortOrder
    rank?: SortOrder
    characterId?: SortOrder
  }

  export type LifeEventMinOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
    event?: SortOrder
    description?: SortOrder
    career?: SortOrder
    rank?: SortOrder
    characterId?: SortOrder
  }

  export type LifeEventSumOrderByAggregateInput = {
    age?: SortOrder
  }

  export type CampaignNullableRelationFilter = {
    is?: CampaignWhereInput | null
    isNot?: CampaignWhereInput | null
  }

  export type PlanetListRelationFilter = {
    every?: PlanetWhereInput
    some?: PlanetWhereInput
    none?: PlanetWhereInput
  }

  export type TradeRouteListRelationFilter = {
    every?: TradeRouteWhereInput
    some?: TradeRouteWhereInput
    none?: TradeRouteWhereInput
  }

  export type PlanetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TradeRouteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StarSystemCampaignIdHexLocationCompoundUniqueInput = {
    campaignId: string
    hexLocation: string
  }

  export type StarSystemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    hexLocation?: SortOrder
    sector?: SortOrder
    subsector?: SortOrder
    allegiance?: SortOrder
    starType?: SortOrder
    gasGiants?: SortOrder
    jumpRoutes?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StarSystemAvgOrderByAggregateInput = {
    gasGiants?: SortOrder
  }

  export type StarSystemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    hexLocation?: SortOrder
    sector?: SortOrder
    subsector?: SortOrder
    allegiance?: SortOrder
    starType?: SortOrder
    gasGiants?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StarSystemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    hexLocation?: SortOrder
    sector?: SortOrder
    subsector?: SortOrder
    allegiance?: SortOrder
    starType?: SortOrder
    gasGiants?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StarSystemSumOrderByAggregateInput = {
    gasGiants?: SortOrder
  }

  export type StarSystemRelationFilter = {
    is?: StarSystemWhereInput
    isNot?: StarSystemWhereInput
  }

  export type TradeGoodListRelationFilter = {
    every?: TradeGoodWhereInput
    some?: TradeGoodWhereInput
    none?: TradeGoodWhereInput
  }

  export type TradeGoodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    uwp?: SortOrder
    size?: SortOrder
    atmosphere?: SortOrder
    hydrographics?: SortOrder
    population?: SortOrder
    government?: SortOrder
    lawLevel?: SortOrder
    techLevel?: SortOrder
    starport?: SortOrder
    tradeCodes?: SortOrder
    bases?: SortOrder
    gasGiant?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    starSystemId?: SortOrder
  }

  export type PlanetAvgOrderByAggregateInput = {
    size?: SortOrder
    atmosphere?: SortOrder
    hydrographics?: SortOrder
    population?: SortOrder
    government?: SortOrder
    lawLevel?: SortOrder
    techLevel?: SortOrder
  }

  export type PlanetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    uwp?: SortOrder
    size?: SortOrder
    atmosphere?: SortOrder
    hydrographics?: SortOrder
    population?: SortOrder
    government?: SortOrder
    lawLevel?: SortOrder
    techLevel?: SortOrder
    starport?: SortOrder
    gasGiant?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    starSystemId?: SortOrder
  }

  export type PlanetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    uwp?: SortOrder
    size?: SortOrder
    atmosphere?: SortOrder
    hydrographics?: SortOrder
    population?: SortOrder
    government?: SortOrder
    lawLevel?: SortOrder
    techLevel?: SortOrder
    starport?: SortOrder
    gasGiant?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    starSystemId?: SortOrder
  }

  export type PlanetSumOrderByAggregateInput = {
    size?: SortOrder
    atmosphere?: SortOrder
    hydrographics?: SortOrder
    population?: SortOrder
    government?: SortOrder
    lawLevel?: SortOrder
    techLevel?: SortOrder
  }

  export type StarshipCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    class?: SortOrder
    hullCode?: SortOrder
    tonnage?: SortOrder
    jumpDrive?: SortOrder
    maneuverDrive?: SortOrder
    powerPlant?: SortOrder
    crew?: SortOrder
    passengers?: SortOrder
    cargo?: SortOrder
    fuel?: SortOrder
    armor?: SortOrder
    weapons?: SortOrder
    status?: SortOrder
    location?: SortOrder
    owner?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StarshipAvgOrderByAggregateInput = {
    tonnage?: SortOrder
    jumpDrive?: SortOrder
    maneuverDrive?: SortOrder
    powerPlant?: SortOrder
    crew?: SortOrder
    passengers?: SortOrder
    cargo?: SortOrder
    fuel?: SortOrder
    armor?: SortOrder
  }

  export type StarshipMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    class?: SortOrder
    hullCode?: SortOrder
    tonnage?: SortOrder
    jumpDrive?: SortOrder
    maneuverDrive?: SortOrder
    powerPlant?: SortOrder
    crew?: SortOrder
    passengers?: SortOrder
    cargo?: SortOrder
    fuel?: SortOrder
    armor?: SortOrder
    status?: SortOrder
    location?: SortOrder
    owner?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StarshipMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    class?: SortOrder
    hullCode?: SortOrder
    tonnage?: SortOrder
    jumpDrive?: SortOrder
    maneuverDrive?: SortOrder
    powerPlant?: SortOrder
    crew?: SortOrder
    passengers?: SortOrder
    cargo?: SortOrder
    fuel?: SortOrder
    armor?: SortOrder
    status?: SortOrder
    location?: SortOrder
    owner?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StarshipSumOrderByAggregateInput = {
    tonnage?: SortOrder
    jumpDrive?: SortOrder
    maneuverDrive?: SortOrder
    powerPlant?: SortOrder
    crew?: SortOrder
    passengers?: SortOrder
    cargo?: SortOrder
    fuel?: SortOrder
    armor?: SortOrder
  }

  export type PlanetNullableRelationFilter = {
    is?: PlanetWhereInput | null
    isNot?: PlanetWhereInput | null
  }

  export type TradeGoodCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    basePrice?: SortOrder
    availability?: SortOrder
    legality?: SortOrder
    dtm?: SortOrder
    planetId?: SortOrder
  }

  export type TradeGoodAvgOrderByAggregateInput = {
    basePrice?: SortOrder
    dtm?: SortOrder
  }

  export type TradeGoodMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    basePrice?: SortOrder
    availability?: SortOrder
    legality?: SortOrder
    dtm?: SortOrder
    planetId?: SortOrder
  }

  export type TradeGoodMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    basePrice?: SortOrder
    availability?: SortOrder
    legality?: SortOrder
    dtm?: SortOrder
    planetId?: SortOrder
  }

  export type TradeGoodSumOrderByAggregateInput = {
    basePrice?: SortOrder
    dtm?: SortOrder
  }

  export type TradeRouteOriginIdDestinationIdCompoundUniqueInput = {
    originId: string
    destinationId: string
  }

  export type TradeRouteCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    distance?: SortOrder
    difficulty?: SortOrder
    originId?: SortOrder
    destinationId?: SortOrder
    cargoTypes?: SortOrder
    profitMargin?: SortOrder
  }

  export type TradeRouteAvgOrderByAggregateInput = {
    distance?: SortOrder
    difficulty?: SortOrder
    profitMargin?: SortOrder
  }

  export type TradeRouteMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    distance?: SortOrder
    difficulty?: SortOrder
    originId?: SortOrder
    destinationId?: SortOrder
    profitMargin?: SortOrder
  }

  export type TradeRouteMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    distance?: SortOrder
    difficulty?: SortOrder
    originId?: SortOrder
    destinationId?: SortOrder
    profitMargin?: SortOrder
  }

  export type TradeRouteSumOrderByAggregateInput = {
    distance?: SortOrder
    difficulty?: SortOrder
    profitMargin?: SortOrder
  }

  export type EnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type CombatSessionListRelationFilter = {
    every?: CombatSessionWhereInput
    some?: CombatSessionWhereInput
    none?: CombatSessionWhereInput
  }

  export type CombatSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    scheduledFor?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    campaignId?: SortOrder
    participants?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    scheduledFor?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    scheduledFor?: SortOrder
    duration?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type SessionNullableRelationFilter = {
    is?: SessionWhereInput | null
    isNot?: SessionWhereInput | null
  }

  export type EncounterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    encounterType?: SortOrder
    difficulty?: SortOrder
    location?: SortOrder
    environment?: SortOrder
    npcs?: SortOrder
    rewards?: SortOrder
    status?: SortOrder
    outcome?: SortOrder
    campaignId?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EncounterAvgOrderByAggregateInput = {
    difficulty?: SortOrder
  }

  export type EncounterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    encounterType?: SortOrder
    difficulty?: SortOrder
    location?: SortOrder
    status?: SortOrder
    outcome?: SortOrder
    campaignId?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EncounterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    encounterType?: SortOrder
    difficulty?: SortOrder
    location?: SortOrder
    status?: SortOrder
    outcome?: SortOrder
    campaignId?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EncounterSumOrderByAggregateInput = {
    difficulty?: SortOrder
  }

  export type EncounterNullableRelationFilter = {
    is?: EncounterWhereInput | null
    isNot?: EncounterWhereInput | null
  }

  export type CombatSessionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    round?: SortOrder
    phase?: SortOrder
    status?: SortOrder
    initiative?: SortOrder
    encounterId?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CombatSessionAvgOrderByAggregateInput = {
    round?: SortOrder
  }

  export type CombatSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    round?: SortOrder
    phase?: SortOrder
    status?: SortOrder
    encounterId?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CombatSessionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    round?: SortOrder
    phase?: SortOrder
    status?: SortOrder
    encounterId?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CombatSessionSumOrderByAggregateInput = {
    round?: SortOrder
  }

  export type CharacterNullableRelationFilter = {
    is?: CharacterWhereInput | null
    isNot?: CharacterWhereInput | null
  }

  export type CombatSessionRelationFilter = {
    is?: CombatSessionWhereInput
    isNot?: CombatSessionWhereInput
  }

  export type CombatActionCountOrderByAggregateInput = {
    id?: SortOrder
    actionType?: SortOrder
    description?: SortOrder
    target?: SortOrder
    result?: SortOrder
    diceRolled?: SortOrder
    rollResult?: SortOrder
    modifiers?: SortOrder
    characterId?: SortOrder
    combatSessionId?: SortOrder
    round?: SortOrder
    timestamp?: SortOrder
  }

  export type CombatActionAvgOrderByAggregateInput = {
    rollResult?: SortOrder
    round?: SortOrder
  }

  export type CombatActionMaxOrderByAggregateInput = {
    id?: SortOrder
    actionType?: SortOrder
    description?: SortOrder
    target?: SortOrder
    diceRolled?: SortOrder
    rollResult?: SortOrder
    characterId?: SortOrder
    combatSessionId?: SortOrder
    round?: SortOrder
    timestamp?: SortOrder
  }

  export type CombatActionMinOrderByAggregateInput = {
    id?: SortOrder
    actionType?: SortOrder
    description?: SortOrder
    target?: SortOrder
    diceRolled?: SortOrder
    rollResult?: SortOrder
    characterId?: SortOrder
    combatSessionId?: SortOrder
    round?: SortOrder
    timestamp?: SortOrder
  }

  export type CombatActionSumOrderByAggregateInput = {
    rollResult?: SortOrder
    round?: SortOrder
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DiceRollCountOrderByAggregateInput = {
    id?: SortOrder
    dice?: SortOrder
    result?: SortOrder
    individual?: SortOrder
    modifiers?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    isGMOnly?: SortOrder
    rollerId?: SortOrder
    campaignId?: SortOrder
    character?: SortOrder
    skill?: SortOrder
    timestamp?: SortOrder
  }

  export type DiceRollAvgOrderByAggregateInput = {
    result?: SortOrder
    individual?: SortOrder
  }

  export type DiceRollMaxOrderByAggregateInput = {
    id?: SortOrder
    dice?: SortOrder
    result?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    isGMOnly?: SortOrder
    rollerId?: SortOrder
    campaignId?: SortOrder
    character?: SortOrder
    skill?: SortOrder
    timestamp?: SortOrder
  }

  export type DiceRollMinOrderByAggregateInput = {
    id?: SortOrder
    dice?: SortOrder
    result?: SortOrder
    description?: SortOrder
    isPublic?: SortOrder
    isGMOnly?: SortOrder
    rollerId?: SortOrder
    campaignId?: SortOrder
    character?: SortOrder
    skill?: SortOrder
    timestamp?: SortOrder
  }

  export type DiceRollSumOrderByAggregateInput = {
    result?: SortOrder
    individual?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CustomContentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    contentType?: SortOrder
    category?: SortOrder
    data?: SortOrder
    tags?: SortOrder
    isPublic?: SortOrder
    isOfficial?: SortOrder
    authorId?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomContentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    contentType?: SortOrder
    category?: SortOrder
    isPublic?: SortOrder
    isOfficial?: SortOrder
    authorId?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomContentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    contentType?: SortOrder
    category?: SortOrder
    isPublic?: SortOrder
    isOfficial?: SortOrder
    authorId?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type HouseRuleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    ruleText?: SortOrder
    pageReference?: SortOrder
    replaces?: SortOrder
    isActive?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HouseRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    ruleText?: SortOrder
    pageReference?: SortOrder
    replaces?: SortOrder
    isActive?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HouseRuleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    ruleText?: SortOrder
    pageReference?: SortOrder
    replaces?: SortOrder
    isActive?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HandoutCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    fileUrl?: SortOrder
    isPlayerVisible?: SortOrder
    recipients?: SortOrder
    authorId?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HandoutMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    fileUrl?: SortOrder
    isPlayerVisible?: SortOrder
    authorId?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HandoutMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    fileUrl?: SortOrder
    isPlayerVisible?: SortOrder
    authorId?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionNoteCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    noteType?: SortOrder
    tags?: SortOrder
    isPublic?: SortOrder
    authorId?: SortOrder
    campaignId?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    noteType?: SortOrder
    isPublic?: SortOrder
    authorId?: SortOrder
    campaignId?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionNoteMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    noteType?: SortOrder
    isPublic?: SortOrder
    authorId?: SortOrder
    campaignId?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignCreateNestedManyWithoutGamemasterInput = {
    create?: XOR<CampaignCreateWithoutGamemasterInput, CampaignUncheckedCreateWithoutGamemasterInput> | CampaignCreateWithoutGamemasterInput[] | CampaignUncheckedCreateWithoutGamemasterInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutGamemasterInput | CampaignCreateOrConnectWithoutGamemasterInput[]
    createMany?: CampaignCreateManyGamemasterInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignMemberCreateWithoutUserInput, CampaignMemberUncheckedCreateWithoutUserInput> | CampaignMemberCreateWithoutUserInput[] | CampaignMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignMemberCreateOrConnectWithoutUserInput | CampaignMemberCreateOrConnectWithoutUserInput[]
    createMany?: CampaignMemberCreateManyUserInputEnvelope
    connect?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
  }

  export type CharacterCreateNestedManyWithoutPlayerInput = {
    create?: XOR<CharacterCreateWithoutPlayerInput, CharacterUncheckedCreateWithoutPlayerInput> | CharacterCreateWithoutPlayerInput[] | CharacterUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutPlayerInput | CharacterCreateOrConnectWithoutPlayerInput[]
    createMany?: CharacterCreateManyPlayerInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type DiceRollCreateNestedManyWithoutRollerInput = {
    create?: XOR<DiceRollCreateWithoutRollerInput, DiceRollUncheckedCreateWithoutRollerInput> | DiceRollCreateWithoutRollerInput[] | DiceRollUncheckedCreateWithoutRollerInput[]
    connectOrCreate?: DiceRollCreateOrConnectWithoutRollerInput | DiceRollCreateOrConnectWithoutRollerInput[]
    createMany?: DiceRollCreateManyRollerInputEnvelope
    connect?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
  }

  export type CustomContentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CustomContentCreateWithoutAuthorInput, CustomContentUncheckedCreateWithoutAuthorInput> | CustomContentCreateWithoutAuthorInput[] | CustomContentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CustomContentCreateOrConnectWithoutAuthorInput | CustomContentCreateOrConnectWithoutAuthorInput[]
    createMany?: CustomContentCreateManyAuthorInputEnvelope
    connect?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
  }

  export type SessionNoteCreateNestedManyWithoutAuthorInput = {
    create?: XOR<SessionNoteCreateWithoutAuthorInput, SessionNoteUncheckedCreateWithoutAuthorInput> | SessionNoteCreateWithoutAuthorInput[] | SessionNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: SessionNoteCreateOrConnectWithoutAuthorInput | SessionNoteCreateOrConnectWithoutAuthorInput[]
    createMany?: SessionNoteCreateManyAuthorInputEnvelope
    connect?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
  }

  export type HandoutCreateNestedManyWithoutAuthorInput = {
    create?: XOR<HandoutCreateWithoutAuthorInput, HandoutUncheckedCreateWithoutAuthorInput> | HandoutCreateWithoutAuthorInput[] | HandoutUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: HandoutCreateOrConnectWithoutAuthorInput | HandoutCreateOrConnectWithoutAuthorInput[]
    createMany?: HandoutCreateManyAuthorInputEnvelope
    connect?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutGamemasterInput = {
    create?: XOR<CampaignCreateWithoutGamemasterInput, CampaignUncheckedCreateWithoutGamemasterInput> | CampaignCreateWithoutGamemasterInput[] | CampaignUncheckedCreateWithoutGamemasterInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutGamemasterInput | CampaignCreateOrConnectWithoutGamemasterInput[]
    createMany?: CampaignCreateManyGamemasterInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignMemberCreateWithoutUserInput, CampaignMemberUncheckedCreateWithoutUserInput> | CampaignMemberCreateWithoutUserInput[] | CampaignMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignMemberCreateOrConnectWithoutUserInput | CampaignMemberCreateOrConnectWithoutUserInput[]
    createMany?: CampaignMemberCreateManyUserInputEnvelope
    connect?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<CharacterCreateWithoutPlayerInput, CharacterUncheckedCreateWithoutPlayerInput> | CharacterCreateWithoutPlayerInput[] | CharacterUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutPlayerInput | CharacterCreateOrConnectWithoutPlayerInput[]
    createMany?: CharacterCreateManyPlayerInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type DiceRollUncheckedCreateNestedManyWithoutRollerInput = {
    create?: XOR<DiceRollCreateWithoutRollerInput, DiceRollUncheckedCreateWithoutRollerInput> | DiceRollCreateWithoutRollerInput[] | DiceRollUncheckedCreateWithoutRollerInput[]
    connectOrCreate?: DiceRollCreateOrConnectWithoutRollerInput | DiceRollCreateOrConnectWithoutRollerInput[]
    createMany?: DiceRollCreateManyRollerInputEnvelope
    connect?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
  }

  export type CustomContentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CustomContentCreateWithoutAuthorInput, CustomContentUncheckedCreateWithoutAuthorInput> | CustomContentCreateWithoutAuthorInput[] | CustomContentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CustomContentCreateOrConnectWithoutAuthorInput | CustomContentCreateOrConnectWithoutAuthorInput[]
    createMany?: CustomContentCreateManyAuthorInputEnvelope
    connect?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
  }

  export type SessionNoteUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<SessionNoteCreateWithoutAuthorInput, SessionNoteUncheckedCreateWithoutAuthorInput> | SessionNoteCreateWithoutAuthorInput[] | SessionNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: SessionNoteCreateOrConnectWithoutAuthorInput | SessionNoteCreateOrConnectWithoutAuthorInput[]
    createMany?: SessionNoteCreateManyAuthorInputEnvelope
    connect?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
  }

  export type HandoutUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<HandoutCreateWithoutAuthorInput, HandoutUncheckedCreateWithoutAuthorInput> | HandoutCreateWithoutAuthorInput[] | HandoutUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: HandoutCreateOrConnectWithoutAuthorInput | HandoutCreateOrConnectWithoutAuthorInput[]
    createMany?: HandoutCreateManyAuthorInputEnvelope
    connect?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumSubscriptionTierFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionTier
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CampaignUpdateManyWithoutGamemasterNestedInput = {
    create?: XOR<CampaignCreateWithoutGamemasterInput, CampaignUncheckedCreateWithoutGamemasterInput> | CampaignCreateWithoutGamemasterInput[] | CampaignUncheckedCreateWithoutGamemasterInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutGamemasterInput | CampaignCreateOrConnectWithoutGamemasterInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutGamemasterInput | CampaignUpsertWithWhereUniqueWithoutGamemasterInput[]
    createMany?: CampaignCreateManyGamemasterInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutGamemasterInput | CampaignUpdateWithWhereUniqueWithoutGamemasterInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutGamemasterInput | CampaignUpdateManyWithWhereWithoutGamemasterInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignMemberCreateWithoutUserInput, CampaignMemberUncheckedCreateWithoutUserInput> | CampaignMemberCreateWithoutUserInput[] | CampaignMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignMemberCreateOrConnectWithoutUserInput | CampaignMemberCreateOrConnectWithoutUserInput[]
    upsert?: CampaignMemberUpsertWithWhereUniqueWithoutUserInput | CampaignMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignMemberCreateManyUserInputEnvelope
    set?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
    disconnect?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
    delete?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
    connect?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
    update?: CampaignMemberUpdateWithWhereUniqueWithoutUserInput | CampaignMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignMemberUpdateManyWithWhereWithoutUserInput | CampaignMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignMemberScalarWhereInput | CampaignMemberScalarWhereInput[]
  }

  export type CharacterUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<CharacterCreateWithoutPlayerInput, CharacterUncheckedCreateWithoutPlayerInput> | CharacterCreateWithoutPlayerInput[] | CharacterUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutPlayerInput | CharacterCreateOrConnectWithoutPlayerInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutPlayerInput | CharacterUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: CharacterCreateManyPlayerInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutPlayerInput | CharacterUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutPlayerInput | CharacterUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type DiceRollUpdateManyWithoutRollerNestedInput = {
    create?: XOR<DiceRollCreateWithoutRollerInput, DiceRollUncheckedCreateWithoutRollerInput> | DiceRollCreateWithoutRollerInput[] | DiceRollUncheckedCreateWithoutRollerInput[]
    connectOrCreate?: DiceRollCreateOrConnectWithoutRollerInput | DiceRollCreateOrConnectWithoutRollerInput[]
    upsert?: DiceRollUpsertWithWhereUniqueWithoutRollerInput | DiceRollUpsertWithWhereUniqueWithoutRollerInput[]
    createMany?: DiceRollCreateManyRollerInputEnvelope
    set?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
    disconnect?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
    delete?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
    connect?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
    update?: DiceRollUpdateWithWhereUniqueWithoutRollerInput | DiceRollUpdateWithWhereUniqueWithoutRollerInput[]
    updateMany?: DiceRollUpdateManyWithWhereWithoutRollerInput | DiceRollUpdateManyWithWhereWithoutRollerInput[]
    deleteMany?: DiceRollScalarWhereInput | DiceRollScalarWhereInput[]
  }

  export type CustomContentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CustomContentCreateWithoutAuthorInput, CustomContentUncheckedCreateWithoutAuthorInput> | CustomContentCreateWithoutAuthorInput[] | CustomContentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CustomContentCreateOrConnectWithoutAuthorInput | CustomContentCreateOrConnectWithoutAuthorInput[]
    upsert?: CustomContentUpsertWithWhereUniqueWithoutAuthorInput | CustomContentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CustomContentCreateManyAuthorInputEnvelope
    set?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
    disconnect?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
    delete?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
    connect?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
    update?: CustomContentUpdateWithWhereUniqueWithoutAuthorInput | CustomContentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CustomContentUpdateManyWithWhereWithoutAuthorInput | CustomContentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CustomContentScalarWhereInput | CustomContentScalarWhereInput[]
  }

  export type SessionNoteUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<SessionNoteCreateWithoutAuthorInput, SessionNoteUncheckedCreateWithoutAuthorInput> | SessionNoteCreateWithoutAuthorInput[] | SessionNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: SessionNoteCreateOrConnectWithoutAuthorInput | SessionNoteCreateOrConnectWithoutAuthorInput[]
    upsert?: SessionNoteUpsertWithWhereUniqueWithoutAuthorInput | SessionNoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: SessionNoteCreateManyAuthorInputEnvelope
    set?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    disconnect?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    delete?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    connect?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    update?: SessionNoteUpdateWithWhereUniqueWithoutAuthorInput | SessionNoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: SessionNoteUpdateManyWithWhereWithoutAuthorInput | SessionNoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: SessionNoteScalarWhereInput | SessionNoteScalarWhereInput[]
  }

  export type HandoutUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<HandoutCreateWithoutAuthorInput, HandoutUncheckedCreateWithoutAuthorInput> | HandoutCreateWithoutAuthorInput[] | HandoutUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: HandoutCreateOrConnectWithoutAuthorInput | HandoutCreateOrConnectWithoutAuthorInput[]
    upsert?: HandoutUpsertWithWhereUniqueWithoutAuthorInput | HandoutUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: HandoutCreateManyAuthorInputEnvelope
    set?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
    disconnect?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
    delete?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
    connect?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
    update?: HandoutUpdateWithWhereUniqueWithoutAuthorInput | HandoutUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: HandoutUpdateManyWithWhereWithoutAuthorInput | HandoutUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: HandoutScalarWhereInput | HandoutScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutGamemasterNestedInput = {
    create?: XOR<CampaignCreateWithoutGamemasterInput, CampaignUncheckedCreateWithoutGamemasterInput> | CampaignCreateWithoutGamemasterInput[] | CampaignUncheckedCreateWithoutGamemasterInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutGamemasterInput | CampaignCreateOrConnectWithoutGamemasterInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutGamemasterInput | CampaignUpsertWithWhereUniqueWithoutGamemasterInput[]
    createMany?: CampaignCreateManyGamemasterInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutGamemasterInput | CampaignUpdateWithWhereUniqueWithoutGamemasterInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutGamemasterInput | CampaignUpdateManyWithWhereWithoutGamemasterInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignMemberCreateWithoutUserInput, CampaignMemberUncheckedCreateWithoutUserInput> | CampaignMemberCreateWithoutUserInput[] | CampaignMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignMemberCreateOrConnectWithoutUserInput | CampaignMemberCreateOrConnectWithoutUserInput[]
    upsert?: CampaignMemberUpsertWithWhereUniqueWithoutUserInput | CampaignMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignMemberCreateManyUserInputEnvelope
    set?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
    disconnect?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
    delete?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
    connect?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
    update?: CampaignMemberUpdateWithWhereUniqueWithoutUserInput | CampaignMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignMemberUpdateManyWithWhereWithoutUserInput | CampaignMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignMemberScalarWhereInput | CampaignMemberScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<CharacterCreateWithoutPlayerInput, CharacterUncheckedCreateWithoutPlayerInput> | CharacterCreateWithoutPlayerInput[] | CharacterUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutPlayerInput | CharacterCreateOrConnectWithoutPlayerInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutPlayerInput | CharacterUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: CharacterCreateManyPlayerInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutPlayerInput | CharacterUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutPlayerInput | CharacterUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type DiceRollUncheckedUpdateManyWithoutRollerNestedInput = {
    create?: XOR<DiceRollCreateWithoutRollerInput, DiceRollUncheckedCreateWithoutRollerInput> | DiceRollCreateWithoutRollerInput[] | DiceRollUncheckedCreateWithoutRollerInput[]
    connectOrCreate?: DiceRollCreateOrConnectWithoutRollerInput | DiceRollCreateOrConnectWithoutRollerInput[]
    upsert?: DiceRollUpsertWithWhereUniqueWithoutRollerInput | DiceRollUpsertWithWhereUniqueWithoutRollerInput[]
    createMany?: DiceRollCreateManyRollerInputEnvelope
    set?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
    disconnect?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
    delete?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
    connect?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
    update?: DiceRollUpdateWithWhereUniqueWithoutRollerInput | DiceRollUpdateWithWhereUniqueWithoutRollerInput[]
    updateMany?: DiceRollUpdateManyWithWhereWithoutRollerInput | DiceRollUpdateManyWithWhereWithoutRollerInput[]
    deleteMany?: DiceRollScalarWhereInput | DiceRollScalarWhereInput[]
  }

  export type CustomContentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CustomContentCreateWithoutAuthorInput, CustomContentUncheckedCreateWithoutAuthorInput> | CustomContentCreateWithoutAuthorInput[] | CustomContentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CustomContentCreateOrConnectWithoutAuthorInput | CustomContentCreateOrConnectWithoutAuthorInput[]
    upsert?: CustomContentUpsertWithWhereUniqueWithoutAuthorInput | CustomContentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CustomContentCreateManyAuthorInputEnvelope
    set?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
    disconnect?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
    delete?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
    connect?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
    update?: CustomContentUpdateWithWhereUniqueWithoutAuthorInput | CustomContentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CustomContentUpdateManyWithWhereWithoutAuthorInput | CustomContentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CustomContentScalarWhereInput | CustomContentScalarWhereInput[]
  }

  export type SessionNoteUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<SessionNoteCreateWithoutAuthorInput, SessionNoteUncheckedCreateWithoutAuthorInput> | SessionNoteCreateWithoutAuthorInput[] | SessionNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: SessionNoteCreateOrConnectWithoutAuthorInput | SessionNoteCreateOrConnectWithoutAuthorInput[]
    upsert?: SessionNoteUpsertWithWhereUniqueWithoutAuthorInput | SessionNoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: SessionNoteCreateManyAuthorInputEnvelope
    set?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    disconnect?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    delete?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    connect?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    update?: SessionNoteUpdateWithWhereUniqueWithoutAuthorInput | SessionNoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: SessionNoteUpdateManyWithWhereWithoutAuthorInput | SessionNoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: SessionNoteScalarWhereInput | SessionNoteScalarWhereInput[]
  }

  export type HandoutUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<HandoutCreateWithoutAuthorInput, HandoutUncheckedCreateWithoutAuthorInput> | HandoutCreateWithoutAuthorInput[] | HandoutUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: HandoutCreateOrConnectWithoutAuthorInput | HandoutCreateOrConnectWithoutAuthorInput[]
    upsert?: HandoutUpsertWithWhereUniqueWithoutAuthorInput | HandoutUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: HandoutCreateManyAuthorInputEnvelope
    set?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
    disconnect?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
    delete?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
    connect?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
    update?: HandoutUpdateWithWhereUniqueWithoutAuthorInput | HandoutUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: HandoutUpdateManyWithWhereWithoutAuthorInput | HandoutUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: HandoutScalarWhereInput | HandoutScalarWhereInput[]
  }

  export type CampaignCreateallowedBooksInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutOwnedCampaignsInput = {
    create?: XOR<UserCreateWithoutOwnedCampaignsInput, UserUncheckedCreateWithoutOwnedCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedCampaignsInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignMemberCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignMemberCreateWithoutCampaignInput, CampaignMemberUncheckedCreateWithoutCampaignInput> | CampaignMemberCreateWithoutCampaignInput[] | CampaignMemberUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMemberCreateOrConnectWithoutCampaignInput | CampaignMemberCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignMemberCreateManyCampaignInputEnvelope
    connect?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
  }

  export type CharacterCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CharacterCreateWithoutCampaignInput, CharacterUncheckedCreateWithoutCampaignInput> | CharacterCreateWithoutCampaignInput[] | CharacterUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutCampaignInput | CharacterCreateOrConnectWithoutCampaignInput[]
    createMany?: CharacterCreateManyCampaignInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutCampaignInput = {
    create?: XOR<SessionCreateWithoutCampaignInput, SessionUncheckedCreateWithoutCampaignInput> | SessionCreateWithoutCampaignInput[] | SessionUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCampaignInput | SessionCreateOrConnectWithoutCampaignInput[]
    createMany?: SessionCreateManyCampaignInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type DiceRollCreateNestedManyWithoutCampaignInput = {
    create?: XOR<DiceRollCreateWithoutCampaignInput, DiceRollUncheckedCreateWithoutCampaignInput> | DiceRollCreateWithoutCampaignInput[] | DiceRollUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DiceRollCreateOrConnectWithoutCampaignInput | DiceRollCreateOrConnectWithoutCampaignInput[]
    createMany?: DiceRollCreateManyCampaignInputEnvelope
    connect?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
  }

  export type EncounterCreateNestedManyWithoutCampaignInput = {
    create?: XOR<EncounterCreateWithoutCampaignInput, EncounterUncheckedCreateWithoutCampaignInput> | EncounterCreateWithoutCampaignInput[] | EncounterUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutCampaignInput | EncounterCreateOrConnectWithoutCampaignInput[]
    createMany?: EncounterCreateManyCampaignInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type StarSystemCreateNestedManyWithoutCampaignInput = {
    create?: XOR<StarSystemCreateWithoutCampaignInput, StarSystemUncheckedCreateWithoutCampaignInput> | StarSystemCreateWithoutCampaignInput[] | StarSystemUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: StarSystemCreateOrConnectWithoutCampaignInput | StarSystemCreateOrConnectWithoutCampaignInput[]
    createMany?: StarSystemCreateManyCampaignInputEnvelope
    connect?: StarSystemWhereUniqueInput | StarSystemWhereUniqueInput[]
  }

  export type StarshipCreateNestedManyWithoutCampaignInput = {
    create?: XOR<StarshipCreateWithoutCampaignInput, StarshipUncheckedCreateWithoutCampaignInput> | StarshipCreateWithoutCampaignInput[] | StarshipUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: StarshipCreateOrConnectWithoutCampaignInput | StarshipCreateOrConnectWithoutCampaignInput[]
    createMany?: StarshipCreateManyCampaignInputEnvelope
    connect?: StarshipWhereUniqueInput | StarshipWhereUniqueInput[]
  }

  export type CustomContentCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CustomContentCreateWithoutCampaignInput, CustomContentUncheckedCreateWithoutCampaignInput> | CustomContentCreateWithoutCampaignInput[] | CustomContentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomContentCreateOrConnectWithoutCampaignInput | CustomContentCreateOrConnectWithoutCampaignInput[]
    createMany?: CustomContentCreateManyCampaignInputEnvelope
    connect?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
  }

  export type HouseRuleCreateNestedManyWithoutCampaignInput = {
    create?: XOR<HouseRuleCreateWithoutCampaignInput, HouseRuleUncheckedCreateWithoutCampaignInput> | HouseRuleCreateWithoutCampaignInput[] | HouseRuleUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: HouseRuleCreateOrConnectWithoutCampaignInput | HouseRuleCreateOrConnectWithoutCampaignInput[]
    createMany?: HouseRuleCreateManyCampaignInputEnvelope
    connect?: HouseRuleWhereUniqueInput | HouseRuleWhereUniqueInput[]
  }

  export type HandoutCreateNestedManyWithoutCampaignInput = {
    create?: XOR<HandoutCreateWithoutCampaignInput, HandoutUncheckedCreateWithoutCampaignInput> | HandoutCreateWithoutCampaignInput[] | HandoutUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: HandoutCreateOrConnectWithoutCampaignInput | HandoutCreateOrConnectWithoutCampaignInput[]
    createMany?: HandoutCreateManyCampaignInputEnvelope
    connect?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
  }

  export type SessionNoteCreateNestedManyWithoutCampaignInput = {
    create?: XOR<SessionNoteCreateWithoutCampaignInput, SessionNoteUncheckedCreateWithoutCampaignInput> | SessionNoteCreateWithoutCampaignInput[] | SessionNoteUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SessionNoteCreateOrConnectWithoutCampaignInput | SessionNoteCreateOrConnectWithoutCampaignInput[]
    createMany?: SessionNoteCreateManyCampaignInputEnvelope
    connect?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
  }

  export type CampaignMemberUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignMemberCreateWithoutCampaignInput, CampaignMemberUncheckedCreateWithoutCampaignInput> | CampaignMemberCreateWithoutCampaignInput[] | CampaignMemberUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMemberCreateOrConnectWithoutCampaignInput | CampaignMemberCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignMemberCreateManyCampaignInputEnvelope
    connect?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CharacterCreateWithoutCampaignInput, CharacterUncheckedCreateWithoutCampaignInput> | CharacterCreateWithoutCampaignInput[] | CharacterUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutCampaignInput | CharacterCreateOrConnectWithoutCampaignInput[]
    createMany?: CharacterCreateManyCampaignInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<SessionCreateWithoutCampaignInput, SessionUncheckedCreateWithoutCampaignInput> | SessionCreateWithoutCampaignInput[] | SessionUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCampaignInput | SessionCreateOrConnectWithoutCampaignInput[]
    createMany?: SessionCreateManyCampaignInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type DiceRollUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<DiceRollCreateWithoutCampaignInput, DiceRollUncheckedCreateWithoutCampaignInput> | DiceRollCreateWithoutCampaignInput[] | DiceRollUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DiceRollCreateOrConnectWithoutCampaignInput | DiceRollCreateOrConnectWithoutCampaignInput[]
    createMany?: DiceRollCreateManyCampaignInputEnvelope
    connect?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<EncounterCreateWithoutCampaignInput, EncounterUncheckedCreateWithoutCampaignInput> | EncounterCreateWithoutCampaignInput[] | EncounterUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutCampaignInput | EncounterCreateOrConnectWithoutCampaignInput[]
    createMany?: EncounterCreateManyCampaignInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type StarSystemUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<StarSystemCreateWithoutCampaignInput, StarSystemUncheckedCreateWithoutCampaignInput> | StarSystemCreateWithoutCampaignInput[] | StarSystemUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: StarSystemCreateOrConnectWithoutCampaignInput | StarSystemCreateOrConnectWithoutCampaignInput[]
    createMany?: StarSystemCreateManyCampaignInputEnvelope
    connect?: StarSystemWhereUniqueInput | StarSystemWhereUniqueInput[]
  }

  export type StarshipUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<StarshipCreateWithoutCampaignInput, StarshipUncheckedCreateWithoutCampaignInput> | StarshipCreateWithoutCampaignInput[] | StarshipUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: StarshipCreateOrConnectWithoutCampaignInput | StarshipCreateOrConnectWithoutCampaignInput[]
    createMany?: StarshipCreateManyCampaignInputEnvelope
    connect?: StarshipWhereUniqueInput | StarshipWhereUniqueInput[]
  }

  export type CustomContentUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CustomContentCreateWithoutCampaignInput, CustomContentUncheckedCreateWithoutCampaignInput> | CustomContentCreateWithoutCampaignInput[] | CustomContentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomContentCreateOrConnectWithoutCampaignInput | CustomContentCreateOrConnectWithoutCampaignInput[]
    createMany?: CustomContentCreateManyCampaignInputEnvelope
    connect?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
  }

  export type HouseRuleUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<HouseRuleCreateWithoutCampaignInput, HouseRuleUncheckedCreateWithoutCampaignInput> | HouseRuleCreateWithoutCampaignInput[] | HouseRuleUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: HouseRuleCreateOrConnectWithoutCampaignInput | HouseRuleCreateOrConnectWithoutCampaignInput[]
    createMany?: HouseRuleCreateManyCampaignInputEnvelope
    connect?: HouseRuleWhereUniqueInput | HouseRuleWhereUniqueInput[]
  }

  export type HandoutUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<HandoutCreateWithoutCampaignInput, HandoutUncheckedCreateWithoutCampaignInput> | HandoutCreateWithoutCampaignInput[] | HandoutUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: HandoutCreateOrConnectWithoutCampaignInput | HandoutCreateOrConnectWithoutCampaignInput[]
    createMany?: HandoutCreateManyCampaignInputEnvelope
    connect?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
  }

  export type SessionNoteUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<SessionNoteCreateWithoutCampaignInput, SessionNoteUncheckedCreateWithoutCampaignInput> | SessionNoteCreateWithoutCampaignInput[] | SessionNoteUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SessionNoteCreateOrConnectWithoutCampaignInput | SessionNoteCreateOrConnectWithoutCampaignInput[]
    createMany?: SessionNoteCreateManyCampaignInputEnvelope
    connect?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CampaignUpdateallowedBooksInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutOwnedCampaignsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedCampaignsInput, UserUncheckedCreateWithoutOwnedCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedCampaignsInput
    upsert?: UserUpsertWithoutOwnedCampaignsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedCampaignsInput, UserUpdateWithoutOwnedCampaignsInput>, UserUncheckedUpdateWithoutOwnedCampaignsInput>
  }

  export type CampaignMemberUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignMemberCreateWithoutCampaignInput, CampaignMemberUncheckedCreateWithoutCampaignInput> | CampaignMemberCreateWithoutCampaignInput[] | CampaignMemberUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMemberCreateOrConnectWithoutCampaignInput | CampaignMemberCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignMemberUpsertWithWhereUniqueWithoutCampaignInput | CampaignMemberUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignMemberCreateManyCampaignInputEnvelope
    set?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
    disconnect?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
    delete?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
    connect?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
    update?: CampaignMemberUpdateWithWhereUniqueWithoutCampaignInput | CampaignMemberUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignMemberUpdateManyWithWhereWithoutCampaignInput | CampaignMemberUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignMemberScalarWhereInput | CampaignMemberScalarWhereInput[]
  }

  export type CharacterUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CharacterCreateWithoutCampaignInput, CharacterUncheckedCreateWithoutCampaignInput> | CharacterCreateWithoutCampaignInput[] | CharacterUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutCampaignInput | CharacterCreateOrConnectWithoutCampaignInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutCampaignInput | CharacterUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CharacterCreateManyCampaignInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutCampaignInput | CharacterUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutCampaignInput | CharacterUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<SessionCreateWithoutCampaignInput, SessionUncheckedCreateWithoutCampaignInput> | SessionCreateWithoutCampaignInput[] | SessionUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCampaignInput | SessionCreateOrConnectWithoutCampaignInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutCampaignInput | SessionUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: SessionCreateManyCampaignInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutCampaignInput | SessionUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutCampaignInput | SessionUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type DiceRollUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<DiceRollCreateWithoutCampaignInput, DiceRollUncheckedCreateWithoutCampaignInput> | DiceRollCreateWithoutCampaignInput[] | DiceRollUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DiceRollCreateOrConnectWithoutCampaignInput | DiceRollCreateOrConnectWithoutCampaignInput[]
    upsert?: DiceRollUpsertWithWhereUniqueWithoutCampaignInput | DiceRollUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: DiceRollCreateManyCampaignInputEnvelope
    set?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
    disconnect?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
    delete?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
    connect?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
    update?: DiceRollUpdateWithWhereUniqueWithoutCampaignInput | DiceRollUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: DiceRollUpdateManyWithWhereWithoutCampaignInput | DiceRollUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: DiceRollScalarWhereInput | DiceRollScalarWhereInput[]
  }

  export type EncounterUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<EncounterCreateWithoutCampaignInput, EncounterUncheckedCreateWithoutCampaignInput> | EncounterCreateWithoutCampaignInput[] | EncounterUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutCampaignInput | EncounterCreateOrConnectWithoutCampaignInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutCampaignInput | EncounterUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: EncounterCreateManyCampaignInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutCampaignInput | EncounterUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutCampaignInput | EncounterUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type StarSystemUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<StarSystemCreateWithoutCampaignInput, StarSystemUncheckedCreateWithoutCampaignInput> | StarSystemCreateWithoutCampaignInput[] | StarSystemUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: StarSystemCreateOrConnectWithoutCampaignInput | StarSystemCreateOrConnectWithoutCampaignInput[]
    upsert?: StarSystemUpsertWithWhereUniqueWithoutCampaignInput | StarSystemUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: StarSystemCreateManyCampaignInputEnvelope
    set?: StarSystemWhereUniqueInput | StarSystemWhereUniqueInput[]
    disconnect?: StarSystemWhereUniqueInput | StarSystemWhereUniqueInput[]
    delete?: StarSystemWhereUniqueInput | StarSystemWhereUniqueInput[]
    connect?: StarSystemWhereUniqueInput | StarSystemWhereUniqueInput[]
    update?: StarSystemUpdateWithWhereUniqueWithoutCampaignInput | StarSystemUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: StarSystemUpdateManyWithWhereWithoutCampaignInput | StarSystemUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: StarSystemScalarWhereInput | StarSystemScalarWhereInput[]
  }

  export type StarshipUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<StarshipCreateWithoutCampaignInput, StarshipUncheckedCreateWithoutCampaignInput> | StarshipCreateWithoutCampaignInput[] | StarshipUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: StarshipCreateOrConnectWithoutCampaignInput | StarshipCreateOrConnectWithoutCampaignInput[]
    upsert?: StarshipUpsertWithWhereUniqueWithoutCampaignInput | StarshipUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: StarshipCreateManyCampaignInputEnvelope
    set?: StarshipWhereUniqueInput | StarshipWhereUniqueInput[]
    disconnect?: StarshipWhereUniqueInput | StarshipWhereUniqueInput[]
    delete?: StarshipWhereUniqueInput | StarshipWhereUniqueInput[]
    connect?: StarshipWhereUniqueInput | StarshipWhereUniqueInput[]
    update?: StarshipUpdateWithWhereUniqueWithoutCampaignInput | StarshipUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: StarshipUpdateManyWithWhereWithoutCampaignInput | StarshipUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: StarshipScalarWhereInput | StarshipScalarWhereInput[]
  }

  export type CustomContentUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CustomContentCreateWithoutCampaignInput, CustomContentUncheckedCreateWithoutCampaignInput> | CustomContentCreateWithoutCampaignInput[] | CustomContentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomContentCreateOrConnectWithoutCampaignInput | CustomContentCreateOrConnectWithoutCampaignInput[]
    upsert?: CustomContentUpsertWithWhereUniqueWithoutCampaignInput | CustomContentUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CustomContentCreateManyCampaignInputEnvelope
    set?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
    disconnect?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
    delete?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
    connect?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
    update?: CustomContentUpdateWithWhereUniqueWithoutCampaignInput | CustomContentUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CustomContentUpdateManyWithWhereWithoutCampaignInput | CustomContentUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CustomContentScalarWhereInput | CustomContentScalarWhereInput[]
  }

  export type HouseRuleUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<HouseRuleCreateWithoutCampaignInput, HouseRuleUncheckedCreateWithoutCampaignInput> | HouseRuleCreateWithoutCampaignInput[] | HouseRuleUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: HouseRuleCreateOrConnectWithoutCampaignInput | HouseRuleCreateOrConnectWithoutCampaignInput[]
    upsert?: HouseRuleUpsertWithWhereUniqueWithoutCampaignInput | HouseRuleUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: HouseRuleCreateManyCampaignInputEnvelope
    set?: HouseRuleWhereUniqueInput | HouseRuleWhereUniqueInput[]
    disconnect?: HouseRuleWhereUniqueInput | HouseRuleWhereUniqueInput[]
    delete?: HouseRuleWhereUniqueInput | HouseRuleWhereUniqueInput[]
    connect?: HouseRuleWhereUniqueInput | HouseRuleWhereUniqueInput[]
    update?: HouseRuleUpdateWithWhereUniqueWithoutCampaignInput | HouseRuleUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: HouseRuleUpdateManyWithWhereWithoutCampaignInput | HouseRuleUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: HouseRuleScalarWhereInput | HouseRuleScalarWhereInput[]
  }

  export type HandoutUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<HandoutCreateWithoutCampaignInput, HandoutUncheckedCreateWithoutCampaignInput> | HandoutCreateWithoutCampaignInput[] | HandoutUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: HandoutCreateOrConnectWithoutCampaignInput | HandoutCreateOrConnectWithoutCampaignInput[]
    upsert?: HandoutUpsertWithWhereUniqueWithoutCampaignInput | HandoutUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: HandoutCreateManyCampaignInputEnvelope
    set?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
    disconnect?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
    delete?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
    connect?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
    update?: HandoutUpdateWithWhereUniqueWithoutCampaignInput | HandoutUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: HandoutUpdateManyWithWhereWithoutCampaignInput | HandoutUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: HandoutScalarWhereInput | HandoutScalarWhereInput[]
  }

  export type SessionNoteUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<SessionNoteCreateWithoutCampaignInput, SessionNoteUncheckedCreateWithoutCampaignInput> | SessionNoteCreateWithoutCampaignInput[] | SessionNoteUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SessionNoteCreateOrConnectWithoutCampaignInput | SessionNoteCreateOrConnectWithoutCampaignInput[]
    upsert?: SessionNoteUpsertWithWhereUniqueWithoutCampaignInput | SessionNoteUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: SessionNoteCreateManyCampaignInputEnvelope
    set?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    disconnect?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    delete?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    connect?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    update?: SessionNoteUpdateWithWhereUniqueWithoutCampaignInput | SessionNoteUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: SessionNoteUpdateManyWithWhereWithoutCampaignInput | SessionNoteUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: SessionNoteScalarWhereInput | SessionNoteScalarWhereInput[]
  }

  export type CampaignMemberUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignMemberCreateWithoutCampaignInput, CampaignMemberUncheckedCreateWithoutCampaignInput> | CampaignMemberCreateWithoutCampaignInput[] | CampaignMemberUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMemberCreateOrConnectWithoutCampaignInput | CampaignMemberCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignMemberUpsertWithWhereUniqueWithoutCampaignInput | CampaignMemberUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignMemberCreateManyCampaignInputEnvelope
    set?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
    disconnect?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
    delete?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
    connect?: CampaignMemberWhereUniqueInput | CampaignMemberWhereUniqueInput[]
    update?: CampaignMemberUpdateWithWhereUniqueWithoutCampaignInput | CampaignMemberUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignMemberUpdateManyWithWhereWithoutCampaignInput | CampaignMemberUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignMemberScalarWhereInput | CampaignMemberScalarWhereInput[]
  }

  export type CharacterUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CharacterCreateWithoutCampaignInput, CharacterUncheckedCreateWithoutCampaignInput> | CharacterCreateWithoutCampaignInput[] | CharacterUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutCampaignInput | CharacterCreateOrConnectWithoutCampaignInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutCampaignInput | CharacterUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CharacterCreateManyCampaignInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutCampaignInput | CharacterUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutCampaignInput | CharacterUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<SessionCreateWithoutCampaignInput, SessionUncheckedCreateWithoutCampaignInput> | SessionCreateWithoutCampaignInput[] | SessionUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCampaignInput | SessionCreateOrConnectWithoutCampaignInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutCampaignInput | SessionUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: SessionCreateManyCampaignInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutCampaignInput | SessionUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutCampaignInput | SessionUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type DiceRollUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<DiceRollCreateWithoutCampaignInput, DiceRollUncheckedCreateWithoutCampaignInput> | DiceRollCreateWithoutCampaignInput[] | DiceRollUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: DiceRollCreateOrConnectWithoutCampaignInput | DiceRollCreateOrConnectWithoutCampaignInput[]
    upsert?: DiceRollUpsertWithWhereUniqueWithoutCampaignInput | DiceRollUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: DiceRollCreateManyCampaignInputEnvelope
    set?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
    disconnect?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
    delete?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
    connect?: DiceRollWhereUniqueInput | DiceRollWhereUniqueInput[]
    update?: DiceRollUpdateWithWhereUniqueWithoutCampaignInput | DiceRollUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: DiceRollUpdateManyWithWhereWithoutCampaignInput | DiceRollUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: DiceRollScalarWhereInput | DiceRollScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<EncounterCreateWithoutCampaignInput, EncounterUncheckedCreateWithoutCampaignInput> | EncounterCreateWithoutCampaignInput[] | EncounterUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutCampaignInput | EncounterCreateOrConnectWithoutCampaignInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutCampaignInput | EncounterUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: EncounterCreateManyCampaignInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutCampaignInput | EncounterUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutCampaignInput | EncounterUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type StarSystemUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<StarSystemCreateWithoutCampaignInput, StarSystemUncheckedCreateWithoutCampaignInput> | StarSystemCreateWithoutCampaignInput[] | StarSystemUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: StarSystemCreateOrConnectWithoutCampaignInput | StarSystemCreateOrConnectWithoutCampaignInput[]
    upsert?: StarSystemUpsertWithWhereUniqueWithoutCampaignInput | StarSystemUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: StarSystemCreateManyCampaignInputEnvelope
    set?: StarSystemWhereUniqueInput | StarSystemWhereUniqueInput[]
    disconnect?: StarSystemWhereUniqueInput | StarSystemWhereUniqueInput[]
    delete?: StarSystemWhereUniqueInput | StarSystemWhereUniqueInput[]
    connect?: StarSystemWhereUniqueInput | StarSystemWhereUniqueInput[]
    update?: StarSystemUpdateWithWhereUniqueWithoutCampaignInput | StarSystemUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: StarSystemUpdateManyWithWhereWithoutCampaignInput | StarSystemUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: StarSystemScalarWhereInput | StarSystemScalarWhereInput[]
  }

  export type StarshipUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<StarshipCreateWithoutCampaignInput, StarshipUncheckedCreateWithoutCampaignInput> | StarshipCreateWithoutCampaignInput[] | StarshipUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: StarshipCreateOrConnectWithoutCampaignInput | StarshipCreateOrConnectWithoutCampaignInput[]
    upsert?: StarshipUpsertWithWhereUniqueWithoutCampaignInput | StarshipUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: StarshipCreateManyCampaignInputEnvelope
    set?: StarshipWhereUniqueInput | StarshipWhereUniqueInput[]
    disconnect?: StarshipWhereUniqueInput | StarshipWhereUniqueInput[]
    delete?: StarshipWhereUniqueInput | StarshipWhereUniqueInput[]
    connect?: StarshipWhereUniqueInput | StarshipWhereUniqueInput[]
    update?: StarshipUpdateWithWhereUniqueWithoutCampaignInput | StarshipUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: StarshipUpdateManyWithWhereWithoutCampaignInput | StarshipUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: StarshipScalarWhereInput | StarshipScalarWhereInput[]
  }

  export type CustomContentUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CustomContentCreateWithoutCampaignInput, CustomContentUncheckedCreateWithoutCampaignInput> | CustomContentCreateWithoutCampaignInput[] | CustomContentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomContentCreateOrConnectWithoutCampaignInput | CustomContentCreateOrConnectWithoutCampaignInput[]
    upsert?: CustomContentUpsertWithWhereUniqueWithoutCampaignInput | CustomContentUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CustomContentCreateManyCampaignInputEnvelope
    set?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
    disconnect?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
    delete?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
    connect?: CustomContentWhereUniqueInput | CustomContentWhereUniqueInput[]
    update?: CustomContentUpdateWithWhereUniqueWithoutCampaignInput | CustomContentUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CustomContentUpdateManyWithWhereWithoutCampaignInput | CustomContentUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CustomContentScalarWhereInput | CustomContentScalarWhereInput[]
  }

  export type HouseRuleUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<HouseRuleCreateWithoutCampaignInput, HouseRuleUncheckedCreateWithoutCampaignInput> | HouseRuleCreateWithoutCampaignInput[] | HouseRuleUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: HouseRuleCreateOrConnectWithoutCampaignInput | HouseRuleCreateOrConnectWithoutCampaignInput[]
    upsert?: HouseRuleUpsertWithWhereUniqueWithoutCampaignInput | HouseRuleUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: HouseRuleCreateManyCampaignInputEnvelope
    set?: HouseRuleWhereUniqueInput | HouseRuleWhereUniqueInput[]
    disconnect?: HouseRuleWhereUniqueInput | HouseRuleWhereUniqueInput[]
    delete?: HouseRuleWhereUniqueInput | HouseRuleWhereUniqueInput[]
    connect?: HouseRuleWhereUniqueInput | HouseRuleWhereUniqueInput[]
    update?: HouseRuleUpdateWithWhereUniqueWithoutCampaignInput | HouseRuleUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: HouseRuleUpdateManyWithWhereWithoutCampaignInput | HouseRuleUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: HouseRuleScalarWhereInput | HouseRuleScalarWhereInput[]
  }

  export type HandoutUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<HandoutCreateWithoutCampaignInput, HandoutUncheckedCreateWithoutCampaignInput> | HandoutCreateWithoutCampaignInput[] | HandoutUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: HandoutCreateOrConnectWithoutCampaignInput | HandoutCreateOrConnectWithoutCampaignInput[]
    upsert?: HandoutUpsertWithWhereUniqueWithoutCampaignInput | HandoutUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: HandoutCreateManyCampaignInputEnvelope
    set?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
    disconnect?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
    delete?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
    connect?: HandoutWhereUniqueInput | HandoutWhereUniqueInput[]
    update?: HandoutUpdateWithWhereUniqueWithoutCampaignInput | HandoutUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: HandoutUpdateManyWithWhereWithoutCampaignInput | HandoutUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: HandoutScalarWhereInput | HandoutScalarWhereInput[]
  }

  export type SessionNoteUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<SessionNoteCreateWithoutCampaignInput, SessionNoteUncheckedCreateWithoutCampaignInput> | SessionNoteCreateWithoutCampaignInput[] | SessionNoteUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SessionNoteCreateOrConnectWithoutCampaignInput | SessionNoteCreateOrConnectWithoutCampaignInput[]
    upsert?: SessionNoteUpsertWithWhereUniqueWithoutCampaignInput | SessionNoteUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: SessionNoteCreateManyCampaignInputEnvelope
    set?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    disconnect?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    delete?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    connect?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    update?: SessionNoteUpdateWithWhereUniqueWithoutCampaignInput | SessionNoteUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: SessionNoteUpdateManyWithWhereWithoutCampaignInput | SessionNoteUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: SessionNoteScalarWhereInput | SessionNoteScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutMembersInput = {
    create?: XOR<CampaignCreateWithoutMembersInput, CampaignUncheckedCreateWithoutMembersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMembersInput
    connect?: CampaignWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCampaignMembersInput = {
    create?: XOR<UserCreateWithoutCampaignMembersInput, UserUncheckedCreateWithoutCampaignMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignMembersInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCampaignRoleFieldUpdateOperationsInput = {
    set?: $Enums.CampaignRole
  }

  export type CampaignUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<CampaignCreateWithoutMembersInput, CampaignUncheckedCreateWithoutMembersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMembersInput
    upsert?: CampaignUpsertWithoutMembersInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutMembersInput, CampaignUpdateWithoutMembersInput>, CampaignUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutCampaignMembersNestedInput = {
    create?: XOR<UserCreateWithoutCampaignMembersInput, UserUncheckedCreateWithoutCampaignMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignMembersInput
    upsert?: UserUpsertWithoutCampaignMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCampaignMembersInput, UserUpdateWithoutCampaignMembersInput>, UserUncheckedUpdateWithoutCampaignMembersInput>
  }

  export type UserCreateNestedOneWithoutCharactersInput = {
    create?: XOR<UserCreateWithoutCharactersInput, UserUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCharactersInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutCharactersInput = {
    create?: XOR<CampaignCreateWithoutCharactersInput, CampaignUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCharactersInput
    connect?: CampaignWhereUniqueInput
  }

  export type CharacteristicsCreateNestedOneWithoutCharacterInput = {
    create?: XOR<CharacteristicsCreateWithoutCharacterInput, CharacteristicsUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: CharacteristicsCreateOrConnectWithoutCharacterInput
    connect?: CharacteristicsWhereUniqueInput
  }

  export type CharacterSkillCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterSkillCreateWithoutCharacterInput, CharacterSkillUncheckedCreateWithoutCharacterInput> | CharacterSkillCreateWithoutCharacterInput[] | CharacterSkillUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutCharacterInput | CharacterSkillCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterSkillCreateManyCharacterInputEnvelope
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
  }

  export type CharacterEquipmentCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterEquipmentCreateWithoutCharacterInput, CharacterEquipmentUncheckedCreateWithoutCharacterInput> | CharacterEquipmentCreateWithoutCharacterInput[] | CharacterEquipmentUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterEquipmentCreateOrConnectWithoutCharacterInput | CharacterEquipmentCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterEquipmentCreateManyCharacterInputEnvelope
    connect?: CharacterEquipmentWhereUniqueInput | CharacterEquipmentWhereUniqueInput[]
  }

  export type LifeEventCreateNestedManyWithoutCharacterInput = {
    create?: XOR<LifeEventCreateWithoutCharacterInput, LifeEventUncheckedCreateWithoutCharacterInput> | LifeEventCreateWithoutCharacterInput[] | LifeEventUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: LifeEventCreateOrConnectWithoutCharacterInput | LifeEventCreateOrConnectWithoutCharacterInput[]
    createMany?: LifeEventCreateManyCharacterInputEnvelope
    connect?: LifeEventWhereUniqueInput | LifeEventWhereUniqueInput[]
  }

  export type CombatActionCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CombatActionCreateWithoutCharacterInput, CombatActionUncheckedCreateWithoutCharacterInput> | CombatActionCreateWithoutCharacterInput[] | CombatActionUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CombatActionCreateOrConnectWithoutCharacterInput | CombatActionCreateOrConnectWithoutCharacterInput[]
    createMany?: CombatActionCreateManyCharacterInputEnvelope
    connect?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
  }

  export type CharacteristicsUncheckedCreateNestedOneWithoutCharacterInput = {
    create?: XOR<CharacteristicsCreateWithoutCharacterInput, CharacteristicsUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: CharacteristicsCreateOrConnectWithoutCharacterInput
    connect?: CharacteristicsWhereUniqueInput
  }

  export type CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterSkillCreateWithoutCharacterInput, CharacterSkillUncheckedCreateWithoutCharacterInput> | CharacterSkillCreateWithoutCharacterInput[] | CharacterSkillUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutCharacterInput | CharacterSkillCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterSkillCreateManyCharacterInputEnvelope
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
  }

  export type CharacterEquipmentUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterEquipmentCreateWithoutCharacterInput, CharacterEquipmentUncheckedCreateWithoutCharacterInput> | CharacterEquipmentCreateWithoutCharacterInput[] | CharacterEquipmentUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterEquipmentCreateOrConnectWithoutCharacterInput | CharacterEquipmentCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterEquipmentCreateManyCharacterInputEnvelope
    connect?: CharacterEquipmentWhereUniqueInput | CharacterEquipmentWhereUniqueInput[]
  }

  export type LifeEventUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<LifeEventCreateWithoutCharacterInput, LifeEventUncheckedCreateWithoutCharacterInput> | LifeEventCreateWithoutCharacterInput[] | LifeEventUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: LifeEventCreateOrConnectWithoutCharacterInput | LifeEventCreateOrConnectWithoutCharacterInput[]
    createMany?: LifeEventCreateManyCharacterInputEnvelope
    connect?: LifeEventWhereUniqueInput | LifeEventWhereUniqueInput[]
  }

  export type CombatActionUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CombatActionCreateWithoutCharacterInput, CombatActionUncheckedCreateWithoutCharacterInput> | CombatActionCreateWithoutCharacterInput[] | CombatActionUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CombatActionCreateOrConnectWithoutCharacterInput | CombatActionCreateOrConnectWithoutCharacterInput[]
    createMany?: CombatActionCreateManyCharacterInputEnvelope
    connect?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutCharactersNestedInput = {
    create?: XOR<UserCreateWithoutCharactersInput, UserUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: UserCreateOrConnectWithoutCharactersInput
    upsert?: UserUpsertWithoutCharactersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCharactersInput, UserUpdateWithoutCharactersInput>, UserUncheckedUpdateWithoutCharactersInput>
  }

  export type CampaignUpdateOneRequiredWithoutCharactersNestedInput = {
    create?: XOR<CampaignCreateWithoutCharactersInput, CampaignUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCharactersInput
    upsert?: CampaignUpsertWithoutCharactersInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutCharactersInput, CampaignUpdateWithoutCharactersInput>, CampaignUncheckedUpdateWithoutCharactersInput>
  }

  export type CharacteristicsUpdateOneWithoutCharacterNestedInput = {
    create?: XOR<CharacteristicsCreateWithoutCharacterInput, CharacteristicsUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: CharacteristicsCreateOrConnectWithoutCharacterInput
    upsert?: CharacteristicsUpsertWithoutCharacterInput
    disconnect?: CharacteristicsWhereInput | boolean
    delete?: CharacteristicsWhereInput | boolean
    connect?: CharacteristicsWhereUniqueInput
    update?: XOR<XOR<CharacteristicsUpdateToOneWithWhereWithoutCharacterInput, CharacteristicsUpdateWithoutCharacterInput>, CharacteristicsUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacterSkillUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterSkillCreateWithoutCharacterInput, CharacterSkillUncheckedCreateWithoutCharacterInput> | CharacterSkillCreateWithoutCharacterInput[] | CharacterSkillUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutCharacterInput | CharacterSkillCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterSkillUpsertWithWhereUniqueWithoutCharacterInput | CharacterSkillUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterSkillCreateManyCharacterInputEnvelope
    set?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    disconnect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    delete?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    update?: CharacterSkillUpdateWithWhereUniqueWithoutCharacterInput | CharacterSkillUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterSkillUpdateManyWithWhereWithoutCharacterInput | CharacterSkillUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterSkillScalarWhereInput | CharacterSkillScalarWhereInput[]
  }

  export type CharacterEquipmentUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterEquipmentCreateWithoutCharacterInput, CharacterEquipmentUncheckedCreateWithoutCharacterInput> | CharacterEquipmentCreateWithoutCharacterInput[] | CharacterEquipmentUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterEquipmentCreateOrConnectWithoutCharacterInput | CharacterEquipmentCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterEquipmentUpsertWithWhereUniqueWithoutCharacterInput | CharacterEquipmentUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterEquipmentCreateManyCharacterInputEnvelope
    set?: CharacterEquipmentWhereUniqueInput | CharacterEquipmentWhereUniqueInput[]
    disconnect?: CharacterEquipmentWhereUniqueInput | CharacterEquipmentWhereUniqueInput[]
    delete?: CharacterEquipmentWhereUniqueInput | CharacterEquipmentWhereUniqueInput[]
    connect?: CharacterEquipmentWhereUniqueInput | CharacterEquipmentWhereUniqueInput[]
    update?: CharacterEquipmentUpdateWithWhereUniqueWithoutCharacterInput | CharacterEquipmentUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterEquipmentUpdateManyWithWhereWithoutCharacterInput | CharacterEquipmentUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterEquipmentScalarWhereInput | CharacterEquipmentScalarWhereInput[]
  }

  export type LifeEventUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<LifeEventCreateWithoutCharacterInput, LifeEventUncheckedCreateWithoutCharacterInput> | LifeEventCreateWithoutCharacterInput[] | LifeEventUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: LifeEventCreateOrConnectWithoutCharacterInput | LifeEventCreateOrConnectWithoutCharacterInput[]
    upsert?: LifeEventUpsertWithWhereUniqueWithoutCharacterInput | LifeEventUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: LifeEventCreateManyCharacterInputEnvelope
    set?: LifeEventWhereUniqueInput | LifeEventWhereUniqueInput[]
    disconnect?: LifeEventWhereUniqueInput | LifeEventWhereUniqueInput[]
    delete?: LifeEventWhereUniqueInput | LifeEventWhereUniqueInput[]
    connect?: LifeEventWhereUniqueInput | LifeEventWhereUniqueInput[]
    update?: LifeEventUpdateWithWhereUniqueWithoutCharacterInput | LifeEventUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: LifeEventUpdateManyWithWhereWithoutCharacterInput | LifeEventUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: LifeEventScalarWhereInput | LifeEventScalarWhereInput[]
  }

  export type CombatActionUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CombatActionCreateWithoutCharacterInput, CombatActionUncheckedCreateWithoutCharacterInput> | CombatActionCreateWithoutCharacterInput[] | CombatActionUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CombatActionCreateOrConnectWithoutCharacterInput | CombatActionCreateOrConnectWithoutCharacterInput[]
    upsert?: CombatActionUpsertWithWhereUniqueWithoutCharacterInput | CombatActionUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CombatActionCreateManyCharacterInputEnvelope
    set?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
    disconnect?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
    delete?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
    connect?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
    update?: CombatActionUpdateWithWhereUniqueWithoutCharacterInput | CombatActionUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CombatActionUpdateManyWithWhereWithoutCharacterInput | CombatActionUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CombatActionScalarWhereInput | CombatActionScalarWhereInput[]
  }

  export type CharacteristicsUncheckedUpdateOneWithoutCharacterNestedInput = {
    create?: XOR<CharacteristicsCreateWithoutCharacterInput, CharacteristicsUncheckedCreateWithoutCharacterInput>
    connectOrCreate?: CharacteristicsCreateOrConnectWithoutCharacterInput
    upsert?: CharacteristicsUpsertWithoutCharacterInput
    disconnect?: CharacteristicsWhereInput | boolean
    delete?: CharacteristicsWhereInput | boolean
    connect?: CharacteristicsWhereUniqueInput
    update?: XOR<XOR<CharacteristicsUpdateToOneWithWhereWithoutCharacterInput, CharacteristicsUpdateWithoutCharacterInput>, CharacteristicsUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterSkillCreateWithoutCharacterInput, CharacterSkillUncheckedCreateWithoutCharacterInput> | CharacterSkillCreateWithoutCharacterInput[] | CharacterSkillUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterSkillCreateOrConnectWithoutCharacterInput | CharacterSkillCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterSkillUpsertWithWhereUniqueWithoutCharacterInput | CharacterSkillUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterSkillCreateManyCharacterInputEnvelope
    set?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    disconnect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    delete?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    connect?: CharacterSkillWhereUniqueInput | CharacterSkillWhereUniqueInput[]
    update?: CharacterSkillUpdateWithWhereUniqueWithoutCharacterInput | CharacterSkillUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterSkillUpdateManyWithWhereWithoutCharacterInput | CharacterSkillUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterSkillScalarWhereInput | CharacterSkillScalarWhereInput[]
  }

  export type CharacterEquipmentUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterEquipmentCreateWithoutCharacterInput, CharacterEquipmentUncheckedCreateWithoutCharacterInput> | CharacterEquipmentCreateWithoutCharacterInput[] | CharacterEquipmentUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterEquipmentCreateOrConnectWithoutCharacterInput | CharacterEquipmentCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterEquipmentUpsertWithWhereUniqueWithoutCharacterInput | CharacterEquipmentUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterEquipmentCreateManyCharacterInputEnvelope
    set?: CharacterEquipmentWhereUniqueInput | CharacterEquipmentWhereUniqueInput[]
    disconnect?: CharacterEquipmentWhereUniqueInput | CharacterEquipmentWhereUniqueInput[]
    delete?: CharacterEquipmentWhereUniqueInput | CharacterEquipmentWhereUniqueInput[]
    connect?: CharacterEquipmentWhereUniqueInput | CharacterEquipmentWhereUniqueInput[]
    update?: CharacterEquipmentUpdateWithWhereUniqueWithoutCharacterInput | CharacterEquipmentUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterEquipmentUpdateManyWithWhereWithoutCharacterInput | CharacterEquipmentUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterEquipmentScalarWhereInput | CharacterEquipmentScalarWhereInput[]
  }

  export type LifeEventUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<LifeEventCreateWithoutCharacterInput, LifeEventUncheckedCreateWithoutCharacterInput> | LifeEventCreateWithoutCharacterInput[] | LifeEventUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: LifeEventCreateOrConnectWithoutCharacterInput | LifeEventCreateOrConnectWithoutCharacterInput[]
    upsert?: LifeEventUpsertWithWhereUniqueWithoutCharacterInput | LifeEventUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: LifeEventCreateManyCharacterInputEnvelope
    set?: LifeEventWhereUniqueInput | LifeEventWhereUniqueInput[]
    disconnect?: LifeEventWhereUniqueInput | LifeEventWhereUniqueInput[]
    delete?: LifeEventWhereUniqueInput | LifeEventWhereUniqueInput[]
    connect?: LifeEventWhereUniqueInput | LifeEventWhereUniqueInput[]
    update?: LifeEventUpdateWithWhereUniqueWithoutCharacterInput | LifeEventUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: LifeEventUpdateManyWithWhereWithoutCharacterInput | LifeEventUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: LifeEventScalarWhereInput | LifeEventScalarWhereInput[]
  }

  export type CombatActionUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CombatActionCreateWithoutCharacterInput, CombatActionUncheckedCreateWithoutCharacterInput> | CombatActionCreateWithoutCharacterInput[] | CombatActionUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CombatActionCreateOrConnectWithoutCharacterInput | CombatActionCreateOrConnectWithoutCharacterInput[]
    upsert?: CombatActionUpsertWithWhereUniqueWithoutCharacterInput | CombatActionUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CombatActionCreateManyCharacterInputEnvelope
    set?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
    disconnect?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
    delete?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
    connect?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
    update?: CombatActionUpdateWithWhereUniqueWithoutCharacterInput | CombatActionUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CombatActionUpdateManyWithWhereWithoutCharacterInput | CombatActionUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CombatActionScalarWhereInput | CombatActionScalarWhereInput[]
  }

  export type CharacterCreateNestedOneWithoutCharacteristicsInput = {
    create?: XOR<CharacterCreateWithoutCharacteristicsInput, CharacterUncheckedCreateWithoutCharacteristicsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutCharacteristicsInput
    connect?: CharacterWhereUniqueInput
  }

  export type CharacterUpdateOneRequiredWithoutCharacteristicsNestedInput = {
    create?: XOR<CharacterCreateWithoutCharacteristicsInput, CharacterUncheckedCreateWithoutCharacteristicsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutCharacteristicsInput
    upsert?: CharacterUpsertWithoutCharacteristicsInput
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutCharacteristicsInput, CharacterUpdateWithoutCharacteristicsInput>, CharacterUncheckedUpdateWithoutCharacteristicsInput>
  }

  export type CharacterCreateNestedOneWithoutSkillsInput = {
    create?: XOR<CharacterCreateWithoutSkillsInput, CharacterUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutSkillsInput
    connect?: CharacterWhereUniqueInput
  }

  export type CharacterUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<CharacterCreateWithoutSkillsInput, CharacterUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutSkillsInput
    upsert?: CharacterUpsertWithoutSkillsInput
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutSkillsInput, CharacterUpdateWithoutSkillsInput>, CharacterUncheckedUpdateWithoutSkillsInput>
  }

  export type CharacterCreateNestedOneWithoutEquipmentInput = {
    create?: XOR<CharacterCreateWithoutEquipmentInput, CharacterUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutEquipmentInput
    connect?: CharacterWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CharacterUpdateOneRequiredWithoutEquipmentNestedInput = {
    create?: XOR<CharacterCreateWithoutEquipmentInput, CharacterUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutEquipmentInput
    upsert?: CharacterUpsertWithoutEquipmentInput
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutEquipmentInput, CharacterUpdateWithoutEquipmentInput>, CharacterUncheckedUpdateWithoutEquipmentInput>
  }

  export type LifeEventCreateskillsInput = {
    set: string[]
  }

  export type CharacterCreateNestedOneWithoutLifeEventsInput = {
    create?: XOR<CharacterCreateWithoutLifeEventsInput, CharacterUncheckedCreateWithoutLifeEventsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutLifeEventsInput
    connect?: CharacterWhereUniqueInput
  }

  export type LifeEventUpdateskillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CharacterUpdateOneRequiredWithoutLifeEventsNestedInput = {
    create?: XOR<CharacterCreateWithoutLifeEventsInput, CharacterUncheckedCreateWithoutLifeEventsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutLifeEventsInput
    upsert?: CharacterUpsertWithoutLifeEventsInput
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutLifeEventsInput, CharacterUpdateWithoutLifeEventsInput>, CharacterUncheckedUpdateWithoutLifeEventsInput>
  }

  export type StarSystemCreatejumpRoutesInput = {
    set: string[]
  }

  export type CampaignCreateNestedOneWithoutStarSystemsInput = {
    create?: XOR<CampaignCreateWithoutStarSystemsInput, CampaignUncheckedCreateWithoutStarSystemsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutStarSystemsInput
    connect?: CampaignWhereUniqueInput
  }

  export type PlanetCreateNestedManyWithoutStarSystemInput = {
    create?: XOR<PlanetCreateWithoutStarSystemInput, PlanetUncheckedCreateWithoutStarSystemInput> | PlanetCreateWithoutStarSystemInput[] | PlanetUncheckedCreateWithoutStarSystemInput[]
    connectOrCreate?: PlanetCreateOrConnectWithoutStarSystemInput | PlanetCreateOrConnectWithoutStarSystemInput[]
    createMany?: PlanetCreateManyStarSystemInputEnvelope
    connect?: PlanetWhereUniqueInput | PlanetWhereUniqueInput[]
  }

  export type TradeRouteCreateNestedManyWithoutOriginInput = {
    create?: XOR<TradeRouteCreateWithoutOriginInput, TradeRouteUncheckedCreateWithoutOriginInput> | TradeRouteCreateWithoutOriginInput[] | TradeRouteUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: TradeRouteCreateOrConnectWithoutOriginInput | TradeRouteCreateOrConnectWithoutOriginInput[]
    createMany?: TradeRouteCreateManyOriginInputEnvelope
    connect?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
  }

  export type TradeRouteCreateNestedManyWithoutDestinationInput = {
    create?: XOR<TradeRouteCreateWithoutDestinationInput, TradeRouteUncheckedCreateWithoutDestinationInput> | TradeRouteCreateWithoutDestinationInput[] | TradeRouteUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: TradeRouteCreateOrConnectWithoutDestinationInput | TradeRouteCreateOrConnectWithoutDestinationInput[]
    createMany?: TradeRouteCreateManyDestinationInputEnvelope
    connect?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
  }

  export type PlanetUncheckedCreateNestedManyWithoutStarSystemInput = {
    create?: XOR<PlanetCreateWithoutStarSystemInput, PlanetUncheckedCreateWithoutStarSystemInput> | PlanetCreateWithoutStarSystemInput[] | PlanetUncheckedCreateWithoutStarSystemInput[]
    connectOrCreate?: PlanetCreateOrConnectWithoutStarSystemInput | PlanetCreateOrConnectWithoutStarSystemInput[]
    createMany?: PlanetCreateManyStarSystemInputEnvelope
    connect?: PlanetWhereUniqueInput | PlanetWhereUniqueInput[]
  }

  export type TradeRouteUncheckedCreateNestedManyWithoutOriginInput = {
    create?: XOR<TradeRouteCreateWithoutOriginInput, TradeRouteUncheckedCreateWithoutOriginInput> | TradeRouteCreateWithoutOriginInput[] | TradeRouteUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: TradeRouteCreateOrConnectWithoutOriginInput | TradeRouteCreateOrConnectWithoutOriginInput[]
    createMany?: TradeRouteCreateManyOriginInputEnvelope
    connect?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
  }

  export type TradeRouteUncheckedCreateNestedManyWithoutDestinationInput = {
    create?: XOR<TradeRouteCreateWithoutDestinationInput, TradeRouteUncheckedCreateWithoutDestinationInput> | TradeRouteCreateWithoutDestinationInput[] | TradeRouteUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: TradeRouteCreateOrConnectWithoutDestinationInput | TradeRouteCreateOrConnectWithoutDestinationInput[]
    createMany?: TradeRouteCreateManyDestinationInputEnvelope
    connect?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
  }

  export type StarSystemUpdatejumpRoutesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CampaignUpdateOneWithoutStarSystemsNestedInput = {
    create?: XOR<CampaignCreateWithoutStarSystemsInput, CampaignUncheckedCreateWithoutStarSystemsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutStarSystemsInput
    upsert?: CampaignUpsertWithoutStarSystemsInput
    disconnect?: CampaignWhereInput | boolean
    delete?: CampaignWhereInput | boolean
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutStarSystemsInput, CampaignUpdateWithoutStarSystemsInput>, CampaignUncheckedUpdateWithoutStarSystemsInput>
  }

  export type PlanetUpdateManyWithoutStarSystemNestedInput = {
    create?: XOR<PlanetCreateWithoutStarSystemInput, PlanetUncheckedCreateWithoutStarSystemInput> | PlanetCreateWithoutStarSystemInput[] | PlanetUncheckedCreateWithoutStarSystemInput[]
    connectOrCreate?: PlanetCreateOrConnectWithoutStarSystemInput | PlanetCreateOrConnectWithoutStarSystemInput[]
    upsert?: PlanetUpsertWithWhereUniqueWithoutStarSystemInput | PlanetUpsertWithWhereUniqueWithoutStarSystemInput[]
    createMany?: PlanetCreateManyStarSystemInputEnvelope
    set?: PlanetWhereUniqueInput | PlanetWhereUniqueInput[]
    disconnect?: PlanetWhereUniqueInput | PlanetWhereUniqueInput[]
    delete?: PlanetWhereUniqueInput | PlanetWhereUniqueInput[]
    connect?: PlanetWhereUniqueInput | PlanetWhereUniqueInput[]
    update?: PlanetUpdateWithWhereUniqueWithoutStarSystemInput | PlanetUpdateWithWhereUniqueWithoutStarSystemInput[]
    updateMany?: PlanetUpdateManyWithWhereWithoutStarSystemInput | PlanetUpdateManyWithWhereWithoutStarSystemInput[]
    deleteMany?: PlanetScalarWhereInput | PlanetScalarWhereInput[]
  }

  export type TradeRouteUpdateManyWithoutOriginNestedInput = {
    create?: XOR<TradeRouteCreateWithoutOriginInput, TradeRouteUncheckedCreateWithoutOriginInput> | TradeRouteCreateWithoutOriginInput[] | TradeRouteUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: TradeRouteCreateOrConnectWithoutOriginInput | TradeRouteCreateOrConnectWithoutOriginInput[]
    upsert?: TradeRouteUpsertWithWhereUniqueWithoutOriginInput | TradeRouteUpsertWithWhereUniqueWithoutOriginInput[]
    createMany?: TradeRouteCreateManyOriginInputEnvelope
    set?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
    disconnect?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
    delete?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
    connect?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
    update?: TradeRouteUpdateWithWhereUniqueWithoutOriginInput | TradeRouteUpdateWithWhereUniqueWithoutOriginInput[]
    updateMany?: TradeRouteUpdateManyWithWhereWithoutOriginInput | TradeRouteUpdateManyWithWhereWithoutOriginInput[]
    deleteMany?: TradeRouteScalarWhereInput | TradeRouteScalarWhereInput[]
  }

  export type TradeRouteUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<TradeRouteCreateWithoutDestinationInput, TradeRouteUncheckedCreateWithoutDestinationInput> | TradeRouteCreateWithoutDestinationInput[] | TradeRouteUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: TradeRouteCreateOrConnectWithoutDestinationInput | TradeRouteCreateOrConnectWithoutDestinationInput[]
    upsert?: TradeRouteUpsertWithWhereUniqueWithoutDestinationInput | TradeRouteUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: TradeRouteCreateManyDestinationInputEnvelope
    set?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
    disconnect?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
    delete?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
    connect?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
    update?: TradeRouteUpdateWithWhereUniqueWithoutDestinationInput | TradeRouteUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: TradeRouteUpdateManyWithWhereWithoutDestinationInput | TradeRouteUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: TradeRouteScalarWhereInput | TradeRouteScalarWhereInput[]
  }

  export type PlanetUncheckedUpdateManyWithoutStarSystemNestedInput = {
    create?: XOR<PlanetCreateWithoutStarSystemInput, PlanetUncheckedCreateWithoutStarSystemInput> | PlanetCreateWithoutStarSystemInput[] | PlanetUncheckedCreateWithoutStarSystemInput[]
    connectOrCreate?: PlanetCreateOrConnectWithoutStarSystemInput | PlanetCreateOrConnectWithoutStarSystemInput[]
    upsert?: PlanetUpsertWithWhereUniqueWithoutStarSystemInput | PlanetUpsertWithWhereUniqueWithoutStarSystemInput[]
    createMany?: PlanetCreateManyStarSystemInputEnvelope
    set?: PlanetWhereUniqueInput | PlanetWhereUniqueInput[]
    disconnect?: PlanetWhereUniqueInput | PlanetWhereUniqueInput[]
    delete?: PlanetWhereUniqueInput | PlanetWhereUniqueInput[]
    connect?: PlanetWhereUniqueInput | PlanetWhereUniqueInput[]
    update?: PlanetUpdateWithWhereUniqueWithoutStarSystemInput | PlanetUpdateWithWhereUniqueWithoutStarSystemInput[]
    updateMany?: PlanetUpdateManyWithWhereWithoutStarSystemInput | PlanetUpdateManyWithWhereWithoutStarSystemInput[]
    deleteMany?: PlanetScalarWhereInput | PlanetScalarWhereInput[]
  }

  export type TradeRouteUncheckedUpdateManyWithoutOriginNestedInput = {
    create?: XOR<TradeRouteCreateWithoutOriginInput, TradeRouteUncheckedCreateWithoutOriginInput> | TradeRouteCreateWithoutOriginInput[] | TradeRouteUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: TradeRouteCreateOrConnectWithoutOriginInput | TradeRouteCreateOrConnectWithoutOriginInput[]
    upsert?: TradeRouteUpsertWithWhereUniqueWithoutOriginInput | TradeRouteUpsertWithWhereUniqueWithoutOriginInput[]
    createMany?: TradeRouteCreateManyOriginInputEnvelope
    set?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
    disconnect?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
    delete?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
    connect?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
    update?: TradeRouteUpdateWithWhereUniqueWithoutOriginInput | TradeRouteUpdateWithWhereUniqueWithoutOriginInput[]
    updateMany?: TradeRouteUpdateManyWithWhereWithoutOriginInput | TradeRouteUpdateManyWithWhereWithoutOriginInput[]
    deleteMany?: TradeRouteScalarWhereInput | TradeRouteScalarWhereInput[]
  }

  export type TradeRouteUncheckedUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<TradeRouteCreateWithoutDestinationInput, TradeRouteUncheckedCreateWithoutDestinationInput> | TradeRouteCreateWithoutDestinationInput[] | TradeRouteUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: TradeRouteCreateOrConnectWithoutDestinationInput | TradeRouteCreateOrConnectWithoutDestinationInput[]
    upsert?: TradeRouteUpsertWithWhereUniqueWithoutDestinationInput | TradeRouteUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: TradeRouteCreateManyDestinationInputEnvelope
    set?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
    disconnect?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
    delete?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
    connect?: TradeRouteWhereUniqueInput | TradeRouteWhereUniqueInput[]
    update?: TradeRouteUpdateWithWhereUniqueWithoutDestinationInput | TradeRouteUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: TradeRouteUpdateManyWithWhereWithoutDestinationInput | TradeRouteUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: TradeRouteScalarWhereInput | TradeRouteScalarWhereInput[]
  }

  export type PlanetCreatetradeCodesInput = {
    set: string[]
  }

  export type PlanetCreatebasesInput = {
    set: string[]
  }

  export type StarSystemCreateNestedOneWithoutPlanetsInput = {
    create?: XOR<StarSystemCreateWithoutPlanetsInput, StarSystemUncheckedCreateWithoutPlanetsInput>
    connectOrCreate?: StarSystemCreateOrConnectWithoutPlanetsInput
    connect?: StarSystemWhereUniqueInput
  }

  export type TradeGoodCreateNestedManyWithoutPlanetInput = {
    create?: XOR<TradeGoodCreateWithoutPlanetInput, TradeGoodUncheckedCreateWithoutPlanetInput> | TradeGoodCreateWithoutPlanetInput[] | TradeGoodUncheckedCreateWithoutPlanetInput[]
    connectOrCreate?: TradeGoodCreateOrConnectWithoutPlanetInput | TradeGoodCreateOrConnectWithoutPlanetInput[]
    createMany?: TradeGoodCreateManyPlanetInputEnvelope
    connect?: TradeGoodWhereUniqueInput | TradeGoodWhereUniqueInput[]
  }

  export type TradeGoodUncheckedCreateNestedManyWithoutPlanetInput = {
    create?: XOR<TradeGoodCreateWithoutPlanetInput, TradeGoodUncheckedCreateWithoutPlanetInput> | TradeGoodCreateWithoutPlanetInput[] | TradeGoodUncheckedCreateWithoutPlanetInput[]
    connectOrCreate?: TradeGoodCreateOrConnectWithoutPlanetInput | TradeGoodCreateOrConnectWithoutPlanetInput[]
    createMany?: TradeGoodCreateManyPlanetInputEnvelope
    connect?: TradeGoodWhereUniqueInput | TradeGoodWhereUniqueInput[]
  }

  export type PlanetUpdatetradeCodesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PlanetUpdatebasesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type StarSystemUpdateOneRequiredWithoutPlanetsNestedInput = {
    create?: XOR<StarSystemCreateWithoutPlanetsInput, StarSystemUncheckedCreateWithoutPlanetsInput>
    connectOrCreate?: StarSystemCreateOrConnectWithoutPlanetsInput
    upsert?: StarSystemUpsertWithoutPlanetsInput
    connect?: StarSystemWhereUniqueInput
    update?: XOR<XOR<StarSystemUpdateToOneWithWhereWithoutPlanetsInput, StarSystemUpdateWithoutPlanetsInput>, StarSystemUncheckedUpdateWithoutPlanetsInput>
  }

  export type TradeGoodUpdateManyWithoutPlanetNestedInput = {
    create?: XOR<TradeGoodCreateWithoutPlanetInput, TradeGoodUncheckedCreateWithoutPlanetInput> | TradeGoodCreateWithoutPlanetInput[] | TradeGoodUncheckedCreateWithoutPlanetInput[]
    connectOrCreate?: TradeGoodCreateOrConnectWithoutPlanetInput | TradeGoodCreateOrConnectWithoutPlanetInput[]
    upsert?: TradeGoodUpsertWithWhereUniqueWithoutPlanetInput | TradeGoodUpsertWithWhereUniqueWithoutPlanetInput[]
    createMany?: TradeGoodCreateManyPlanetInputEnvelope
    set?: TradeGoodWhereUniqueInput | TradeGoodWhereUniqueInput[]
    disconnect?: TradeGoodWhereUniqueInput | TradeGoodWhereUniqueInput[]
    delete?: TradeGoodWhereUniqueInput | TradeGoodWhereUniqueInput[]
    connect?: TradeGoodWhereUniqueInput | TradeGoodWhereUniqueInput[]
    update?: TradeGoodUpdateWithWhereUniqueWithoutPlanetInput | TradeGoodUpdateWithWhereUniqueWithoutPlanetInput[]
    updateMany?: TradeGoodUpdateManyWithWhereWithoutPlanetInput | TradeGoodUpdateManyWithWhereWithoutPlanetInput[]
    deleteMany?: TradeGoodScalarWhereInput | TradeGoodScalarWhereInput[]
  }

  export type TradeGoodUncheckedUpdateManyWithoutPlanetNestedInput = {
    create?: XOR<TradeGoodCreateWithoutPlanetInput, TradeGoodUncheckedCreateWithoutPlanetInput> | TradeGoodCreateWithoutPlanetInput[] | TradeGoodUncheckedCreateWithoutPlanetInput[]
    connectOrCreate?: TradeGoodCreateOrConnectWithoutPlanetInput | TradeGoodCreateOrConnectWithoutPlanetInput[]
    upsert?: TradeGoodUpsertWithWhereUniqueWithoutPlanetInput | TradeGoodUpsertWithWhereUniqueWithoutPlanetInput[]
    createMany?: TradeGoodCreateManyPlanetInputEnvelope
    set?: TradeGoodWhereUniqueInput | TradeGoodWhereUniqueInput[]
    disconnect?: TradeGoodWhereUniqueInput | TradeGoodWhereUniqueInput[]
    delete?: TradeGoodWhereUniqueInput | TradeGoodWhereUniqueInput[]
    connect?: TradeGoodWhereUniqueInput | TradeGoodWhereUniqueInput[]
    update?: TradeGoodUpdateWithWhereUniqueWithoutPlanetInput | TradeGoodUpdateWithWhereUniqueWithoutPlanetInput[]
    updateMany?: TradeGoodUpdateManyWithWhereWithoutPlanetInput | TradeGoodUpdateManyWithWhereWithoutPlanetInput[]
    deleteMany?: TradeGoodScalarWhereInput | TradeGoodScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutStarshipsInput = {
    create?: XOR<CampaignCreateWithoutStarshipsInput, CampaignUncheckedCreateWithoutStarshipsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutStarshipsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneWithoutStarshipsNestedInput = {
    create?: XOR<CampaignCreateWithoutStarshipsInput, CampaignUncheckedCreateWithoutStarshipsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutStarshipsInput
    upsert?: CampaignUpsertWithoutStarshipsInput
    disconnect?: CampaignWhereInput | boolean
    delete?: CampaignWhereInput | boolean
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutStarshipsInput, CampaignUpdateWithoutStarshipsInput>, CampaignUncheckedUpdateWithoutStarshipsInput>
  }

  export type PlanetCreateNestedOneWithoutTradeGoodsInput = {
    create?: XOR<PlanetCreateWithoutTradeGoodsInput, PlanetUncheckedCreateWithoutTradeGoodsInput>
    connectOrCreate?: PlanetCreateOrConnectWithoutTradeGoodsInput
    connect?: PlanetWhereUniqueInput
  }

  export type PlanetUpdateOneWithoutTradeGoodsNestedInput = {
    create?: XOR<PlanetCreateWithoutTradeGoodsInput, PlanetUncheckedCreateWithoutTradeGoodsInput>
    connectOrCreate?: PlanetCreateOrConnectWithoutTradeGoodsInput
    upsert?: PlanetUpsertWithoutTradeGoodsInput
    disconnect?: PlanetWhereInput | boolean
    delete?: PlanetWhereInput | boolean
    connect?: PlanetWhereUniqueInput
    update?: XOR<XOR<PlanetUpdateToOneWithWhereWithoutTradeGoodsInput, PlanetUpdateWithoutTradeGoodsInput>, PlanetUncheckedUpdateWithoutTradeGoodsInput>
  }

  export type TradeRouteCreatecargoTypesInput = {
    set: string[]
  }

  export type StarSystemCreateNestedOneWithoutTradeRoutesInput = {
    create?: XOR<StarSystemCreateWithoutTradeRoutesInput, StarSystemUncheckedCreateWithoutTradeRoutesInput>
    connectOrCreate?: StarSystemCreateOrConnectWithoutTradeRoutesInput
    connect?: StarSystemWhereUniqueInput
  }

  export type StarSystemCreateNestedOneWithoutTradeRoutesDestinationInput = {
    create?: XOR<StarSystemCreateWithoutTradeRoutesDestinationInput, StarSystemUncheckedCreateWithoutTradeRoutesDestinationInput>
    connectOrCreate?: StarSystemCreateOrConnectWithoutTradeRoutesDestinationInput
    connect?: StarSystemWhereUniqueInput
  }

  export type TradeRouteUpdatecargoTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type StarSystemUpdateOneRequiredWithoutTradeRoutesNestedInput = {
    create?: XOR<StarSystemCreateWithoutTradeRoutesInput, StarSystemUncheckedCreateWithoutTradeRoutesInput>
    connectOrCreate?: StarSystemCreateOrConnectWithoutTradeRoutesInput
    upsert?: StarSystemUpsertWithoutTradeRoutesInput
    connect?: StarSystemWhereUniqueInput
    update?: XOR<XOR<StarSystemUpdateToOneWithWhereWithoutTradeRoutesInput, StarSystemUpdateWithoutTradeRoutesInput>, StarSystemUncheckedUpdateWithoutTradeRoutesInput>
  }

  export type StarSystemUpdateOneRequiredWithoutTradeRoutesDestinationNestedInput = {
    create?: XOR<StarSystemCreateWithoutTradeRoutesDestinationInput, StarSystemUncheckedCreateWithoutTradeRoutesDestinationInput>
    connectOrCreate?: StarSystemCreateOrConnectWithoutTradeRoutesDestinationInput
    upsert?: StarSystemUpsertWithoutTradeRoutesDestinationInput
    connect?: StarSystemWhereUniqueInput
    update?: XOR<XOR<StarSystemUpdateToOneWithWhereWithoutTradeRoutesDestinationInput, StarSystemUpdateWithoutTradeRoutesDestinationInput>, StarSystemUncheckedUpdateWithoutTradeRoutesDestinationInput>
  }

  export type SessionCreateparticipantsInput = {
    set: string[]
  }

  export type CampaignCreateNestedOneWithoutSessionsInput = {
    create?: XOR<CampaignCreateWithoutSessionsInput, CampaignUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutSessionsInput
    connect?: CampaignWhereUniqueInput
  }

  export type EncounterCreateNestedManyWithoutSessionInput = {
    create?: XOR<EncounterCreateWithoutSessionInput, EncounterUncheckedCreateWithoutSessionInput> | EncounterCreateWithoutSessionInput[] | EncounterUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutSessionInput | EncounterCreateOrConnectWithoutSessionInput[]
    createMany?: EncounterCreateManySessionInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type CombatSessionCreateNestedManyWithoutSessionInput = {
    create?: XOR<CombatSessionCreateWithoutSessionInput, CombatSessionUncheckedCreateWithoutSessionInput> | CombatSessionCreateWithoutSessionInput[] | CombatSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CombatSessionCreateOrConnectWithoutSessionInput | CombatSessionCreateOrConnectWithoutSessionInput[]
    createMany?: CombatSessionCreateManySessionInputEnvelope
    connect?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
  }

  export type SessionNoteCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionNoteCreateWithoutSessionInput, SessionNoteUncheckedCreateWithoutSessionInput> | SessionNoteCreateWithoutSessionInput[] | SessionNoteUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionNoteCreateOrConnectWithoutSessionInput | SessionNoteCreateOrConnectWithoutSessionInput[]
    createMany?: SessionNoteCreateManySessionInputEnvelope
    connect?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<EncounterCreateWithoutSessionInput, EncounterUncheckedCreateWithoutSessionInput> | EncounterCreateWithoutSessionInput[] | EncounterUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutSessionInput | EncounterCreateOrConnectWithoutSessionInput[]
    createMany?: EncounterCreateManySessionInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type CombatSessionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<CombatSessionCreateWithoutSessionInput, CombatSessionUncheckedCreateWithoutSessionInput> | CombatSessionCreateWithoutSessionInput[] | CombatSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CombatSessionCreateOrConnectWithoutSessionInput | CombatSessionCreateOrConnectWithoutSessionInput[]
    createMany?: CombatSessionCreateManySessionInputEnvelope
    connect?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
  }

  export type SessionNoteUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionNoteCreateWithoutSessionInput, SessionNoteUncheckedCreateWithoutSessionInput> | SessionNoteCreateWithoutSessionInput[] | SessionNoteUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionNoteCreateOrConnectWithoutSessionInput | SessionNoteCreateOrConnectWithoutSessionInput[]
    createMany?: SessionNoteCreateManySessionInputEnvelope
    connect?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
  }

  export type EnumSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SessionStatus
  }

  export type SessionUpdateparticipantsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CampaignUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<CampaignCreateWithoutSessionsInput, CampaignUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutSessionsInput
    upsert?: CampaignUpsertWithoutSessionsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutSessionsInput, CampaignUpdateWithoutSessionsInput>, CampaignUncheckedUpdateWithoutSessionsInput>
  }

  export type EncounterUpdateManyWithoutSessionNestedInput = {
    create?: XOR<EncounterCreateWithoutSessionInput, EncounterUncheckedCreateWithoutSessionInput> | EncounterCreateWithoutSessionInput[] | EncounterUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutSessionInput | EncounterCreateOrConnectWithoutSessionInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutSessionInput | EncounterUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: EncounterCreateManySessionInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutSessionInput | EncounterUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutSessionInput | EncounterUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type CombatSessionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CombatSessionCreateWithoutSessionInput, CombatSessionUncheckedCreateWithoutSessionInput> | CombatSessionCreateWithoutSessionInput[] | CombatSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CombatSessionCreateOrConnectWithoutSessionInput | CombatSessionCreateOrConnectWithoutSessionInput[]
    upsert?: CombatSessionUpsertWithWhereUniqueWithoutSessionInput | CombatSessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CombatSessionCreateManySessionInputEnvelope
    set?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
    disconnect?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
    delete?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
    connect?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
    update?: CombatSessionUpdateWithWhereUniqueWithoutSessionInput | CombatSessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CombatSessionUpdateManyWithWhereWithoutSessionInput | CombatSessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CombatSessionScalarWhereInput | CombatSessionScalarWhereInput[]
  }

  export type SessionNoteUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionNoteCreateWithoutSessionInput, SessionNoteUncheckedCreateWithoutSessionInput> | SessionNoteCreateWithoutSessionInput[] | SessionNoteUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionNoteCreateOrConnectWithoutSessionInput | SessionNoteCreateOrConnectWithoutSessionInput[]
    upsert?: SessionNoteUpsertWithWhereUniqueWithoutSessionInput | SessionNoteUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionNoteCreateManySessionInputEnvelope
    set?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    disconnect?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    delete?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    connect?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    update?: SessionNoteUpdateWithWhereUniqueWithoutSessionInput | SessionNoteUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionNoteUpdateManyWithWhereWithoutSessionInput | SessionNoteUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionNoteScalarWhereInput | SessionNoteScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<EncounterCreateWithoutSessionInput, EncounterUncheckedCreateWithoutSessionInput> | EncounterCreateWithoutSessionInput[] | EncounterUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutSessionInput | EncounterCreateOrConnectWithoutSessionInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutSessionInput | EncounterUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: EncounterCreateManySessionInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutSessionInput | EncounterUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutSessionInput | EncounterUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type CombatSessionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CombatSessionCreateWithoutSessionInput, CombatSessionUncheckedCreateWithoutSessionInput> | CombatSessionCreateWithoutSessionInput[] | CombatSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CombatSessionCreateOrConnectWithoutSessionInput | CombatSessionCreateOrConnectWithoutSessionInput[]
    upsert?: CombatSessionUpsertWithWhereUniqueWithoutSessionInput | CombatSessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CombatSessionCreateManySessionInputEnvelope
    set?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
    disconnect?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
    delete?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
    connect?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
    update?: CombatSessionUpdateWithWhereUniqueWithoutSessionInput | CombatSessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CombatSessionUpdateManyWithWhereWithoutSessionInput | CombatSessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CombatSessionScalarWhereInput | CombatSessionScalarWhereInput[]
  }

  export type SessionNoteUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionNoteCreateWithoutSessionInput, SessionNoteUncheckedCreateWithoutSessionInput> | SessionNoteCreateWithoutSessionInput[] | SessionNoteUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionNoteCreateOrConnectWithoutSessionInput | SessionNoteCreateOrConnectWithoutSessionInput[]
    upsert?: SessionNoteUpsertWithWhereUniqueWithoutSessionInput | SessionNoteUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionNoteCreateManySessionInputEnvelope
    set?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    disconnect?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    delete?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    connect?: SessionNoteWhereUniqueInput | SessionNoteWhereUniqueInput[]
    update?: SessionNoteUpdateWithWhereUniqueWithoutSessionInput | SessionNoteUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionNoteUpdateManyWithWhereWithoutSessionInput | SessionNoteUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionNoteScalarWhereInput | SessionNoteScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutEncountersInput = {
    create?: XOR<CampaignCreateWithoutEncountersInput, CampaignUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutEncountersInput
    connect?: CampaignWhereUniqueInput
  }

  export type SessionCreateNestedOneWithoutEncountersInput = {
    create?: XOR<SessionCreateWithoutEncountersInput, SessionUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: SessionCreateOrConnectWithoutEncountersInput
    connect?: SessionWhereUniqueInput
  }

  export type CombatSessionCreateNestedManyWithoutEncounterInput = {
    create?: XOR<CombatSessionCreateWithoutEncounterInput, CombatSessionUncheckedCreateWithoutEncounterInput> | CombatSessionCreateWithoutEncounterInput[] | CombatSessionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: CombatSessionCreateOrConnectWithoutEncounterInput | CombatSessionCreateOrConnectWithoutEncounterInput[]
    createMany?: CombatSessionCreateManyEncounterInputEnvelope
    connect?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
  }

  export type CombatSessionUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<CombatSessionCreateWithoutEncounterInput, CombatSessionUncheckedCreateWithoutEncounterInput> | CombatSessionCreateWithoutEncounterInput[] | CombatSessionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: CombatSessionCreateOrConnectWithoutEncounterInput | CombatSessionCreateOrConnectWithoutEncounterInput[]
    createMany?: CombatSessionCreateManyEncounterInputEnvelope
    connect?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
  }

  export type CampaignUpdateOneRequiredWithoutEncountersNestedInput = {
    create?: XOR<CampaignCreateWithoutEncountersInput, CampaignUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutEncountersInput
    upsert?: CampaignUpsertWithoutEncountersInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutEncountersInput, CampaignUpdateWithoutEncountersInput>, CampaignUncheckedUpdateWithoutEncountersInput>
  }

  export type SessionUpdateOneWithoutEncountersNestedInput = {
    create?: XOR<SessionCreateWithoutEncountersInput, SessionUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: SessionCreateOrConnectWithoutEncountersInput
    upsert?: SessionUpsertWithoutEncountersInput
    disconnect?: SessionWhereInput | boolean
    delete?: SessionWhereInput | boolean
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutEncountersInput, SessionUpdateWithoutEncountersInput>, SessionUncheckedUpdateWithoutEncountersInput>
  }

  export type CombatSessionUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<CombatSessionCreateWithoutEncounterInput, CombatSessionUncheckedCreateWithoutEncounterInput> | CombatSessionCreateWithoutEncounterInput[] | CombatSessionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: CombatSessionCreateOrConnectWithoutEncounterInput | CombatSessionCreateOrConnectWithoutEncounterInput[]
    upsert?: CombatSessionUpsertWithWhereUniqueWithoutEncounterInput | CombatSessionUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: CombatSessionCreateManyEncounterInputEnvelope
    set?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
    disconnect?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
    delete?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
    connect?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
    update?: CombatSessionUpdateWithWhereUniqueWithoutEncounterInput | CombatSessionUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: CombatSessionUpdateManyWithWhereWithoutEncounterInput | CombatSessionUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: CombatSessionScalarWhereInput | CombatSessionScalarWhereInput[]
  }

  export type CombatSessionUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<CombatSessionCreateWithoutEncounterInput, CombatSessionUncheckedCreateWithoutEncounterInput> | CombatSessionCreateWithoutEncounterInput[] | CombatSessionUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: CombatSessionCreateOrConnectWithoutEncounterInput | CombatSessionCreateOrConnectWithoutEncounterInput[]
    upsert?: CombatSessionUpsertWithWhereUniqueWithoutEncounterInput | CombatSessionUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: CombatSessionCreateManyEncounterInputEnvelope
    set?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
    disconnect?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
    delete?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
    connect?: CombatSessionWhereUniqueInput | CombatSessionWhereUniqueInput[]
    update?: CombatSessionUpdateWithWhereUniqueWithoutEncounterInput | CombatSessionUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: CombatSessionUpdateManyWithWhereWithoutEncounterInput | CombatSessionUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: CombatSessionScalarWhereInput | CombatSessionScalarWhereInput[]
  }

  export type EncounterCreateNestedOneWithoutCombatSessionsInput = {
    create?: XOR<EncounterCreateWithoutCombatSessionsInput, EncounterUncheckedCreateWithoutCombatSessionsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutCombatSessionsInput
    connect?: EncounterWhereUniqueInput
  }

  export type SessionCreateNestedOneWithoutCombatSessionsInput = {
    create?: XOR<SessionCreateWithoutCombatSessionsInput, SessionUncheckedCreateWithoutCombatSessionsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutCombatSessionsInput
    connect?: SessionWhereUniqueInput
  }

  export type CombatActionCreateNestedManyWithoutCombatSessionInput = {
    create?: XOR<CombatActionCreateWithoutCombatSessionInput, CombatActionUncheckedCreateWithoutCombatSessionInput> | CombatActionCreateWithoutCombatSessionInput[] | CombatActionUncheckedCreateWithoutCombatSessionInput[]
    connectOrCreate?: CombatActionCreateOrConnectWithoutCombatSessionInput | CombatActionCreateOrConnectWithoutCombatSessionInput[]
    createMany?: CombatActionCreateManyCombatSessionInputEnvelope
    connect?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
  }

  export type CombatActionUncheckedCreateNestedManyWithoutCombatSessionInput = {
    create?: XOR<CombatActionCreateWithoutCombatSessionInput, CombatActionUncheckedCreateWithoutCombatSessionInput> | CombatActionCreateWithoutCombatSessionInput[] | CombatActionUncheckedCreateWithoutCombatSessionInput[]
    connectOrCreate?: CombatActionCreateOrConnectWithoutCombatSessionInput | CombatActionCreateOrConnectWithoutCombatSessionInput[]
    createMany?: CombatActionCreateManyCombatSessionInputEnvelope
    connect?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
  }

  export type EncounterUpdateOneWithoutCombatSessionsNestedInput = {
    create?: XOR<EncounterCreateWithoutCombatSessionsInput, EncounterUncheckedCreateWithoutCombatSessionsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutCombatSessionsInput
    upsert?: EncounterUpsertWithoutCombatSessionsInput
    disconnect?: EncounterWhereInput | boolean
    delete?: EncounterWhereInput | boolean
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutCombatSessionsInput, EncounterUpdateWithoutCombatSessionsInput>, EncounterUncheckedUpdateWithoutCombatSessionsInput>
  }

  export type SessionUpdateOneWithoutCombatSessionsNestedInput = {
    create?: XOR<SessionCreateWithoutCombatSessionsInput, SessionUncheckedCreateWithoutCombatSessionsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutCombatSessionsInput
    upsert?: SessionUpsertWithoutCombatSessionsInput
    disconnect?: SessionWhereInput | boolean
    delete?: SessionWhereInput | boolean
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutCombatSessionsInput, SessionUpdateWithoutCombatSessionsInput>, SessionUncheckedUpdateWithoutCombatSessionsInput>
  }

  export type CombatActionUpdateManyWithoutCombatSessionNestedInput = {
    create?: XOR<CombatActionCreateWithoutCombatSessionInput, CombatActionUncheckedCreateWithoutCombatSessionInput> | CombatActionCreateWithoutCombatSessionInput[] | CombatActionUncheckedCreateWithoutCombatSessionInput[]
    connectOrCreate?: CombatActionCreateOrConnectWithoutCombatSessionInput | CombatActionCreateOrConnectWithoutCombatSessionInput[]
    upsert?: CombatActionUpsertWithWhereUniqueWithoutCombatSessionInput | CombatActionUpsertWithWhereUniqueWithoutCombatSessionInput[]
    createMany?: CombatActionCreateManyCombatSessionInputEnvelope
    set?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
    disconnect?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
    delete?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
    connect?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
    update?: CombatActionUpdateWithWhereUniqueWithoutCombatSessionInput | CombatActionUpdateWithWhereUniqueWithoutCombatSessionInput[]
    updateMany?: CombatActionUpdateManyWithWhereWithoutCombatSessionInput | CombatActionUpdateManyWithWhereWithoutCombatSessionInput[]
    deleteMany?: CombatActionScalarWhereInput | CombatActionScalarWhereInput[]
  }

  export type CombatActionUncheckedUpdateManyWithoutCombatSessionNestedInput = {
    create?: XOR<CombatActionCreateWithoutCombatSessionInput, CombatActionUncheckedCreateWithoutCombatSessionInput> | CombatActionCreateWithoutCombatSessionInput[] | CombatActionUncheckedCreateWithoutCombatSessionInput[]
    connectOrCreate?: CombatActionCreateOrConnectWithoutCombatSessionInput | CombatActionCreateOrConnectWithoutCombatSessionInput[]
    upsert?: CombatActionUpsertWithWhereUniqueWithoutCombatSessionInput | CombatActionUpsertWithWhereUniqueWithoutCombatSessionInput[]
    createMany?: CombatActionCreateManyCombatSessionInputEnvelope
    set?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
    disconnect?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
    delete?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
    connect?: CombatActionWhereUniqueInput | CombatActionWhereUniqueInput[]
    update?: CombatActionUpdateWithWhereUniqueWithoutCombatSessionInput | CombatActionUpdateWithWhereUniqueWithoutCombatSessionInput[]
    updateMany?: CombatActionUpdateManyWithWhereWithoutCombatSessionInput | CombatActionUpdateManyWithWhereWithoutCombatSessionInput[]
    deleteMany?: CombatActionScalarWhereInput | CombatActionScalarWhereInput[]
  }

  export type CharacterCreateNestedOneWithoutCombatActionsInput = {
    create?: XOR<CharacterCreateWithoutCombatActionsInput, CharacterUncheckedCreateWithoutCombatActionsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutCombatActionsInput
    connect?: CharacterWhereUniqueInput
  }

  export type CombatSessionCreateNestedOneWithoutActionsInput = {
    create?: XOR<CombatSessionCreateWithoutActionsInput, CombatSessionUncheckedCreateWithoutActionsInput>
    connectOrCreate?: CombatSessionCreateOrConnectWithoutActionsInput
    connect?: CombatSessionWhereUniqueInput
  }

  export type CharacterUpdateOneWithoutCombatActionsNestedInput = {
    create?: XOR<CharacterCreateWithoutCombatActionsInput, CharacterUncheckedCreateWithoutCombatActionsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutCombatActionsInput
    upsert?: CharacterUpsertWithoutCombatActionsInput
    disconnect?: CharacterWhereInput | boolean
    delete?: CharacterWhereInput | boolean
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutCombatActionsInput, CharacterUpdateWithoutCombatActionsInput>, CharacterUncheckedUpdateWithoutCombatActionsInput>
  }

  export type CombatSessionUpdateOneRequiredWithoutActionsNestedInput = {
    create?: XOR<CombatSessionCreateWithoutActionsInput, CombatSessionUncheckedCreateWithoutActionsInput>
    connectOrCreate?: CombatSessionCreateOrConnectWithoutActionsInput
    upsert?: CombatSessionUpsertWithoutActionsInput
    connect?: CombatSessionWhereUniqueInput
    update?: XOR<XOR<CombatSessionUpdateToOneWithWhereWithoutActionsInput, CombatSessionUpdateWithoutActionsInput>, CombatSessionUncheckedUpdateWithoutActionsInput>
  }

  export type DiceRollCreateindividualInput = {
    set: number[]
  }

  export type DiceRollCreatemodifiersInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutDiceRollsInput = {
    create?: XOR<UserCreateWithoutDiceRollsInput, UserUncheckedCreateWithoutDiceRollsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDiceRollsInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutDiceRollsInput = {
    create?: XOR<CampaignCreateWithoutDiceRollsInput, CampaignUncheckedCreateWithoutDiceRollsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutDiceRollsInput
    connect?: CampaignWhereUniqueInput
  }

  export type DiceRollUpdateindividualInput = {
    set?: number[]
    push?: number | number[]
  }

  export type DiceRollUpdatemodifiersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutDiceRollsNestedInput = {
    create?: XOR<UserCreateWithoutDiceRollsInput, UserUncheckedCreateWithoutDiceRollsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDiceRollsInput
    upsert?: UserUpsertWithoutDiceRollsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDiceRollsInput, UserUpdateWithoutDiceRollsInput>, UserUncheckedUpdateWithoutDiceRollsInput>
  }

  export type CampaignUpdateOneRequiredWithoutDiceRollsNestedInput = {
    create?: XOR<CampaignCreateWithoutDiceRollsInput, CampaignUncheckedCreateWithoutDiceRollsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutDiceRollsInput
    upsert?: CampaignUpsertWithoutDiceRollsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutDiceRollsInput, CampaignUpdateWithoutDiceRollsInput>, CampaignUncheckedUpdateWithoutDiceRollsInput>
  }

  export type CustomContentCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutCustomContentInput = {
    create?: XOR<UserCreateWithoutCustomContentInput, UserUncheckedCreateWithoutCustomContentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomContentInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutCustomContentInput = {
    create?: XOR<CampaignCreateWithoutCustomContentInput, CampaignUncheckedCreateWithoutCustomContentInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCustomContentInput
    connect?: CampaignWhereUniqueInput
  }

  export type CustomContentUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutCustomContentNestedInput = {
    create?: XOR<UserCreateWithoutCustomContentInput, UserUncheckedCreateWithoutCustomContentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomContentInput
    upsert?: UserUpsertWithoutCustomContentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCustomContentInput, UserUpdateWithoutCustomContentInput>, UserUncheckedUpdateWithoutCustomContentInput>
  }

  export type CampaignUpdateOneWithoutCustomContentNestedInput = {
    create?: XOR<CampaignCreateWithoutCustomContentInput, CampaignUncheckedCreateWithoutCustomContentInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCustomContentInput
    upsert?: CampaignUpsertWithoutCustomContentInput
    disconnect?: CampaignWhereInput | boolean
    delete?: CampaignWhereInput | boolean
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutCustomContentInput, CampaignUpdateWithoutCustomContentInput>, CampaignUncheckedUpdateWithoutCustomContentInput>
  }

  export type CampaignCreateNestedOneWithoutHouseRulesDataInput = {
    create?: XOR<CampaignCreateWithoutHouseRulesDataInput, CampaignUncheckedCreateWithoutHouseRulesDataInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutHouseRulesDataInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutHouseRulesDataNestedInput = {
    create?: XOR<CampaignCreateWithoutHouseRulesDataInput, CampaignUncheckedCreateWithoutHouseRulesDataInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutHouseRulesDataInput
    upsert?: CampaignUpsertWithoutHouseRulesDataInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutHouseRulesDataInput, CampaignUpdateWithoutHouseRulesDataInput>, CampaignUncheckedUpdateWithoutHouseRulesDataInput>
  }

  export type HandoutCreaterecipientsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutHandoutsInput = {
    create?: XOR<UserCreateWithoutHandoutsInput, UserUncheckedCreateWithoutHandoutsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHandoutsInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutHandoutsInput = {
    create?: XOR<CampaignCreateWithoutHandoutsInput, CampaignUncheckedCreateWithoutHandoutsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutHandoutsInput
    connect?: CampaignWhereUniqueInput
  }

  export type HandoutUpdaterecipientsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutHandoutsNestedInput = {
    create?: XOR<UserCreateWithoutHandoutsInput, UserUncheckedCreateWithoutHandoutsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHandoutsInput
    upsert?: UserUpsertWithoutHandoutsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHandoutsInput, UserUpdateWithoutHandoutsInput>, UserUncheckedUpdateWithoutHandoutsInput>
  }

  export type CampaignUpdateOneRequiredWithoutHandoutsNestedInput = {
    create?: XOR<CampaignCreateWithoutHandoutsInput, CampaignUncheckedCreateWithoutHandoutsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutHandoutsInput
    upsert?: CampaignUpsertWithoutHandoutsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutHandoutsInput, CampaignUpdateWithoutHandoutsInput>, CampaignUncheckedUpdateWithoutHandoutsInput>
  }

  export type SessionNoteCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutSessionNotesInput = {
    create?: XOR<UserCreateWithoutSessionNotesInput, UserUncheckedCreateWithoutSessionNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionNotesInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutSessionNotesInput = {
    create?: XOR<CampaignCreateWithoutSessionNotesInput, CampaignUncheckedCreateWithoutSessionNotesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutSessionNotesInput
    connect?: CampaignWhereUniqueInput
  }

  export type SessionCreateNestedOneWithoutSessionNotesInput = {
    create?: XOR<SessionCreateWithoutSessionNotesInput, SessionUncheckedCreateWithoutSessionNotesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionNotesInput
    connect?: SessionWhereUniqueInput
  }

  export type SessionNoteUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutSessionNotesNestedInput = {
    create?: XOR<UserCreateWithoutSessionNotesInput, UserUncheckedCreateWithoutSessionNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionNotesInput
    upsert?: UserUpsertWithoutSessionNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionNotesInput, UserUpdateWithoutSessionNotesInput>, UserUncheckedUpdateWithoutSessionNotesInput>
  }

  export type CampaignUpdateOneRequiredWithoutSessionNotesNestedInput = {
    create?: XOR<CampaignCreateWithoutSessionNotesInput, CampaignUncheckedCreateWithoutSessionNotesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutSessionNotesInput
    upsert?: CampaignUpsertWithoutSessionNotesInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutSessionNotesInput, CampaignUpdateWithoutSessionNotesInput>, CampaignUncheckedUpdateWithoutSessionNotesInput>
  }

  export type SessionUpdateOneWithoutSessionNotesNestedInput = {
    create?: XOR<SessionCreateWithoutSessionNotesInput, SessionUncheckedCreateWithoutSessionNotesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionNotesInput
    upsert?: SessionUpsertWithoutSessionNotesInput
    disconnect?: SessionWhereInput | boolean
    delete?: SessionWhereInput | boolean
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutSessionNotesInput, SessionUpdateWithoutSessionNotesInput>, SessionUncheckedUpdateWithoutSessionNotesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCampaignRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignRole | EnumCampaignRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignRole[] | ListEnumCampaignRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignRole[] | ListEnumCampaignRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignRoleFilter<$PrismaModel> | $Enums.CampaignRole
  }

  export type NestedEnumCampaignRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignRole | EnumCampaignRoleFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignRole[] | ListEnumCampaignRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignRole[] | ListEnumCampaignRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignRoleWithAggregatesFilter<$PrismaModel> | $Enums.CampaignRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignRoleFilter<$PrismaModel>
    _max?: NestedEnumCampaignRoleFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CampaignCreateWithoutGamemasterInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CampaignMemberCreateNestedManyWithoutCampaignInput
    characters?: CharacterCreateNestedManyWithoutCampaignInput
    sessions?: SessionCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemCreateNestedManyWithoutCampaignInput
    starships?: StarshipCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleCreateNestedManyWithoutCampaignInput
    handouts?: HandoutCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutGamemasterInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CampaignMemberUncheckedCreateNestedManyWithoutCampaignInput
    characters?: CharacterUncheckedCreateNestedManyWithoutCampaignInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemUncheckedCreateNestedManyWithoutCampaignInput
    starships?: StarshipUncheckedCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentUncheckedCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleUncheckedCreateNestedManyWithoutCampaignInput
    handouts?: HandoutUncheckedCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutGamemasterInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutGamemasterInput, CampaignUncheckedCreateWithoutGamemasterInput>
  }

  export type CampaignCreateManyGamemasterInputEnvelope = {
    data: CampaignCreateManyGamemasterInput | CampaignCreateManyGamemasterInput[]
    skipDuplicates?: boolean
  }

  export type CampaignMemberCreateWithoutUserInput = {
    id?: string
    role?: $Enums.CampaignRole
    isActive?: boolean
    joinedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutMembersInput
  }

  export type CampaignMemberUncheckedCreateWithoutUserInput = {
    id?: string
    campaignId: string
    role?: $Enums.CampaignRole
    isActive?: boolean
    joinedAt?: Date | string
  }

  export type CampaignMemberCreateOrConnectWithoutUserInput = {
    where: CampaignMemberWhereUniqueInput
    create: XOR<CampaignMemberCreateWithoutUserInput, CampaignMemberUncheckedCreateWithoutUserInput>
  }

  export type CampaignMemberCreateManyUserInputEnvelope = {
    data: CampaignMemberCreateManyUserInput | CampaignMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CharacterCreateWithoutPlayerInput = {
    id?: string
    name: string
    credits?: number
    notes?: string | null
    portrait?: string | null
    homeworld?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutCharactersInput
    characteristics?: CharacteristicsCreateNestedOneWithoutCharacterInput
    skills?: CharacterSkillCreateNestedManyWithoutCharacterInput
    equipment?: CharacterEquipmentCreateNestedManyWithoutCharacterInput
    lifeEvents?: LifeEventCreateNestedManyWithoutCharacterInput
    combatActions?: CombatActionCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutPlayerInput = {
    id?: string
    name: string
    credits?: number
    notes?: string | null
    portrait?: string | null
    homeworld?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    characteristics?: CharacteristicsUncheckedCreateNestedOneWithoutCharacterInput
    skills?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    equipment?: CharacterEquipmentUncheckedCreateNestedManyWithoutCharacterInput
    lifeEvents?: LifeEventUncheckedCreateNestedManyWithoutCharacterInput
    combatActions?: CombatActionUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutPlayerInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutPlayerInput, CharacterUncheckedCreateWithoutPlayerInput>
  }

  export type CharacterCreateManyPlayerInputEnvelope = {
    data: CharacterCreateManyPlayerInput | CharacterCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type DiceRollCreateWithoutRollerInput = {
    id?: string
    dice: string
    result: number
    individual?: DiceRollCreateindividualInput | number[]
    modifiers?: DiceRollCreatemodifiersInput | string[]
    description?: string | null
    isPublic?: boolean
    isGMOnly?: boolean
    character?: string | null
    skill?: string | null
    timestamp?: Date | string
    campaign: CampaignCreateNestedOneWithoutDiceRollsInput
  }

  export type DiceRollUncheckedCreateWithoutRollerInput = {
    id?: string
    dice: string
    result: number
    individual?: DiceRollCreateindividualInput | number[]
    modifiers?: DiceRollCreatemodifiersInput | string[]
    description?: string | null
    isPublic?: boolean
    isGMOnly?: boolean
    campaignId: string
    character?: string | null
    skill?: string | null
    timestamp?: Date | string
  }

  export type DiceRollCreateOrConnectWithoutRollerInput = {
    where: DiceRollWhereUniqueInput
    create: XOR<DiceRollCreateWithoutRollerInput, DiceRollUncheckedCreateWithoutRollerInput>
  }

  export type DiceRollCreateManyRollerInputEnvelope = {
    data: DiceRollCreateManyRollerInput | DiceRollCreateManyRollerInput[]
    skipDuplicates?: boolean
  }

  export type CustomContentCreateWithoutAuthorInput = {
    id?: string
    title: string
    description?: string | null
    contentType: string
    category?: string | null
    data: JsonNullValueInput | InputJsonValue
    tags?: CustomContentCreatetagsInput | string[]
    isPublic?: boolean
    isOfficial?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutCustomContentInput
  }

  export type CustomContentUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    description?: string | null
    contentType: string
    category?: string | null
    data: JsonNullValueInput | InputJsonValue
    tags?: CustomContentCreatetagsInput | string[]
    isPublic?: boolean
    isOfficial?: boolean
    campaignId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomContentCreateOrConnectWithoutAuthorInput = {
    where: CustomContentWhereUniqueInput
    create: XOR<CustomContentCreateWithoutAuthorInput, CustomContentUncheckedCreateWithoutAuthorInput>
  }

  export type CustomContentCreateManyAuthorInputEnvelope = {
    data: CustomContentCreateManyAuthorInput | CustomContentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type SessionNoteCreateWithoutAuthorInput = {
    id?: string
    title?: string | null
    content: string
    noteType?: string
    tags?: SessionNoteCreatetagsInput | string[]
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutSessionNotesInput
    session?: SessionCreateNestedOneWithoutSessionNotesInput
  }

  export type SessionNoteUncheckedCreateWithoutAuthorInput = {
    id?: string
    title?: string | null
    content: string
    noteType?: string
    tags?: SessionNoteCreatetagsInput | string[]
    isPublic?: boolean
    campaignId: string
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionNoteCreateOrConnectWithoutAuthorInput = {
    where: SessionNoteWhereUniqueInput
    create: XOR<SessionNoteCreateWithoutAuthorInput, SessionNoteUncheckedCreateWithoutAuthorInput>
  }

  export type SessionNoteCreateManyAuthorInputEnvelope = {
    data: SessionNoteCreateManyAuthorInput | SessionNoteCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type HandoutCreateWithoutAuthorInput = {
    id?: string
    title: string
    description?: string | null
    content?: string | null
    imageUrl?: string | null
    fileUrl?: string | null
    isPlayerVisible?: boolean
    recipients?: HandoutCreaterecipientsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutHandoutsInput
  }

  export type HandoutUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    description?: string | null
    content?: string | null
    imageUrl?: string | null
    fileUrl?: string | null
    isPlayerVisible?: boolean
    recipients?: HandoutCreaterecipientsInput | string[]
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HandoutCreateOrConnectWithoutAuthorInput = {
    where: HandoutWhereUniqueInput
    create: XOR<HandoutCreateWithoutAuthorInput, HandoutUncheckedCreateWithoutAuthorInput>
  }

  export type HandoutCreateManyAuthorInputEnvelope = {
    data: HandoutCreateManyAuthorInput | HandoutCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CampaignUpsertWithWhereUniqueWithoutGamemasterInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutGamemasterInput, CampaignUncheckedUpdateWithoutGamemasterInput>
    create: XOR<CampaignCreateWithoutGamemasterInput, CampaignUncheckedCreateWithoutGamemasterInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutGamemasterInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutGamemasterInput, CampaignUncheckedUpdateWithoutGamemasterInput>
  }

  export type CampaignUpdateManyWithWhereWithoutGamemasterInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutGamemasterInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    maxPlayers?: IntNullableFilter<"Campaign"> | number | null
    isPublic?: BoolFilter<"Campaign"> | boolean
    allowedBooks?: StringNullableListFilter<"Campaign">
    houseRules?: JsonNullableFilter<"Campaign">
    gamemasterId?: StringFilter<"Campaign"> | string
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
  }

  export type CampaignMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: CampaignMemberWhereUniqueInput
    update: XOR<CampaignMemberUpdateWithoutUserInput, CampaignMemberUncheckedUpdateWithoutUserInput>
    create: XOR<CampaignMemberCreateWithoutUserInput, CampaignMemberUncheckedCreateWithoutUserInput>
  }

  export type CampaignMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: CampaignMemberWhereUniqueInput
    data: XOR<CampaignMemberUpdateWithoutUserInput, CampaignMemberUncheckedUpdateWithoutUserInput>
  }

  export type CampaignMemberUpdateManyWithWhereWithoutUserInput = {
    where: CampaignMemberScalarWhereInput
    data: XOR<CampaignMemberUpdateManyMutationInput, CampaignMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type CampaignMemberScalarWhereInput = {
    AND?: CampaignMemberScalarWhereInput | CampaignMemberScalarWhereInput[]
    OR?: CampaignMemberScalarWhereInput[]
    NOT?: CampaignMemberScalarWhereInput | CampaignMemberScalarWhereInput[]
    id?: StringFilter<"CampaignMember"> | string
    campaignId?: StringFilter<"CampaignMember"> | string
    userId?: StringFilter<"CampaignMember"> | string
    role?: EnumCampaignRoleFilter<"CampaignMember"> | $Enums.CampaignRole
    isActive?: BoolFilter<"CampaignMember"> | boolean
    joinedAt?: DateTimeFilter<"CampaignMember"> | Date | string
  }

  export type CharacterUpsertWithWhereUniqueWithoutPlayerInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutPlayerInput, CharacterUncheckedUpdateWithoutPlayerInput>
    create: XOR<CharacterCreateWithoutPlayerInput, CharacterUncheckedCreateWithoutPlayerInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutPlayerInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutPlayerInput, CharacterUncheckedUpdateWithoutPlayerInput>
  }

  export type CharacterUpdateManyWithWhereWithoutPlayerInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutPlayerInput>
  }

  export type CharacterScalarWhereInput = {
    AND?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
    OR?: CharacterScalarWhereInput[]
    NOT?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
    id?: StringFilter<"Character"> | string
    name?: StringFilter<"Character"> | string
    credits?: IntFilter<"Character"> | number
    notes?: StringNullableFilter<"Character"> | string | null
    portrait?: StringNullableFilter<"Character"> | string | null
    homeworld?: StringNullableFilter<"Character"> | string | null
    age?: IntNullableFilter<"Character"> | number | null
    gender?: StringNullableFilter<"Character"> | string | null
    species?: StringNullableFilter<"Character"> | string | null
    playerId?: StringFilter<"Character"> | string
    campaignId?: StringFilter<"Character"> | string
    createdAt?: DateTimeFilter<"Character"> | Date | string
    updatedAt?: DateTimeFilter<"Character"> | Date | string
  }

  export type DiceRollUpsertWithWhereUniqueWithoutRollerInput = {
    where: DiceRollWhereUniqueInput
    update: XOR<DiceRollUpdateWithoutRollerInput, DiceRollUncheckedUpdateWithoutRollerInput>
    create: XOR<DiceRollCreateWithoutRollerInput, DiceRollUncheckedCreateWithoutRollerInput>
  }

  export type DiceRollUpdateWithWhereUniqueWithoutRollerInput = {
    where: DiceRollWhereUniqueInput
    data: XOR<DiceRollUpdateWithoutRollerInput, DiceRollUncheckedUpdateWithoutRollerInput>
  }

  export type DiceRollUpdateManyWithWhereWithoutRollerInput = {
    where: DiceRollScalarWhereInput
    data: XOR<DiceRollUpdateManyMutationInput, DiceRollUncheckedUpdateManyWithoutRollerInput>
  }

  export type DiceRollScalarWhereInput = {
    AND?: DiceRollScalarWhereInput | DiceRollScalarWhereInput[]
    OR?: DiceRollScalarWhereInput[]
    NOT?: DiceRollScalarWhereInput | DiceRollScalarWhereInput[]
    id?: StringFilter<"DiceRoll"> | string
    dice?: StringFilter<"DiceRoll"> | string
    result?: IntFilter<"DiceRoll"> | number
    individual?: IntNullableListFilter<"DiceRoll">
    modifiers?: StringNullableListFilter<"DiceRoll">
    description?: StringNullableFilter<"DiceRoll"> | string | null
    isPublic?: BoolFilter<"DiceRoll"> | boolean
    isGMOnly?: BoolFilter<"DiceRoll"> | boolean
    rollerId?: StringFilter<"DiceRoll"> | string
    campaignId?: StringFilter<"DiceRoll"> | string
    character?: StringNullableFilter<"DiceRoll"> | string | null
    skill?: StringNullableFilter<"DiceRoll"> | string | null
    timestamp?: DateTimeFilter<"DiceRoll"> | Date | string
  }

  export type CustomContentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CustomContentWhereUniqueInput
    update: XOR<CustomContentUpdateWithoutAuthorInput, CustomContentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CustomContentCreateWithoutAuthorInput, CustomContentUncheckedCreateWithoutAuthorInput>
  }

  export type CustomContentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CustomContentWhereUniqueInput
    data: XOR<CustomContentUpdateWithoutAuthorInput, CustomContentUncheckedUpdateWithoutAuthorInput>
  }

  export type CustomContentUpdateManyWithWhereWithoutAuthorInput = {
    where: CustomContentScalarWhereInput
    data: XOR<CustomContentUpdateManyMutationInput, CustomContentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CustomContentScalarWhereInput = {
    AND?: CustomContentScalarWhereInput | CustomContentScalarWhereInput[]
    OR?: CustomContentScalarWhereInput[]
    NOT?: CustomContentScalarWhereInput | CustomContentScalarWhereInput[]
    id?: StringFilter<"CustomContent"> | string
    title?: StringFilter<"CustomContent"> | string
    description?: StringNullableFilter<"CustomContent"> | string | null
    contentType?: StringFilter<"CustomContent"> | string
    category?: StringNullableFilter<"CustomContent"> | string | null
    data?: JsonFilter<"CustomContent">
    tags?: StringNullableListFilter<"CustomContent">
    isPublic?: BoolFilter<"CustomContent"> | boolean
    isOfficial?: BoolFilter<"CustomContent"> | boolean
    authorId?: StringFilter<"CustomContent"> | string
    campaignId?: StringNullableFilter<"CustomContent"> | string | null
    createdAt?: DateTimeFilter<"CustomContent"> | Date | string
    updatedAt?: DateTimeFilter<"CustomContent"> | Date | string
  }

  export type SessionNoteUpsertWithWhereUniqueWithoutAuthorInput = {
    where: SessionNoteWhereUniqueInput
    update: XOR<SessionNoteUpdateWithoutAuthorInput, SessionNoteUncheckedUpdateWithoutAuthorInput>
    create: XOR<SessionNoteCreateWithoutAuthorInput, SessionNoteUncheckedCreateWithoutAuthorInput>
  }

  export type SessionNoteUpdateWithWhereUniqueWithoutAuthorInput = {
    where: SessionNoteWhereUniqueInput
    data: XOR<SessionNoteUpdateWithoutAuthorInput, SessionNoteUncheckedUpdateWithoutAuthorInput>
  }

  export type SessionNoteUpdateManyWithWhereWithoutAuthorInput = {
    where: SessionNoteScalarWhereInput
    data: XOR<SessionNoteUpdateManyMutationInput, SessionNoteUncheckedUpdateManyWithoutAuthorInput>
  }

  export type SessionNoteScalarWhereInput = {
    AND?: SessionNoteScalarWhereInput | SessionNoteScalarWhereInput[]
    OR?: SessionNoteScalarWhereInput[]
    NOT?: SessionNoteScalarWhereInput | SessionNoteScalarWhereInput[]
    id?: StringFilter<"SessionNote"> | string
    title?: StringNullableFilter<"SessionNote"> | string | null
    content?: StringFilter<"SessionNote"> | string
    noteType?: StringFilter<"SessionNote"> | string
    tags?: StringNullableListFilter<"SessionNote">
    isPublic?: BoolFilter<"SessionNote"> | boolean
    authorId?: StringFilter<"SessionNote"> | string
    campaignId?: StringFilter<"SessionNote"> | string
    sessionId?: StringNullableFilter<"SessionNote"> | string | null
    createdAt?: DateTimeFilter<"SessionNote"> | Date | string
    updatedAt?: DateTimeFilter<"SessionNote"> | Date | string
  }

  export type HandoutUpsertWithWhereUniqueWithoutAuthorInput = {
    where: HandoutWhereUniqueInput
    update: XOR<HandoutUpdateWithoutAuthorInput, HandoutUncheckedUpdateWithoutAuthorInput>
    create: XOR<HandoutCreateWithoutAuthorInput, HandoutUncheckedCreateWithoutAuthorInput>
  }

  export type HandoutUpdateWithWhereUniqueWithoutAuthorInput = {
    where: HandoutWhereUniqueInput
    data: XOR<HandoutUpdateWithoutAuthorInput, HandoutUncheckedUpdateWithoutAuthorInput>
  }

  export type HandoutUpdateManyWithWhereWithoutAuthorInput = {
    where: HandoutScalarWhereInput
    data: XOR<HandoutUpdateManyMutationInput, HandoutUncheckedUpdateManyWithoutAuthorInput>
  }

  export type HandoutScalarWhereInput = {
    AND?: HandoutScalarWhereInput | HandoutScalarWhereInput[]
    OR?: HandoutScalarWhereInput[]
    NOT?: HandoutScalarWhereInput | HandoutScalarWhereInput[]
    id?: StringFilter<"Handout"> | string
    title?: StringFilter<"Handout"> | string
    description?: StringNullableFilter<"Handout"> | string | null
    content?: StringNullableFilter<"Handout"> | string | null
    imageUrl?: StringNullableFilter<"Handout"> | string | null
    fileUrl?: StringNullableFilter<"Handout"> | string | null
    isPlayerVisible?: BoolFilter<"Handout"> | boolean
    recipients?: StringNullableListFilter<"Handout">
    authorId?: StringFilter<"Handout"> | string
    campaignId?: StringFilter<"Handout"> | string
    createdAt?: DateTimeFilter<"Handout"> | Date | string
    updatedAt?: DateTimeFilter<"Handout"> | Date | string
  }

  export type UserCreateWithoutOwnedCampaignsInput = {
    id?: string
    email: string
    displayName?: string | null
    avatar?: string | null
    timezone?: string
    subscriptionTier?: $Enums.SubscriptionTier
    cognitoUserId: string
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    campaignMembers?: CampaignMemberCreateNestedManyWithoutUserInput
    characters?: CharacterCreateNestedManyWithoutPlayerInput
    diceRolls?: DiceRollCreateNestedManyWithoutRollerInput
    customContent?: CustomContentCreateNestedManyWithoutAuthorInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutAuthorInput
    handouts?: HandoutCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutOwnedCampaignsInput = {
    id?: string
    email: string
    displayName?: string | null
    avatar?: string | null
    timezone?: string
    subscriptionTier?: $Enums.SubscriptionTier
    cognitoUserId: string
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    campaignMembers?: CampaignMemberUncheckedCreateNestedManyWithoutUserInput
    characters?: CharacterUncheckedCreateNestedManyWithoutPlayerInput
    diceRolls?: DiceRollUncheckedCreateNestedManyWithoutRollerInput
    customContent?: CustomContentUncheckedCreateNestedManyWithoutAuthorInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutAuthorInput
    handouts?: HandoutUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutOwnedCampaignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedCampaignsInput, UserUncheckedCreateWithoutOwnedCampaignsInput>
  }

  export type CampaignMemberCreateWithoutCampaignInput = {
    id?: string
    role?: $Enums.CampaignRole
    isActive?: boolean
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignMembersInput
  }

  export type CampaignMemberUncheckedCreateWithoutCampaignInput = {
    id?: string
    userId: string
    role?: $Enums.CampaignRole
    isActive?: boolean
    joinedAt?: Date | string
  }

  export type CampaignMemberCreateOrConnectWithoutCampaignInput = {
    where: CampaignMemberWhereUniqueInput
    create: XOR<CampaignMemberCreateWithoutCampaignInput, CampaignMemberUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignMemberCreateManyCampaignInputEnvelope = {
    data: CampaignMemberCreateManyCampaignInput | CampaignMemberCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CharacterCreateWithoutCampaignInput = {
    id?: string
    name: string
    credits?: number
    notes?: string | null
    portrait?: string | null
    homeworld?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: UserCreateNestedOneWithoutCharactersInput
    characteristics?: CharacteristicsCreateNestedOneWithoutCharacterInput
    skills?: CharacterSkillCreateNestedManyWithoutCharacterInput
    equipment?: CharacterEquipmentCreateNestedManyWithoutCharacterInput
    lifeEvents?: LifeEventCreateNestedManyWithoutCharacterInput
    combatActions?: CombatActionCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutCampaignInput = {
    id?: string
    name: string
    credits?: number
    notes?: string | null
    portrait?: string | null
    homeworld?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    playerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    characteristics?: CharacteristicsUncheckedCreateNestedOneWithoutCharacterInput
    skills?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    equipment?: CharacterEquipmentUncheckedCreateNestedManyWithoutCharacterInput
    lifeEvents?: LifeEventUncheckedCreateNestedManyWithoutCharacterInput
    combatActions?: CombatActionUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutCampaignInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutCampaignInput, CharacterUncheckedCreateWithoutCampaignInput>
  }

  export type CharacterCreateManyCampaignInputEnvelope = {
    data: CharacterCreateManyCampaignInput | CharacterCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutCampaignInput = {
    id?: string
    name: string
    scheduledFor?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.SessionStatus
    participants?: SessionCreateparticipantsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterCreateNestedManyWithoutSessionInput
    combatSessions?: CombatSessionCreateNestedManyWithoutSessionInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutCampaignInput = {
    id?: string
    name: string
    scheduledFor?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.SessionStatus
    participants?: SessionCreateparticipantsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterUncheckedCreateNestedManyWithoutSessionInput
    combatSessions?: CombatSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutCampaignInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutCampaignInput, SessionUncheckedCreateWithoutCampaignInput>
  }

  export type SessionCreateManyCampaignInputEnvelope = {
    data: SessionCreateManyCampaignInput | SessionCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type DiceRollCreateWithoutCampaignInput = {
    id?: string
    dice: string
    result: number
    individual?: DiceRollCreateindividualInput | number[]
    modifiers?: DiceRollCreatemodifiersInput | string[]
    description?: string | null
    isPublic?: boolean
    isGMOnly?: boolean
    character?: string | null
    skill?: string | null
    timestamp?: Date | string
    roller: UserCreateNestedOneWithoutDiceRollsInput
  }

  export type DiceRollUncheckedCreateWithoutCampaignInput = {
    id?: string
    dice: string
    result: number
    individual?: DiceRollCreateindividualInput | number[]
    modifiers?: DiceRollCreatemodifiersInput | string[]
    description?: string | null
    isPublic?: boolean
    isGMOnly?: boolean
    rollerId: string
    character?: string | null
    skill?: string | null
    timestamp?: Date | string
  }

  export type DiceRollCreateOrConnectWithoutCampaignInput = {
    where: DiceRollWhereUniqueInput
    create: XOR<DiceRollCreateWithoutCampaignInput, DiceRollUncheckedCreateWithoutCampaignInput>
  }

  export type DiceRollCreateManyCampaignInputEnvelope = {
    data: DiceRollCreateManyCampaignInput | DiceRollCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type EncounterCreateWithoutCampaignInput = {
    id?: string
    name: string
    description?: string | null
    encounterType: string
    difficulty?: number | null
    location?: string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    outcome?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session?: SessionCreateNestedOneWithoutEncountersInput
    combatSessions?: CombatSessionCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutCampaignInput = {
    id?: string
    name: string
    description?: string | null
    encounterType: string
    difficulty?: number | null
    location?: string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    outcome?: string | null
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    combatSessions?: CombatSessionUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutCampaignInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutCampaignInput, EncounterUncheckedCreateWithoutCampaignInput>
  }

  export type EncounterCreateManyCampaignInputEnvelope = {
    data: EncounterCreateManyCampaignInput | EncounterCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type StarSystemCreateWithoutCampaignInput = {
    id?: string
    name: string
    hexLocation: string
    sector: string
    subsector?: string | null
    allegiance?: string | null
    starType?: string | null
    gasGiants?: number
    jumpRoutes?: StarSystemCreatejumpRoutesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    planets?: PlanetCreateNestedManyWithoutStarSystemInput
    tradeRoutes?: TradeRouteCreateNestedManyWithoutOriginInput
    tradeRoutesDestination?: TradeRouteCreateNestedManyWithoutDestinationInput
  }

  export type StarSystemUncheckedCreateWithoutCampaignInput = {
    id?: string
    name: string
    hexLocation: string
    sector: string
    subsector?: string | null
    allegiance?: string | null
    starType?: string | null
    gasGiants?: number
    jumpRoutes?: StarSystemCreatejumpRoutesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    planets?: PlanetUncheckedCreateNestedManyWithoutStarSystemInput
    tradeRoutes?: TradeRouteUncheckedCreateNestedManyWithoutOriginInput
    tradeRoutesDestination?: TradeRouteUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type StarSystemCreateOrConnectWithoutCampaignInput = {
    where: StarSystemWhereUniqueInput
    create: XOR<StarSystemCreateWithoutCampaignInput, StarSystemUncheckedCreateWithoutCampaignInput>
  }

  export type StarSystemCreateManyCampaignInputEnvelope = {
    data: StarSystemCreateManyCampaignInput | StarSystemCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type StarshipCreateWithoutCampaignInput = {
    id?: string
    name: string
    class: string
    hullCode?: string | null
    tonnage: number
    jumpDrive?: number
    maneuverDrive?: number
    powerPlant?: number
    crew?: number
    passengers?: number
    cargo?: number
    fuel?: number
    armor?: number
    weapons?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    location?: string | null
    owner?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StarshipUncheckedCreateWithoutCampaignInput = {
    id?: string
    name: string
    class: string
    hullCode?: string | null
    tonnage: number
    jumpDrive?: number
    maneuverDrive?: number
    powerPlant?: number
    crew?: number
    passengers?: number
    cargo?: number
    fuel?: number
    armor?: number
    weapons?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    location?: string | null
    owner?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StarshipCreateOrConnectWithoutCampaignInput = {
    where: StarshipWhereUniqueInput
    create: XOR<StarshipCreateWithoutCampaignInput, StarshipUncheckedCreateWithoutCampaignInput>
  }

  export type StarshipCreateManyCampaignInputEnvelope = {
    data: StarshipCreateManyCampaignInput | StarshipCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CustomContentCreateWithoutCampaignInput = {
    id?: string
    title: string
    description?: string | null
    contentType: string
    category?: string | null
    data: JsonNullValueInput | InputJsonValue
    tags?: CustomContentCreatetagsInput | string[]
    isPublic?: boolean
    isOfficial?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutCustomContentInput
  }

  export type CustomContentUncheckedCreateWithoutCampaignInput = {
    id?: string
    title: string
    description?: string | null
    contentType: string
    category?: string | null
    data: JsonNullValueInput | InputJsonValue
    tags?: CustomContentCreatetagsInput | string[]
    isPublic?: boolean
    isOfficial?: boolean
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomContentCreateOrConnectWithoutCampaignInput = {
    where: CustomContentWhereUniqueInput
    create: XOR<CustomContentCreateWithoutCampaignInput, CustomContentUncheckedCreateWithoutCampaignInput>
  }

  export type CustomContentCreateManyCampaignInputEnvelope = {
    data: CustomContentCreateManyCampaignInput | CustomContentCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type HouseRuleCreateWithoutCampaignInput = {
    id?: string
    title: string
    description: string
    category: string
    ruleText: string
    pageReference?: string | null
    replaces?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HouseRuleUncheckedCreateWithoutCampaignInput = {
    id?: string
    title: string
    description: string
    category: string
    ruleText: string
    pageReference?: string | null
    replaces?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HouseRuleCreateOrConnectWithoutCampaignInput = {
    where: HouseRuleWhereUniqueInput
    create: XOR<HouseRuleCreateWithoutCampaignInput, HouseRuleUncheckedCreateWithoutCampaignInput>
  }

  export type HouseRuleCreateManyCampaignInputEnvelope = {
    data: HouseRuleCreateManyCampaignInput | HouseRuleCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type HandoutCreateWithoutCampaignInput = {
    id?: string
    title: string
    description?: string | null
    content?: string | null
    imageUrl?: string | null
    fileUrl?: string | null
    isPlayerVisible?: boolean
    recipients?: HandoutCreaterecipientsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutHandoutsInput
  }

  export type HandoutUncheckedCreateWithoutCampaignInput = {
    id?: string
    title: string
    description?: string | null
    content?: string | null
    imageUrl?: string | null
    fileUrl?: string | null
    isPlayerVisible?: boolean
    recipients?: HandoutCreaterecipientsInput | string[]
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HandoutCreateOrConnectWithoutCampaignInput = {
    where: HandoutWhereUniqueInput
    create: XOR<HandoutCreateWithoutCampaignInput, HandoutUncheckedCreateWithoutCampaignInput>
  }

  export type HandoutCreateManyCampaignInputEnvelope = {
    data: HandoutCreateManyCampaignInput | HandoutCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type SessionNoteCreateWithoutCampaignInput = {
    id?: string
    title?: string | null
    content: string
    noteType?: string
    tags?: SessionNoteCreatetagsInput | string[]
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutSessionNotesInput
    session?: SessionCreateNestedOneWithoutSessionNotesInput
  }

  export type SessionNoteUncheckedCreateWithoutCampaignInput = {
    id?: string
    title?: string | null
    content: string
    noteType?: string
    tags?: SessionNoteCreatetagsInput | string[]
    isPublic?: boolean
    authorId: string
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionNoteCreateOrConnectWithoutCampaignInput = {
    where: SessionNoteWhereUniqueInput
    create: XOR<SessionNoteCreateWithoutCampaignInput, SessionNoteUncheckedCreateWithoutCampaignInput>
  }

  export type SessionNoteCreateManyCampaignInputEnvelope = {
    data: SessionNoteCreateManyCampaignInput | SessionNoteCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOwnedCampaignsInput = {
    update: XOR<UserUpdateWithoutOwnedCampaignsInput, UserUncheckedUpdateWithoutOwnedCampaignsInput>
    create: XOR<UserCreateWithoutOwnedCampaignsInput, UserUncheckedCreateWithoutOwnedCampaignsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedCampaignsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedCampaignsInput, UserUncheckedUpdateWithoutOwnedCampaignsInput>
  }

  export type UserUpdateWithoutOwnedCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaignMembers?: CampaignMemberUpdateManyWithoutUserNestedInput
    characters?: CharacterUpdateManyWithoutPlayerNestedInput
    diceRolls?: DiceRollUpdateManyWithoutRollerNestedInput
    customContent?: CustomContentUpdateManyWithoutAuthorNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutAuthorNestedInput
    handouts?: HandoutUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    campaignMembers?: CampaignMemberUncheckedUpdateManyWithoutUserNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutPlayerNestedInput
    diceRolls?: DiceRollUncheckedUpdateManyWithoutRollerNestedInput
    customContent?: CustomContentUncheckedUpdateManyWithoutAuthorNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutAuthorNestedInput
    handouts?: HandoutUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type CampaignMemberUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignMemberWhereUniqueInput
    update: XOR<CampaignMemberUpdateWithoutCampaignInput, CampaignMemberUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignMemberCreateWithoutCampaignInput, CampaignMemberUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignMemberUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignMemberWhereUniqueInput
    data: XOR<CampaignMemberUpdateWithoutCampaignInput, CampaignMemberUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignMemberUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignMemberScalarWhereInput
    data: XOR<CampaignMemberUpdateManyMutationInput, CampaignMemberUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CharacterUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutCampaignInput, CharacterUncheckedUpdateWithoutCampaignInput>
    create: XOR<CharacterCreateWithoutCampaignInput, CharacterUncheckedCreateWithoutCampaignInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutCampaignInput, CharacterUncheckedUpdateWithoutCampaignInput>
  }

  export type CharacterUpdateManyWithWhereWithoutCampaignInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutCampaignInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutCampaignInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutCampaignInput, SessionUncheckedUpdateWithoutCampaignInput>
    create: XOR<SessionCreateWithoutCampaignInput, SessionUncheckedCreateWithoutCampaignInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutCampaignInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutCampaignInput, SessionUncheckedUpdateWithoutCampaignInput>
  }

  export type SessionUpdateManyWithWhereWithoutCampaignInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutCampaignInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    name?: StringFilter<"Session"> | string
    scheduledFor?: DateTimeNullableFilter<"Session"> | Date | string | null
    duration?: IntNullableFilter<"Session"> | number | null
    notes?: StringNullableFilter<"Session"> | string | null
    status?: EnumSessionStatusFilter<"Session"> | $Enums.SessionStatus
    campaignId?: StringFilter<"Session"> | string
    participants?: StringNullableListFilter<"Session">
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type DiceRollUpsertWithWhereUniqueWithoutCampaignInput = {
    where: DiceRollWhereUniqueInput
    update: XOR<DiceRollUpdateWithoutCampaignInput, DiceRollUncheckedUpdateWithoutCampaignInput>
    create: XOR<DiceRollCreateWithoutCampaignInput, DiceRollUncheckedCreateWithoutCampaignInput>
  }

  export type DiceRollUpdateWithWhereUniqueWithoutCampaignInput = {
    where: DiceRollWhereUniqueInput
    data: XOR<DiceRollUpdateWithoutCampaignInput, DiceRollUncheckedUpdateWithoutCampaignInput>
  }

  export type DiceRollUpdateManyWithWhereWithoutCampaignInput = {
    where: DiceRollScalarWhereInput
    data: XOR<DiceRollUpdateManyMutationInput, DiceRollUncheckedUpdateManyWithoutCampaignInput>
  }

  export type EncounterUpsertWithWhereUniqueWithoutCampaignInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutCampaignInput, EncounterUncheckedUpdateWithoutCampaignInput>
    create: XOR<EncounterCreateWithoutCampaignInput, EncounterUncheckedCreateWithoutCampaignInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutCampaignInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutCampaignInput, EncounterUncheckedUpdateWithoutCampaignInput>
  }

  export type EncounterUpdateManyWithWhereWithoutCampaignInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutCampaignInput>
  }

  export type EncounterScalarWhereInput = {
    AND?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    OR?: EncounterScalarWhereInput[]
    NOT?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    id?: StringFilter<"Encounter"> | string
    name?: StringFilter<"Encounter"> | string
    description?: StringNullableFilter<"Encounter"> | string | null
    encounterType?: StringFilter<"Encounter"> | string
    difficulty?: IntNullableFilter<"Encounter"> | number | null
    location?: StringNullableFilter<"Encounter"> | string | null
    environment?: JsonNullableFilter<"Encounter">
    npcs?: JsonNullableFilter<"Encounter">
    rewards?: JsonNullableFilter<"Encounter">
    status?: StringFilter<"Encounter"> | string
    outcome?: StringNullableFilter<"Encounter"> | string | null
    campaignId?: StringFilter<"Encounter"> | string
    sessionId?: StringNullableFilter<"Encounter"> | string | null
    createdAt?: DateTimeFilter<"Encounter"> | Date | string
    updatedAt?: DateTimeFilter<"Encounter"> | Date | string
  }

  export type StarSystemUpsertWithWhereUniqueWithoutCampaignInput = {
    where: StarSystemWhereUniqueInput
    update: XOR<StarSystemUpdateWithoutCampaignInput, StarSystemUncheckedUpdateWithoutCampaignInput>
    create: XOR<StarSystemCreateWithoutCampaignInput, StarSystemUncheckedCreateWithoutCampaignInput>
  }

  export type StarSystemUpdateWithWhereUniqueWithoutCampaignInput = {
    where: StarSystemWhereUniqueInput
    data: XOR<StarSystemUpdateWithoutCampaignInput, StarSystemUncheckedUpdateWithoutCampaignInput>
  }

  export type StarSystemUpdateManyWithWhereWithoutCampaignInput = {
    where: StarSystemScalarWhereInput
    data: XOR<StarSystemUpdateManyMutationInput, StarSystemUncheckedUpdateManyWithoutCampaignInput>
  }

  export type StarSystemScalarWhereInput = {
    AND?: StarSystemScalarWhereInput | StarSystemScalarWhereInput[]
    OR?: StarSystemScalarWhereInput[]
    NOT?: StarSystemScalarWhereInput | StarSystemScalarWhereInput[]
    id?: StringFilter<"StarSystem"> | string
    name?: StringFilter<"StarSystem"> | string
    hexLocation?: StringFilter<"StarSystem"> | string
    sector?: StringFilter<"StarSystem"> | string
    subsector?: StringNullableFilter<"StarSystem"> | string | null
    allegiance?: StringNullableFilter<"StarSystem"> | string | null
    starType?: StringNullableFilter<"StarSystem"> | string | null
    gasGiants?: IntFilter<"StarSystem"> | number
    jumpRoutes?: StringNullableListFilter<"StarSystem">
    campaignId?: StringNullableFilter<"StarSystem"> | string | null
    createdAt?: DateTimeFilter<"StarSystem"> | Date | string
    updatedAt?: DateTimeFilter<"StarSystem"> | Date | string
  }

  export type StarshipUpsertWithWhereUniqueWithoutCampaignInput = {
    where: StarshipWhereUniqueInput
    update: XOR<StarshipUpdateWithoutCampaignInput, StarshipUncheckedUpdateWithoutCampaignInput>
    create: XOR<StarshipCreateWithoutCampaignInput, StarshipUncheckedCreateWithoutCampaignInput>
  }

  export type StarshipUpdateWithWhereUniqueWithoutCampaignInput = {
    where: StarshipWhereUniqueInput
    data: XOR<StarshipUpdateWithoutCampaignInput, StarshipUncheckedUpdateWithoutCampaignInput>
  }

  export type StarshipUpdateManyWithWhereWithoutCampaignInput = {
    where: StarshipScalarWhereInput
    data: XOR<StarshipUpdateManyMutationInput, StarshipUncheckedUpdateManyWithoutCampaignInput>
  }

  export type StarshipScalarWhereInput = {
    AND?: StarshipScalarWhereInput | StarshipScalarWhereInput[]
    OR?: StarshipScalarWhereInput[]
    NOT?: StarshipScalarWhereInput | StarshipScalarWhereInput[]
    id?: StringFilter<"Starship"> | string
    name?: StringFilter<"Starship"> | string
    class?: StringFilter<"Starship"> | string
    hullCode?: StringNullableFilter<"Starship"> | string | null
    tonnage?: IntFilter<"Starship"> | number
    jumpDrive?: IntFilter<"Starship"> | number
    maneuverDrive?: IntFilter<"Starship"> | number
    powerPlant?: IntFilter<"Starship"> | number
    crew?: IntFilter<"Starship"> | number
    passengers?: IntFilter<"Starship"> | number
    cargo?: IntFilter<"Starship"> | number
    fuel?: IntFilter<"Starship"> | number
    armor?: IntFilter<"Starship"> | number
    weapons?: JsonNullableFilter<"Starship">
    status?: StringFilter<"Starship"> | string
    location?: StringNullableFilter<"Starship"> | string | null
    owner?: StringNullableFilter<"Starship"> | string | null
    campaignId?: StringNullableFilter<"Starship"> | string | null
    createdAt?: DateTimeFilter<"Starship"> | Date | string
    updatedAt?: DateTimeFilter<"Starship"> | Date | string
  }

  export type CustomContentUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CustomContentWhereUniqueInput
    update: XOR<CustomContentUpdateWithoutCampaignInput, CustomContentUncheckedUpdateWithoutCampaignInput>
    create: XOR<CustomContentCreateWithoutCampaignInput, CustomContentUncheckedCreateWithoutCampaignInput>
  }

  export type CustomContentUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CustomContentWhereUniqueInput
    data: XOR<CustomContentUpdateWithoutCampaignInput, CustomContentUncheckedUpdateWithoutCampaignInput>
  }

  export type CustomContentUpdateManyWithWhereWithoutCampaignInput = {
    where: CustomContentScalarWhereInput
    data: XOR<CustomContentUpdateManyMutationInput, CustomContentUncheckedUpdateManyWithoutCampaignInput>
  }

  export type HouseRuleUpsertWithWhereUniqueWithoutCampaignInput = {
    where: HouseRuleWhereUniqueInput
    update: XOR<HouseRuleUpdateWithoutCampaignInput, HouseRuleUncheckedUpdateWithoutCampaignInput>
    create: XOR<HouseRuleCreateWithoutCampaignInput, HouseRuleUncheckedCreateWithoutCampaignInput>
  }

  export type HouseRuleUpdateWithWhereUniqueWithoutCampaignInput = {
    where: HouseRuleWhereUniqueInput
    data: XOR<HouseRuleUpdateWithoutCampaignInput, HouseRuleUncheckedUpdateWithoutCampaignInput>
  }

  export type HouseRuleUpdateManyWithWhereWithoutCampaignInput = {
    where: HouseRuleScalarWhereInput
    data: XOR<HouseRuleUpdateManyMutationInput, HouseRuleUncheckedUpdateManyWithoutCampaignInput>
  }

  export type HouseRuleScalarWhereInput = {
    AND?: HouseRuleScalarWhereInput | HouseRuleScalarWhereInput[]
    OR?: HouseRuleScalarWhereInput[]
    NOT?: HouseRuleScalarWhereInput | HouseRuleScalarWhereInput[]
    id?: StringFilter<"HouseRule"> | string
    title?: StringFilter<"HouseRule"> | string
    description?: StringFilter<"HouseRule"> | string
    category?: StringFilter<"HouseRule"> | string
    ruleText?: StringFilter<"HouseRule"> | string
    pageReference?: StringNullableFilter<"HouseRule"> | string | null
    replaces?: StringNullableFilter<"HouseRule"> | string | null
    isActive?: BoolFilter<"HouseRule"> | boolean
    campaignId?: StringFilter<"HouseRule"> | string
    createdAt?: DateTimeFilter<"HouseRule"> | Date | string
    updatedAt?: DateTimeFilter<"HouseRule"> | Date | string
  }

  export type HandoutUpsertWithWhereUniqueWithoutCampaignInput = {
    where: HandoutWhereUniqueInput
    update: XOR<HandoutUpdateWithoutCampaignInput, HandoutUncheckedUpdateWithoutCampaignInput>
    create: XOR<HandoutCreateWithoutCampaignInput, HandoutUncheckedCreateWithoutCampaignInput>
  }

  export type HandoutUpdateWithWhereUniqueWithoutCampaignInput = {
    where: HandoutWhereUniqueInput
    data: XOR<HandoutUpdateWithoutCampaignInput, HandoutUncheckedUpdateWithoutCampaignInput>
  }

  export type HandoutUpdateManyWithWhereWithoutCampaignInput = {
    where: HandoutScalarWhereInput
    data: XOR<HandoutUpdateManyMutationInput, HandoutUncheckedUpdateManyWithoutCampaignInput>
  }

  export type SessionNoteUpsertWithWhereUniqueWithoutCampaignInput = {
    where: SessionNoteWhereUniqueInput
    update: XOR<SessionNoteUpdateWithoutCampaignInput, SessionNoteUncheckedUpdateWithoutCampaignInput>
    create: XOR<SessionNoteCreateWithoutCampaignInput, SessionNoteUncheckedCreateWithoutCampaignInput>
  }

  export type SessionNoteUpdateWithWhereUniqueWithoutCampaignInput = {
    where: SessionNoteWhereUniqueInput
    data: XOR<SessionNoteUpdateWithoutCampaignInput, SessionNoteUncheckedUpdateWithoutCampaignInput>
  }

  export type SessionNoteUpdateManyWithWhereWithoutCampaignInput = {
    where: SessionNoteScalarWhereInput
    data: XOR<SessionNoteUpdateManyMutationInput, SessionNoteUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    gamemaster: UserCreateNestedOneWithoutOwnedCampaignsInput
    characters?: CharacterCreateNestedManyWithoutCampaignInput
    sessions?: SessionCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemCreateNestedManyWithoutCampaignInput
    starships?: StarshipCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleCreateNestedManyWithoutCampaignInput
    handouts?: HandoutCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterUncheckedCreateNestedManyWithoutCampaignInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemUncheckedCreateNestedManyWithoutCampaignInput
    starships?: StarshipUncheckedCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentUncheckedCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleUncheckedCreateNestedManyWithoutCampaignInput
    handouts?: HandoutUncheckedCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutMembersInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutMembersInput, CampaignUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutCampaignMembersInput = {
    id?: string
    email: string
    displayName?: string | null
    avatar?: string | null
    timezone?: string
    subscriptionTier?: $Enums.SubscriptionTier
    cognitoUserId: string
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ownedCampaigns?: CampaignCreateNestedManyWithoutGamemasterInput
    characters?: CharacterCreateNestedManyWithoutPlayerInput
    diceRolls?: DiceRollCreateNestedManyWithoutRollerInput
    customContent?: CustomContentCreateNestedManyWithoutAuthorInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutAuthorInput
    handouts?: HandoutCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutCampaignMembersInput = {
    id?: string
    email: string
    displayName?: string | null
    avatar?: string | null
    timezone?: string
    subscriptionTier?: $Enums.SubscriptionTier
    cognitoUserId: string
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ownedCampaigns?: CampaignUncheckedCreateNestedManyWithoutGamemasterInput
    characters?: CharacterUncheckedCreateNestedManyWithoutPlayerInput
    diceRolls?: DiceRollUncheckedCreateNestedManyWithoutRollerInput
    customContent?: CustomContentUncheckedCreateNestedManyWithoutAuthorInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutAuthorInput
    handouts?: HandoutUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutCampaignMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCampaignMembersInput, UserUncheckedCreateWithoutCampaignMembersInput>
  }

  export type CampaignUpsertWithoutMembersInput = {
    update: XOR<CampaignUpdateWithoutMembersInput, CampaignUncheckedUpdateWithoutMembersInput>
    create: XOR<CampaignCreateWithoutMembersInput, CampaignUncheckedCreateWithoutMembersInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutMembersInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutMembersInput, CampaignUncheckedUpdateWithoutMembersInput>
  }

  export type CampaignUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamemaster?: UserUpdateOneRequiredWithoutOwnedCampaignsNestedInput
    characters?: CharacterUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUncheckedUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUncheckedUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUncheckedUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUncheckedUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUncheckedUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUncheckedUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type UserUpsertWithoutCampaignMembersInput = {
    update: XOR<UserUpdateWithoutCampaignMembersInput, UserUncheckedUpdateWithoutCampaignMembersInput>
    create: XOR<UserCreateWithoutCampaignMembersInput, UserUncheckedCreateWithoutCampaignMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCampaignMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCampaignMembersInput, UserUncheckedUpdateWithoutCampaignMembersInput>
  }

  export type UserUpdateWithoutCampaignMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownedCampaigns?: CampaignUpdateManyWithoutGamemasterNestedInput
    characters?: CharacterUpdateManyWithoutPlayerNestedInput
    diceRolls?: DiceRollUpdateManyWithoutRollerNestedInput
    customContent?: CustomContentUpdateManyWithoutAuthorNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutAuthorNestedInput
    handouts?: HandoutUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutCampaignMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownedCampaigns?: CampaignUncheckedUpdateManyWithoutGamemasterNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutPlayerNestedInput
    diceRolls?: DiceRollUncheckedUpdateManyWithoutRollerNestedInput
    customContent?: CustomContentUncheckedUpdateManyWithoutAuthorNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutAuthorNestedInput
    handouts?: HandoutUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutCharactersInput = {
    id?: string
    email: string
    displayName?: string | null
    avatar?: string | null
    timezone?: string
    subscriptionTier?: $Enums.SubscriptionTier
    cognitoUserId: string
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ownedCampaigns?: CampaignCreateNestedManyWithoutGamemasterInput
    campaignMembers?: CampaignMemberCreateNestedManyWithoutUserInput
    diceRolls?: DiceRollCreateNestedManyWithoutRollerInput
    customContent?: CustomContentCreateNestedManyWithoutAuthorInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutAuthorInput
    handouts?: HandoutCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutCharactersInput = {
    id?: string
    email: string
    displayName?: string | null
    avatar?: string | null
    timezone?: string
    subscriptionTier?: $Enums.SubscriptionTier
    cognitoUserId: string
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ownedCampaigns?: CampaignUncheckedCreateNestedManyWithoutGamemasterInput
    campaignMembers?: CampaignMemberUncheckedCreateNestedManyWithoutUserInput
    diceRolls?: DiceRollUncheckedCreateNestedManyWithoutRollerInput
    customContent?: CustomContentUncheckedCreateNestedManyWithoutAuthorInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutAuthorInput
    handouts?: HandoutUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutCharactersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCharactersInput, UserUncheckedCreateWithoutCharactersInput>
  }

  export type CampaignCreateWithoutCharactersInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    gamemaster: UserCreateNestedOneWithoutOwnedCampaignsInput
    members?: CampaignMemberCreateNestedManyWithoutCampaignInput
    sessions?: SessionCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemCreateNestedManyWithoutCampaignInput
    starships?: StarshipCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleCreateNestedManyWithoutCampaignInput
    handouts?: HandoutCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCharactersInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CampaignMemberUncheckedCreateNestedManyWithoutCampaignInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemUncheckedCreateNestedManyWithoutCampaignInput
    starships?: StarshipUncheckedCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentUncheckedCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleUncheckedCreateNestedManyWithoutCampaignInput
    handouts?: HandoutUncheckedCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCharactersInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCharactersInput, CampaignUncheckedCreateWithoutCharactersInput>
  }

  export type CharacteristicsCreateWithoutCharacterInput = {
    id?: string
    strength?: number
    dexterity?: number
    endurance?: number
    intelligence?: number
    education?: number
    socialStanding?: number
    physicalDamage?: number | null
    mentalDamage?: number | null
  }

  export type CharacteristicsUncheckedCreateWithoutCharacterInput = {
    id?: string
    strength?: number
    dexterity?: number
    endurance?: number
    intelligence?: number
    education?: number
    socialStanding?: number
    physicalDamage?: number | null
    mentalDamage?: number | null
  }

  export type CharacteristicsCreateOrConnectWithoutCharacterInput = {
    where: CharacteristicsWhereUniqueInput
    create: XOR<CharacteristicsCreateWithoutCharacterInput, CharacteristicsUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterSkillCreateWithoutCharacterInput = {
    id?: string
    name: string
    level?: number
    specialization?: string | null
  }

  export type CharacterSkillUncheckedCreateWithoutCharacterInput = {
    id?: string
    name: string
    level?: number
    specialization?: string | null
  }

  export type CharacterSkillCreateOrConnectWithoutCharacterInput = {
    where: CharacterSkillWhereUniqueInput
    create: XOR<CharacterSkillCreateWithoutCharacterInput, CharacterSkillUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterSkillCreateManyCharacterInputEnvelope = {
    data: CharacterSkillCreateManyCharacterInput | CharacterSkillCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type CharacterEquipmentCreateWithoutCharacterInput = {
    id?: string
    name: string
    description?: string | null
    weight?: number | null
    cost?: number | null
    quantity?: number
    equipped?: boolean
    category?: string | null
    subcategory?: string | null
    weaponType?: string | null
    damage?: string | null
    range?: string | null
    armorValue?: number | null
    armorType?: string | null
  }

  export type CharacterEquipmentUncheckedCreateWithoutCharacterInput = {
    id?: string
    name: string
    description?: string | null
    weight?: number | null
    cost?: number | null
    quantity?: number
    equipped?: boolean
    category?: string | null
    subcategory?: string | null
    weaponType?: string | null
    damage?: string | null
    range?: string | null
    armorValue?: number | null
    armorType?: string | null
  }

  export type CharacterEquipmentCreateOrConnectWithoutCharacterInput = {
    where: CharacterEquipmentWhereUniqueInput
    create: XOR<CharacterEquipmentCreateWithoutCharacterInput, CharacterEquipmentUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterEquipmentCreateManyCharacterInputEnvelope = {
    data: CharacterEquipmentCreateManyCharacterInput | CharacterEquipmentCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type LifeEventCreateWithoutCharacterInput = {
    id?: string
    age: number
    event: string
    description?: string | null
    effects?: NullableJsonNullValueInput | InputJsonValue
    career?: string | null
    rank?: string | null
    skills?: LifeEventCreateskillsInput | string[]
  }

  export type LifeEventUncheckedCreateWithoutCharacterInput = {
    id?: string
    age: number
    event: string
    description?: string | null
    effects?: NullableJsonNullValueInput | InputJsonValue
    career?: string | null
    rank?: string | null
    skills?: LifeEventCreateskillsInput | string[]
  }

  export type LifeEventCreateOrConnectWithoutCharacterInput = {
    where: LifeEventWhereUniqueInput
    create: XOR<LifeEventCreateWithoutCharacterInput, LifeEventUncheckedCreateWithoutCharacterInput>
  }

  export type LifeEventCreateManyCharacterInputEnvelope = {
    data: LifeEventCreateManyCharacterInput | LifeEventCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type CombatActionCreateWithoutCharacterInput = {
    id?: string
    actionType: string
    description?: string | null
    target?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    diceRolled?: string | null
    rollResult?: number | null
    modifiers?: NullableJsonNullValueInput | InputJsonValue
    round: number
    timestamp?: Date | string
    combatSession: CombatSessionCreateNestedOneWithoutActionsInput
  }

  export type CombatActionUncheckedCreateWithoutCharacterInput = {
    id?: string
    actionType: string
    description?: string | null
    target?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    diceRolled?: string | null
    rollResult?: number | null
    modifiers?: NullableJsonNullValueInput | InputJsonValue
    combatSessionId: string
    round: number
    timestamp?: Date | string
  }

  export type CombatActionCreateOrConnectWithoutCharacterInput = {
    where: CombatActionWhereUniqueInput
    create: XOR<CombatActionCreateWithoutCharacterInput, CombatActionUncheckedCreateWithoutCharacterInput>
  }

  export type CombatActionCreateManyCharacterInputEnvelope = {
    data: CombatActionCreateManyCharacterInput | CombatActionCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCharactersInput = {
    update: XOR<UserUpdateWithoutCharactersInput, UserUncheckedUpdateWithoutCharactersInput>
    create: XOR<UserCreateWithoutCharactersInput, UserUncheckedCreateWithoutCharactersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCharactersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCharactersInput, UserUncheckedUpdateWithoutCharactersInput>
  }

  export type UserUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownedCampaigns?: CampaignUpdateManyWithoutGamemasterNestedInput
    campaignMembers?: CampaignMemberUpdateManyWithoutUserNestedInput
    diceRolls?: DiceRollUpdateManyWithoutRollerNestedInput
    customContent?: CustomContentUpdateManyWithoutAuthorNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutAuthorNestedInput
    handouts?: HandoutUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownedCampaigns?: CampaignUncheckedUpdateManyWithoutGamemasterNestedInput
    campaignMembers?: CampaignMemberUncheckedUpdateManyWithoutUserNestedInput
    diceRolls?: DiceRollUncheckedUpdateManyWithoutRollerNestedInput
    customContent?: CustomContentUncheckedUpdateManyWithoutAuthorNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutAuthorNestedInput
    handouts?: HandoutUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type CampaignUpsertWithoutCharactersInput = {
    update: XOR<CampaignUpdateWithoutCharactersInput, CampaignUncheckedUpdateWithoutCharactersInput>
    create: XOR<CampaignCreateWithoutCharactersInput, CampaignUncheckedCreateWithoutCharactersInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutCharactersInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutCharactersInput, CampaignUncheckedUpdateWithoutCharactersInput>
  }

  export type CampaignUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamemaster?: UserUpdateOneRequiredWithoutOwnedCampaignsNestedInput
    members?: CampaignMemberUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CampaignMemberUncheckedUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUncheckedUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUncheckedUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUncheckedUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUncheckedUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUncheckedUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CharacteristicsUpsertWithoutCharacterInput = {
    update: XOR<CharacteristicsUpdateWithoutCharacterInput, CharacteristicsUncheckedUpdateWithoutCharacterInput>
    create: XOR<CharacteristicsCreateWithoutCharacterInput, CharacteristicsUncheckedCreateWithoutCharacterInput>
    where?: CharacteristicsWhereInput
  }

  export type CharacteristicsUpdateToOneWithWhereWithoutCharacterInput = {
    where?: CharacteristicsWhereInput
    data: XOR<CharacteristicsUpdateWithoutCharacterInput, CharacteristicsUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacteristicsUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    endurance?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    education?: IntFieldUpdateOperationsInput | number
    socialStanding?: IntFieldUpdateOperationsInput | number
    physicalDamage?: NullableIntFieldUpdateOperationsInput | number | null
    mentalDamage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacteristicsUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: IntFieldUpdateOperationsInput | number
    dexterity?: IntFieldUpdateOperationsInput | number
    endurance?: IntFieldUpdateOperationsInput | number
    intelligence?: IntFieldUpdateOperationsInput | number
    education?: IntFieldUpdateOperationsInput | number
    socialStanding?: IntFieldUpdateOperationsInput | number
    physicalDamage?: NullableIntFieldUpdateOperationsInput | number | null
    mentalDamage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CharacterSkillUpsertWithWhereUniqueWithoutCharacterInput = {
    where: CharacterSkillWhereUniqueInput
    update: XOR<CharacterSkillUpdateWithoutCharacterInput, CharacterSkillUncheckedUpdateWithoutCharacterInput>
    create: XOR<CharacterSkillCreateWithoutCharacterInput, CharacterSkillUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterSkillUpdateWithWhereUniqueWithoutCharacterInput = {
    where: CharacterSkillWhereUniqueInput
    data: XOR<CharacterSkillUpdateWithoutCharacterInput, CharacterSkillUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacterSkillUpdateManyWithWhereWithoutCharacterInput = {
    where: CharacterSkillScalarWhereInput
    data: XOR<CharacterSkillUpdateManyMutationInput, CharacterSkillUncheckedUpdateManyWithoutCharacterInput>
  }

  export type CharacterSkillScalarWhereInput = {
    AND?: CharacterSkillScalarWhereInput | CharacterSkillScalarWhereInput[]
    OR?: CharacterSkillScalarWhereInput[]
    NOT?: CharacterSkillScalarWhereInput | CharacterSkillScalarWhereInput[]
    id?: StringFilter<"CharacterSkill"> | string
    name?: StringFilter<"CharacterSkill"> | string
    level?: IntFilter<"CharacterSkill"> | number
    specialization?: StringNullableFilter<"CharacterSkill"> | string | null
    characterId?: StringFilter<"CharacterSkill"> | string
  }

  export type CharacterEquipmentUpsertWithWhereUniqueWithoutCharacterInput = {
    where: CharacterEquipmentWhereUniqueInput
    update: XOR<CharacterEquipmentUpdateWithoutCharacterInput, CharacterEquipmentUncheckedUpdateWithoutCharacterInput>
    create: XOR<CharacterEquipmentCreateWithoutCharacterInput, CharacterEquipmentUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterEquipmentUpdateWithWhereUniqueWithoutCharacterInput = {
    where: CharacterEquipmentWhereUniqueInput
    data: XOR<CharacterEquipmentUpdateWithoutCharacterInput, CharacterEquipmentUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacterEquipmentUpdateManyWithWhereWithoutCharacterInput = {
    where: CharacterEquipmentScalarWhereInput
    data: XOR<CharacterEquipmentUpdateManyMutationInput, CharacterEquipmentUncheckedUpdateManyWithoutCharacterInput>
  }

  export type CharacterEquipmentScalarWhereInput = {
    AND?: CharacterEquipmentScalarWhereInput | CharacterEquipmentScalarWhereInput[]
    OR?: CharacterEquipmentScalarWhereInput[]
    NOT?: CharacterEquipmentScalarWhereInput | CharacterEquipmentScalarWhereInput[]
    id?: StringFilter<"CharacterEquipment"> | string
    name?: StringFilter<"CharacterEquipment"> | string
    description?: StringNullableFilter<"CharacterEquipment"> | string | null
    weight?: FloatNullableFilter<"CharacterEquipment"> | number | null
    cost?: IntNullableFilter<"CharacterEquipment"> | number | null
    quantity?: IntFilter<"CharacterEquipment"> | number
    equipped?: BoolFilter<"CharacterEquipment"> | boolean
    category?: StringNullableFilter<"CharacterEquipment"> | string | null
    subcategory?: StringNullableFilter<"CharacterEquipment"> | string | null
    weaponType?: StringNullableFilter<"CharacterEquipment"> | string | null
    damage?: StringNullableFilter<"CharacterEquipment"> | string | null
    range?: StringNullableFilter<"CharacterEquipment"> | string | null
    armorValue?: IntNullableFilter<"CharacterEquipment"> | number | null
    armorType?: StringNullableFilter<"CharacterEquipment"> | string | null
    characterId?: StringFilter<"CharacterEquipment"> | string
  }

  export type LifeEventUpsertWithWhereUniqueWithoutCharacterInput = {
    where: LifeEventWhereUniqueInput
    update: XOR<LifeEventUpdateWithoutCharacterInput, LifeEventUncheckedUpdateWithoutCharacterInput>
    create: XOR<LifeEventCreateWithoutCharacterInput, LifeEventUncheckedCreateWithoutCharacterInput>
  }

  export type LifeEventUpdateWithWhereUniqueWithoutCharacterInput = {
    where: LifeEventWhereUniqueInput
    data: XOR<LifeEventUpdateWithoutCharacterInput, LifeEventUncheckedUpdateWithoutCharacterInput>
  }

  export type LifeEventUpdateManyWithWhereWithoutCharacterInput = {
    where: LifeEventScalarWhereInput
    data: XOR<LifeEventUpdateManyMutationInput, LifeEventUncheckedUpdateManyWithoutCharacterInput>
  }

  export type LifeEventScalarWhereInput = {
    AND?: LifeEventScalarWhereInput | LifeEventScalarWhereInput[]
    OR?: LifeEventScalarWhereInput[]
    NOT?: LifeEventScalarWhereInput | LifeEventScalarWhereInput[]
    id?: StringFilter<"LifeEvent"> | string
    age?: IntFilter<"LifeEvent"> | number
    event?: StringFilter<"LifeEvent"> | string
    description?: StringNullableFilter<"LifeEvent"> | string | null
    effects?: JsonNullableFilter<"LifeEvent">
    career?: StringNullableFilter<"LifeEvent"> | string | null
    rank?: StringNullableFilter<"LifeEvent"> | string | null
    skills?: StringNullableListFilter<"LifeEvent">
    characterId?: StringFilter<"LifeEvent"> | string
  }

  export type CombatActionUpsertWithWhereUniqueWithoutCharacterInput = {
    where: CombatActionWhereUniqueInput
    update: XOR<CombatActionUpdateWithoutCharacterInput, CombatActionUncheckedUpdateWithoutCharacterInput>
    create: XOR<CombatActionCreateWithoutCharacterInput, CombatActionUncheckedCreateWithoutCharacterInput>
  }

  export type CombatActionUpdateWithWhereUniqueWithoutCharacterInput = {
    where: CombatActionWhereUniqueInput
    data: XOR<CombatActionUpdateWithoutCharacterInput, CombatActionUncheckedUpdateWithoutCharacterInput>
  }

  export type CombatActionUpdateManyWithWhereWithoutCharacterInput = {
    where: CombatActionScalarWhereInput
    data: XOR<CombatActionUpdateManyMutationInput, CombatActionUncheckedUpdateManyWithoutCharacterInput>
  }

  export type CombatActionScalarWhereInput = {
    AND?: CombatActionScalarWhereInput | CombatActionScalarWhereInput[]
    OR?: CombatActionScalarWhereInput[]
    NOT?: CombatActionScalarWhereInput | CombatActionScalarWhereInput[]
    id?: StringFilter<"CombatAction"> | string
    actionType?: StringFilter<"CombatAction"> | string
    description?: StringNullableFilter<"CombatAction"> | string | null
    target?: StringNullableFilter<"CombatAction"> | string | null
    result?: JsonNullableFilter<"CombatAction">
    diceRolled?: StringNullableFilter<"CombatAction"> | string | null
    rollResult?: IntNullableFilter<"CombatAction"> | number | null
    modifiers?: JsonNullableFilter<"CombatAction">
    characterId?: StringNullableFilter<"CombatAction"> | string | null
    combatSessionId?: StringFilter<"CombatAction"> | string
    round?: IntFilter<"CombatAction"> | number
    timestamp?: DateTimeFilter<"CombatAction"> | Date | string
  }

  export type CharacterCreateWithoutCharacteristicsInput = {
    id?: string
    name: string
    credits?: number
    notes?: string | null
    portrait?: string | null
    homeworld?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: UserCreateNestedOneWithoutCharactersInput
    campaign: CampaignCreateNestedOneWithoutCharactersInput
    skills?: CharacterSkillCreateNestedManyWithoutCharacterInput
    equipment?: CharacterEquipmentCreateNestedManyWithoutCharacterInput
    lifeEvents?: LifeEventCreateNestedManyWithoutCharacterInput
    combatActions?: CombatActionCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutCharacteristicsInput = {
    id?: string
    name: string
    credits?: number
    notes?: string | null
    portrait?: string | null
    homeworld?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    playerId: string
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    skills?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    equipment?: CharacterEquipmentUncheckedCreateNestedManyWithoutCharacterInput
    lifeEvents?: LifeEventUncheckedCreateNestedManyWithoutCharacterInput
    combatActions?: CombatActionUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutCharacteristicsInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutCharacteristicsInput, CharacterUncheckedCreateWithoutCharacteristicsInput>
  }

  export type CharacterUpsertWithoutCharacteristicsInput = {
    update: XOR<CharacterUpdateWithoutCharacteristicsInput, CharacterUncheckedUpdateWithoutCharacteristicsInput>
    create: XOR<CharacterCreateWithoutCharacteristicsInput, CharacterUncheckedCreateWithoutCharacteristicsInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutCharacteristicsInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutCharacteristicsInput, CharacterUncheckedUpdateWithoutCharacteristicsInput>
  }

  export type CharacterUpdateWithoutCharacteristicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: UserUpdateOneRequiredWithoutCharactersNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutCharactersNestedInput
    skills?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    equipment?: CharacterEquipmentUpdateManyWithoutCharacterNestedInput
    lifeEvents?: LifeEventUpdateManyWithoutCharacterNestedInput
    combatActions?: CombatActionUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutCharacteristicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    playerId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skills?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    equipment?: CharacterEquipmentUncheckedUpdateManyWithoutCharacterNestedInput
    lifeEvents?: LifeEventUncheckedUpdateManyWithoutCharacterNestedInput
    combatActions?: CombatActionUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterCreateWithoutSkillsInput = {
    id?: string
    name: string
    credits?: number
    notes?: string | null
    portrait?: string | null
    homeworld?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: UserCreateNestedOneWithoutCharactersInput
    campaign: CampaignCreateNestedOneWithoutCharactersInput
    characteristics?: CharacteristicsCreateNestedOneWithoutCharacterInput
    equipment?: CharacterEquipmentCreateNestedManyWithoutCharacterInput
    lifeEvents?: LifeEventCreateNestedManyWithoutCharacterInput
    combatActions?: CombatActionCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutSkillsInput = {
    id?: string
    name: string
    credits?: number
    notes?: string | null
    portrait?: string | null
    homeworld?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    playerId: string
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    characteristics?: CharacteristicsUncheckedCreateNestedOneWithoutCharacterInput
    equipment?: CharacterEquipmentUncheckedCreateNestedManyWithoutCharacterInput
    lifeEvents?: LifeEventUncheckedCreateNestedManyWithoutCharacterInput
    combatActions?: CombatActionUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutSkillsInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutSkillsInput, CharacterUncheckedCreateWithoutSkillsInput>
  }

  export type CharacterUpsertWithoutSkillsInput = {
    update: XOR<CharacterUpdateWithoutSkillsInput, CharacterUncheckedUpdateWithoutSkillsInput>
    create: XOR<CharacterCreateWithoutSkillsInput, CharacterUncheckedCreateWithoutSkillsInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutSkillsInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutSkillsInput, CharacterUncheckedUpdateWithoutSkillsInput>
  }

  export type CharacterUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: UserUpdateOneRequiredWithoutCharactersNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutCharactersNestedInput
    characteristics?: CharacteristicsUpdateOneWithoutCharacterNestedInput
    equipment?: CharacterEquipmentUpdateManyWithoutCharacterNestedInput
    lifeEvents?: LifeEventUpdateManyWithoutCharacterNestedInput
    combatActions?: CombatActionUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    playerId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characteristics?: CharacteristicsUncheckedUpdateOneWithoutCharacterNestedInput
    equipment?: CharacterEquipmentUncheckedUpdateManyWithoutCharacterNestedInput
    lifeEvents?: LifeEventUncheckedUpdateManyWithoutCharacterNestedInput
    combatActions?: CombatActionUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterCreateWithoutEquipmentInput = {
    id?: string
    name: string
    credits?: number
    notes?: string | null
    portrait?: string | null
    homeworld?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: UserCreateNestedOneWithoutCharactersInput
    campaign: CampaignCreateNestedOneWithoutCharactersInput
    characteristics?: CharacteristicsCreateNestedOneWithoutCharacterInput
    skills?: CharacterSkillCreateNestedManyWithoutCharacterInput
    lifeEvents?: LifeEventCreateNestedManyWithoutCharacterInput
    combatActions?: CombatActionCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutEquipmentInput = {
    id?: string
    name: string
    credits?: number
    notes?: string | null
    portrait?: string | null
    homeworld?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    playerId: string
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    characteristics?: CharacteristicsUncheckedCreateNestedOneWithoutCharacterInput
    skills?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    lifeEvents?: LifeEventUncheckedCreateNestedManyWithoutCharacterInput
    combatActions?: CombatActionUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutEquipmentInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutEquipmentInput, CharacterUncheckedCreateWithoutEquipmentInput>
  }

  export type CharacterUpsertWithoutEquipmentInput = {
    update: XOR<CharacterUpdateWithoutEquipmentInput, CharacterUncheckedUpdateWithoutEquipmentInput>
    create: XOR<CharacterCreateWithoutEquipmentInput, CharacterUncheckedCreateWithoutEquipmentInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutEquipmentInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutEquipmentInput, CharacterUncheckedUpdateWithoutEquipmentInput>
  }

  export type CharacterUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: UserUpdateOneRequiredWithoutCharactersNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutCharactersNestedInput
    characteristics?: CharacteristicsUpdateOneWithoutCharacterNestedInput
    skills?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    lifeEvents?: LifeEventUpdateManyWithoutCharacterNestedInput
    combatActions?: CombatActionUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    playerId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characteristics?: CharacteristicsUncheckedUpdateOneWithoutCharacterNestedInput
    skills?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    lifeEvents?: LifeEventUncheckedUpdateManyWithoutCharacterNestedInput
    combatActions?: CombatActionUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterCreateWithoutLifeEventsInput = {
    id?: string
    name: string
    credits?: number
    notes?: string | null
    portrait?: string | null
    homeworld?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: UserCreateNestedOneWithoutCharactersInput
    campaign: CampaignCreateNestedOneWithoutCharactersInput
    characteristics?: CharacteristicsCreateNestedOneWithoutCharacterInput
    skills?: CharacterSkillCreateNestedManyWithoutCharacterInput
    equipment?: CharacterEquipmentCreateNestedManyWithoutCharacterInput
    combatActions?: CombatActionCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutLifeEventsInput = {
    id?: string
    name: string
    credits?: number
    notes?: string | null
    portrait?: string | null
    homeworld?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    playerId: string
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    characteristics?: CharacteristicsUncheckedCreateNestedOneWithoutCharacterInput
    skills?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    equipment?: CharacterEquipmentUncheckedCreateNestedManyWithoutCharacterInput
    combatActions?: CombatActionUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutLifeEventsInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutLifeEventsInput, CharacterUncheckedCreateWithoutLifeEventsInput>
  }

  export type CharacterUpsertWithoutLifeEventsInput = {
    update: XOR<CharacterUpdateWithoutLifeEventsInput, CharacterUncheckedUpdateWithoutLifeEventsInput>
    create: XOR<CharacterCreateWithoutLifeEventsInput, CharacterUncheckedCreateWithoutLifeEventsInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutLifeEventsInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutLifeEventsInput, CharacterUncheckedUpdateWithoutLifeEventsInput>
  }

  export type CharacterUpdateWithoutLifeEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: UserUpdateOneRequiredWithoutCharactersNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutCharactersNestedInput
    characteristics?: CharacteristicsUpdateOneWithoutCharacterNestedInput
    skills?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    equipment?: CharacterEquipmentUpdateManyWithoutCharacterNestedInput
    combatActions?: CombatActionUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutLifeEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    playerId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characteristics?: CharacteristicsUncheckedUpdateOneWithoutCharacterNestedInput
    skills?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    equipment?: CharacterEquipmentUncheckedUpdateManyWithoutCharacterNestedInput
    combatActions?: CombatActionUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CampaignCreateWithoutStarSystemsInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    gamemaster: UserCreateNestedOneWithoutOwnedCampaignsInput
    members?: CampaignMemberCreateNestedManyWithoutCampaignInput
    characters?: CharacterCreateNestedManyWithoutCampaignInput
    sessions?: SessionCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    starships?: StarshipCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleCreateNestedManyWithoutCampaignInput
    handouts?: HandoutCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutStarSystemsInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CampaignMemberUncheckedCreateNestedManyWithoutCampaignInput
    characters?: CharacterUncheckedCreateNestedManyWithoutCampaignInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    starships?: StarshipUncheckedCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentUncheckedCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleUncheckedCreateNestedManyWithoutCampaignInput
    handouts?: HandoutUncheckedCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutStarSystemsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutStarSystemsInput, CampaignUncheckedCreateWithoutStarSystemsInput>
  }

  export type PlanetCreateWithoutStarSystemInput = {
    id?: string
    name: string
    uwp: string
    size: number
    atmosphere: number
    hydrographics: number
    population: number
    government: number
    lawLevel: number
    techLevel: number
    starport: string
    tradeCodes?: PlanetCreatetradeCodesInput | string[]
    bases?: PlanetCreatebasesInput | string[]
    gasGiant?: boolean
    description?: string | null
    notes?: string | null
    tradeGoods?: TradeGoodCreateNestedManyWithoutPlanetInput
  }

  export type PlanetUncheckedCreateWithoutStarSystemInput = {
    id?: string
    name: string
    uwp: string
    size: number
    atmosphere: number
    hydrographics: number
    population: number
    government: number
    lawLevel: number
    techLevel: number
    starport: string
    tradeCodes?: PlanetCreatetradeCodesInput | string[]
    bases?: PlanetCreatebasesInput | string[]
    gasGiant?: boolean
    description?: string | null
    notes?: string | null
    tradeGoods?: TradeGoodUncheckedCreateNestedManyWithoutPlanetInput
  }

  export type PlanetCreateOrConnectWithoutStarSystemInput = {
    where: PlanetWhereUniqueInput
    create: XOR<PlanetCreateWithoutStarSystemInput, PlanetUncheckedCreateWithoutStarSystemInput>
  }

  export type PlanetCreateManyStarSystemInputEnvelope = {
    data: PlanetCreateManyStarSystemInput | PlanetCreateManyStarSystemInput[]
    skipDuplicates?: boolean
  }

  export type TradeRouteCreateWithoutOriginInput = {
    id?: string
    name: string
    distance: number
    difficulty?: number
    cargoTypes?: TradeRouteCreatecargoTypesInput | string[]
    profitMargin?: number | null
    destination: StarSystemCreateNestedOneWithoutTradeRoutesDestinationInput
  }

  export type TradeRouteUncheckedCreateWithoutOriginInput = {
    id?: string
    name: string
    distance: number
    difficulty?: number
    destinationId: string
    cargoTypes?: TradeRouteCreatecargoTypesInput | string[]
    profitMargin?: number | null
  }

  export type TradeRouteCreateOrConnectWithoutOriginInput = {
    where: TradeRouteWhereUniqueInput
    create: XOR<TradeRouteCreateWithoutOriginInput, TradeRouteUncheckedCreateWithoutOriginInput>
  }

  export type TradeRouteCreateManyOriginInputEnvelope = {
    data: TradeRouteCreateManyOriginInput | TradeRouteCreateManyOriginInput[]
    skipDuplicates?: boolean
  }

  export type TradeRouteCreateWithoutDestinationInput = {
    id?: string
    name: string
    distance: number
    difficulty?: number
    cargoTypes?: TradeRouteCreatecargoTypesInput | string[]
    profitMargin?: number | null
    origin: StarSystemCreateNestedOneWithoutTradeRoutesInput
  }

  export type TradeRouteUncheckedCreateWithoutDestinationInput = {
    id?: string
    name: string
    distance: number
    difficulty?: number
    originId: string
    cargoTypes?: TradeRouteCreatecargoTypesInput | string[]
    profitMargin?: number | null
  }

  export type TradeRouteCreateOrConnectWithoutDestinationInput = {
    where: TradeRouteWhereUniqueInput
    create: XOR<TradeRouteCreateWithoutDestinationInput, TradeRouteUncheckedCreateWithoutDestinationInput>
  }

  export type TradeRouteCreateManyDestinationInputEnvelope = {
    data: TradeRouteCreateManyDestinationInput | TradeRouteCreateManyDestinationInput[]
    skipDuplicates?: boolean
  }

  export type CampaignUpsertWithoutStarSystemsInput = {
    update: XOR<CampaignUpdateWithoutStarSystemsInput, CampaignUncheckedUpdateWithoutStarSystemsInput>
    create: XOR<CampaignCreateWithoutStarSystemsInput, CampaignUncheckedCreateWithoutStarSystemsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutStarSystemsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutStarSystemsInput, CampaignUncheckedUpdateWithoutStarSystemsInput>
  }

  export type CampaignUpdateWithoutStarSystemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamemaster?: UserUpdateOneRequiredWithoutOwnedCampaignsNestedInput
    members?: CampaignMemberUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutStarSystemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CampaignMemberUncheckedUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUncheckedUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUncheckedUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUncheckedUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUncheckedUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type PlanetUpsertWithWhereUniqueWithoutStarSystemInput = {
    where: PlanetWhereUniqueInput
    update: XOR<PlanetUpdateWithoutStarSystemInput, PlanetUncheckedUpdateWithoutStarSystemInput>
    create: XOR<PlanetCreateWithoutStarSystemInput, PlanetUncheckedCreateWithoutStarSystemInput>
  }

  export type PlanetUpdateWithWhereUniqueWithoutStarSystemInput = {
    where: PlanetWhereUniqueInput
    data: XOR<PlanetUpdateWithoutStarSystemInput, PlanetUncheckedUpdateWithoutStarSystemInput>
  }

  export type PlanetUpdateManyWithWhereWithoutStarSystemInput = {
    where: PlanetScalarWhereInput
    data: XOR<PlanetUpdateManyMutationInput, PlanetUncheckedUpdateManyWithoutStarSystemInput>
  }

  export type PlanetScalarWhereInput = {
    AND?: PlanetScalarWhereInput | PlanetScalarWhereInput[]
    OR?: PlanetScalarWhereInput[]
    NOT?: PlanetScalarWhereInput | PlanetScalarWhereInput[]
    id?: StringFilter<"Planet"> | string
    name?: StringFilter<"Planet"> | string
    uwp?: StringFilter<"Planet"> | string
    size?: IntFilter<"Planet"> | number
    atmosphere?: IntFilter<"Planet"> | number
    hydrographics?: IntFilter<"Planet"> | number
    population?: IntFilter<"Planet"> | number
    government?: IntFilter<"Planet"> | number
    lawLevel?: IntFilter<"Planet"> | number
    techLevel?: IntFilter<"Planet"> | number
    starport?: StringFilter<"Planet"> | string
    tradeCodes?: StringNullableListFilter<"Planet">
    bases?: StringNullableListFilter<"Planet">
    gasGiant?: BoolFilter<"Planet"> | boolean
    description?: StringNullableFilter<"Planet"> | string | null
    notes?: StringNullableFilter<"Planet"> | string | null
    starSystemId?: StringFilter<"Planet"> | string
  }

  export type TradeRouteUpsertWithWhereUniqueWithoutOriginInput = {
    where: TradeRouteWhereUniqueInput
    update: XOR<TradeRouteUpdateWithoutOriginInput, TradeRouteUncheckedUpdateWithoutOriginInput>
    create: XOR<TradeRouteCreateWithoutOriginInput, TradeRouteUncheckedCreateWithoutOriginInput>
  }

  export type TradeRouteUpdateWithWhereUniqueWithoutOriginInput = {
    where: TradeRouteWhereUniqueInput
    data: XOR<TradeRouteUpdateWithoutOriginInput, TradeRouteUncheckedUpdateWithoutOriginInput>
  }

  export type TradeRouteUpdateManyWithWhereWithoutOriginInput = {
    where: TradeRouteScalarWhereInput
    data: XOR<TradeRouteUpdateManyMutationInput, TradeRouteUncheckedUpdateManyWithoutOriginInput>
  }

  export type TradeRouteScalarWhereInput = {
    AND?: TradeRouteScalarWhereInput | TradeRouteScalarWhereInput[]
    OR?: TradeRouteScalarWhereInput[]
    NOT?: TradeRouteScalarWhereInput | TradeRouteScalarWhereInput[]
    id?: StringFilter<"TradeRoute"> | string
    name?: StringFilter<"TradeRoute"> | string
    distance?: IntFilter<"TradeRoute"> | number
    difficulty?: IntFilter<"TradeRoute"> | number
    originId?: StringFilter<"TradeRoute"> | string
    destinationId?: StringFilter<"TradeRoute"> | string
    cargoTypes?: StringNullableListFilter<"TradeRoute">
    profitMargin?: FloatNullableFilter<"TradeRoute"> | number | null
  }

  export type TradeRouteUpsertWithWhereUniqueWithoutDestinationInput = {
    where: TradeRouteWhereUniqueInput
    update: XOR<TradeRouteUpdateWithoutDestinationInput, TradeRouteUncheckedUpdateWithoutDestinationInput>
    create: XOR<TradeRouteCreateWithoutDestinationInput, TradeRouteUncheckedCreateWithoutDestinationInput>
  }

  export type TradeRouteUpdateWithWhereUniqueWithoutDestinationInput = {
    where: TradeRouteWhereUniqueInput
    data: XOR<TradeRouteUpdateWithoutDestinationInput, TradeRouteUncheckedUpdateWithoutDestinationInput>
  }

  export type TradeRouteUpdateManyWithWhereWithoutDestinationInput = {
    where: TradeRouteScalarWhereInput
    data: XOR<TradeRouteUpdateManyMutationInput, TradeRouteUncheckedUpdateManyWithoutDestinationInput>
  }

  export type StarSystemCreateWithoutPlanetsInput = {
    id?: string
    name: string
    hexLocation: string
    sector: string
    subsector?: string | null
    allegiance?: string | null
    starType?: string | null
    gasGiants?: number
    jumpRoutes?: StarSystemCreatejumpRoutesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutStarSystemsInput
    tradeRoutes?: TradeRouteCreateNestedManyWithoutOriginInput
    tradeRoutesDestination?: TradeRouteCreateNestedManyWithoutDestinationInput
  }

  export type StarSystemUncheckedCreateWithoutPlanetsInput = {
    id?: string
    name: string
    hexLocation: string
    sector: string
    subsector?: string | null
    allegiance?: string | null
    starType?: string | null
    gasGiants?: number
    jumpRoutes?: StarSystemCreatejumpRoutesInput | string[]
    campaignId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tradeRoutes?: TradeRouteUncheckedCreateNestedManyWithoutOriginInput
    tradeRoutesDestination?: TradeRouteUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type StarSystemCreateOrConnectWithoutPlanetsInput = {
    where: StarSystemWhereUniqueInput
    create: XOR<StarSystemCreateWithoutPlanetsInput, StarSystemUncheckedCreateWithoutPlanetsInput>
  }

  export type TradeGoodCreateWithoutPlanetInput = {
    id?: string
    name: string
    category: string
    basePrice: number
    availability?: string | null
    legality?: string | null
    dtm?: number
  }

  export type TradeGoodUncheckedCreateWithoutPlanetInput = {
    id?: string
    name: string
    category: string
    basePrice: number
    availability?: string | null
    legality?: string | null
    dtm?: number
  }

  export type TradeGoodCreateOrConnectWithoutPlanetInput = {
    where: TradeGoodWhereUniqueInput
    create: XOR<TradeGoodCreateWithoutPlanetInput, TradeGoodUncheckedCreateWithoutPlanetInput>
  }

  export type TradeGoodCreateManyPlanetInputEnvelope = {
    data: TradeGoodCreateManyPlanetInput | TradeGoodCreateManyPlanetInput[]
    skipDuplicates?: boolean
  }

  export type StarSystemUpsertWithoutPlanetsInput = {
    update: XOR<StarSystemUpdateWithoutPlanetsInput, StarSystemUncheckedUpdateWithoutPlanetsInput>
    create: XOR<StarSystemCreateWithoutPlanetsInput, StarSystemUncheckedCreateWithoutPlanetsInput>
    where?: StarSystemWhereInput
  }

  export type StarSystemUpdateToOneWithWhereWithoutPlanetsInput = {
    where?: StarSystemWhereInput
    data: XOR<StarSystemUpdateWithoutPlanetsInput, StarSystemUncheckedUpdateWithoutPlanetsInput>
  }

  export type StarSystemUpdateWithoutPlanetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hexLocation?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    subsector?: NullableStringFieldUpdateOperationsInput | string | null
    allegiance?: NullableStringFieldUpdateOperationsInput | string | null
    starType?: NullableStringFieldUpdateOperationsInput | string | null
    gasGiants?: IntFieldUpdateOperationsInput | number
    jumpRoutes?: StarSystemUpdatejumpRoutesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutStarSystemsNestedInput
    tradeRoutes?: TradeRouteUpdateManyWithoutOriginNestedInput
    tradeRoutesDestination?: TradeRouteUpdateManyWithoutDestinationNestedInput
  }

  export type StarSystemUncheckedUpdateWithoutPlanetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hexLocation?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    subsector?: NullableStringFieldUpdateOperationsInput | string | null
    allegiance?: NullableStringFieldUpdateOperationsInput | string | null
    starType?: NullableStringFieldUpdateOperationsInput | string | null
    gasGiants?: IntFieldUpdateOperationsInput | number
    jumpRoutes?: StarSystemUpdatejumpRoutesInput | string[]
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tradeRoutes?: TradeRouteUncheckedUpdateManyWithoutOriginNestedInput
    tradeRoutesDestination?: TradeRouteUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type TradeGoodUpsertWithWhereUniqueWithoutPlanetInput = {
    where: TradeGoodWhereUniqueInput
    update: XOR<TradeGoodUpdateWithoutPlanetInput, TradeGoodUncheckedUpdateWithoutPlanetInput>
    create: XOR<TradeGoodCreateWithoutPlanetInput, TradeGoodUncheckedCreateWithoutPlanetInput>
  }

  export type TradeGoodUpdateWithWhereUniqueWithoutPlanetInput = {
    where: TradeGoodWhereUniqueInput
    data: XOR<TradeGoodUpdateWithoutPlanetInput, TradeGoodUncheckedUpdateWithoutPlanetInput>
  }

  export type TradeGoodUpdateManyWithWhereWithoutPlanetInput = {
    where: TradeGoodScalarWhereInput
    data: XOR<TradeGoodUpdateManyMutationInput, TradeGoodUncheckedUpdateManyWithoutPlanetInput>
  }

  export type TradeGoodScalarWhereInput = {
    AND?: TradeGoodScalarWhereInput | TradeGoodScalarWhereInput[]
    OR?: TradeGoodScalarWhereInput[]
    NOT?: TradeGoodScalarWhereInput | TradeGoodScalarWhereInput[]
    id?: StringFilter<"TradeGood"> | string
    name?: StringFilter<"TradeGood"> | string
    category?: StringFilter<"TradeGood"> | string
    basePrice?: IntFilter<"TradeGood"> | number
    availability?: StringNullableFilter<"TradeGood"> | string | null
    legality?: StringNullableFilter<"TradeGood"> | string | null
    dtm?: IntFilter<"TradeGood"> | number
    planetId?: StringNullableFilter<"TradeGood"> | string | null
  }

  export type CampaignCreateWithoutStarshipsInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    gamemaster: UserCreateNestedOneWithoutOwnedCampaignsInput
    members?: CampaignMemberCreateNestedManyWithoutCampaignInput
    characters?: CharacterCreateNestedManyWithoutCampaignInput
    sessions?: SessionCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleCreateNestedManyWithoutCampaignInput
    handouts?: HandoutCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutStarshipsInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CampaignMemberUncheckedCreateNestedManyWithoutCampaignInput
    characters?: CharacterUncheckedCreateNestedManyWithoutCampaignInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemUncheckedCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentUncheckedCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleUncheckedCreateNestedManyWithoutCampaignInput
    handouts?: HandoutUncheckedCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutStarshipsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutStarshipsInput, CampaignUncheckedCreateWithoutStarshipsInput>
  }

  export type CampaignUpsertWithoutStarshipsInput = {
    update: XOR<CampaignUpdateWithoutStarshipsInput, CampaignUncheckedUpdateWithoutStarshipsInput>
    create: XOR<CampaignCreateWithoutStarshipsInput, CampaignUncheckedCreateWithoutStarshipsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutStarshipsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutStarshipsInput, CampaignUncheckedUpdateWithoutStarshipsInput>
  }

  export type CampaignUpdateWithoutStarshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamemaster?: UserUpdateOneRequiredWithoutOwnedCampaignsNestedInput
    members?: CampaignMemberUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutStarshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CampaignMemberUncheckedUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUncheckedUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUncheckedUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUncheckedUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUncheckedUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type PlanetCreateWithoutTradeGoodsInput = {
    id?: string
    name: string
    uwp: string
    size: number
    atmosphere: number
    hydrographics: number
    population: number
    government: number
    lawLevel: number
    techLevel: number
    starport: string
    tradeCodes?: PlanetCreatetradeCodesInput | string[]
    bases?: PlanetCreatebasesInput | string[]
    gasGiant?: boolean
    description?: string | null
    notes?: string | null
    starSystem: StarSystemCreateNestedOneWithoutPlanetsInput
  }

  export type PlanetUncheckedCreateWithoutTradeGoodsInput = {
    id?: string
    name: string
    uwp: string
    size: number
    atmosphere: number
    hydrographics: number
    population: number
    government: number
    lawLevel: number
    techLevel: number
    starport: string
    tradeCodes?: PlanetCreatetradeCodesInput | string[]
    bases?: PlanetCreatebasesInput | string[]
    gasGiant?: boolean
    description?: string | null
    notes?: string | null
    starSystemId: string
  }

  export type PlanetCreateOrConnectWithoutTradeGoodsInput = {
    where: PlanetWhereUniqueInput
    create: XOR<PlanetCreateWithoutTradeGoodsInput, PlanetUncheckedCreateWithoutTradeGoodsInput>
  }

  export type PlanetUpsertWithoutTradeGoodsInput = {
    update: XOR<PlanetUpdateWithoutTradeGoodsInput, PlanetUncheckedUpdateWithoutTradeGoodsInput>
    create: XOR<PlanetCreateWithoutTradeGoodsInput, PlanetUncheckedCreateWithoutTradeGoodsInput>
    where?: PlanetWhereInput
  }

  export type PlanetUpdateToOneWithWhereWithoutTradeGoodsInput = {
    where?: PlanetWhereInput
    data: XOR<PlanetUpdateWithoutTradeGoodsInput, PlanetUncheckedUpdateWithoutTradeGoodsInput>
  }

  export type PlanetUpdateWithoutTradeGoodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uwp?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    atmosphere?: IntFieldUpdateOperationsInput | number
    hydrographics?: IntFieldUpdateOperationsInput | number
    population?: IntFieldUpdateOperationsInput | number
    government?: IntFieldUpdateOperationsInput | number
    lawLevel?: IntFieldUpdateOperationsInput | number
    techLevel?: IntFieldUpdateOperationsInput | number
    starport?: StringFieldUpdateOperationsInput | string
    tradeCodes?: PlanetUpdatetradeCodesInput | string[]
    bases?: PlanetUpdatebasesInput | string[]
    gasGiant?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    starSystem?: StarSystemUpdateOneRequiredWithoutPlanetsNestedInput
  }

  export type PlanetUncheckedUpdateWithoutTradeGoodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uwp?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    atmosphere?: IntFieldUpdateOperationsInput | number
    hydrographics?: IntFieldUpdateOperationsInput | number
    population?: IntFieldUpdateOperationsInput | number
    government?: IntFieldUpdateOperationsInput | number
    lawLevel?: IntFieldUpdateOperationsInput | number
    techLevel?: IntFieldUpdateOperationsInput | number
    starport?: StringFieldUpdateOperationsInput | string
    tradeCodes?: PlanetUpdatetradeCodesInput | string[]
    bases?: PlanetUpdatebasesInput | string[]
    gasGiant?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    starSystemId?: StringFieldUpdateOperationsInput | string
  }

  export type StarSystemCreateWithoutTradeRoutesInput = {
    id?: string
    name: string
    hexLocation: string
    sector: string
    subsector?: string | null
    allegiance?: string | null
    starType?: string | null
    gasGiants?: number
    jumpRoutes?: StarSystemCreatejumpRoutesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutStarSystemsInput
    planets?: PlanetCreateNestedManyWithoutStarSystemInput
    tradeRoutesDestination?: TradeRouteCreateNestedManyWithoutDestinationInput
  }

  export type StarSystemUncheckedCreateWithoutTradeRoutesInput = {
    id?: string
    name: string
    hexLocation: string
    sector: string
    subsector?: string | null
    allegiance?: string | null
    starType?: string | null
    gasGiants?: number
    jumpRoutes?: StarSystemCreatejumpRoutesInput | string[]
    campaignId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planets?: PlanetUncheckedCreateNestedManyWithoutStarSystemInput
    tradeRoutesDestination?: TradeRouteUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type StarSystemCreateOrConnectWithoutTradeRoutesInput = {
    where: StarSystemWhereUniqueInput
    create: XOR<StarSystemCreateWithoutTradeRoutesInput, StarSystemUncheckedCreateWithoutTradeRoutesInput>
  }

  export type StarSystemCreateWithoutTradeRoutesDestinationInput = {
    id?: string
    name: string
    hexLocation: string
    sector: string
    subsector?: string | null
    allegiance?: string | null
    starType?: string | null
    gasGiants?: number
    jumpRoutes?: StarSystemCreatejumpRoutesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign?: CampaignCreateNestedOneWithoutStarSystemsInput
    planets?: PlanetCreateNestedManyWithoutStarSystemInput
    tradeRoutes?: TradeRouteCreateNestedManyWithoutOriginInput
  }

  export type StarSystemUncheckedCreateWithoutTradeRoutesDestinationInput = {
    id?: string
    name: string
    hexLocation: string
    sector: string
    subsector?: string | null
    allegiance?: string | null
    starType?: string | null
    gasGiants?: number
    jumpRoutes?: StarSystemCreatejumpRoutesInput | string[]
    campaignId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planets?: PlanetUncheckedCreateNestedManyWithoutStarSystemInput
    tradeRoutes?: TradeRouteUncheckedCreateNestedManyWithoutOriginInput
  }

  export type StarSystemCreateOrConnectWithoutTradeRoutesDestinationInput = {
    where: StarSystemWhereUniqueInput
    create: XOR<StarSystemCreateWithoutTradeRoutesDestinationInput, StarSystemUncheckedCreateWithoutTradeRoutesDestinationInput>
  }

  export type StarSystemUpsertWithoutTradeRoutesInput = {
    update: XOR<StarSystemUpdateWithoutTradeRoutesInput, StarSystemUncheckedUpdateWithoutTradeRoutesInput>
    create: XOR<StarSystemCreateWithoutTradeRoutesInput, StarSystemUncheckedCreateWithoutTradeRoutesInput>
    where?: StarSystemWhereInput
  }

  export type StarSystemUpdateToOneWithWhereWithoutTradeRoutesInput = {
    where?: StarSystemWhereInput
    data: XOR<StarSystemUpdateWithoutTradeRoutesInput, StarSystemUncheckedUpdateWithoutTradeRoutesInput>
  }

  export type StarSystemUpdateWithoutTradeRoutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hexLocation?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    subsector?: NullableStringFieldUpdateOperationsInput | string | null
    allegiance?: NullableStringFieldUpdateOperationsInput | string | null
    starType?: NullableStringFieldUpdateOperationsInput | string | null
    gasGiants?: IntFieldUpdateOperationsInput | number
    jumpRoutes?: StarSystemUpdatejumpRoutesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutStarSystemsNestedInput
    planets?: PlanetUpdateManyWithoutStarSystemNestedInput
    tradeRoutesDestination?: TradeRouteUpdateManyWithoutDestinationNestedInput
  }

  export type StarSystemUncheckedUpdateWithoutTradeRoutesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hexLocation?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    subsector?: NullableStringFieldUpdateOperationsInput | string | null
    allegiance?: NullableStringFieldUpdateOperationsInput | string | null
    starType?: NullableStringFieldUpdateOperationsInput | string | null
    gasGiants?: IntFieldUpdateOperationsInput | number
    jumpRoutes?: StarSystemUpdatejumpRoutesInput | string[]
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planets?: PlanetUncheckedUpdateManyWithoutStarSystemNestedInput
    tradeRoutesDestination?: TradeRouteUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type StarSystemUpsertWithoutTradeRoutesDestinationInput = {
    update: XOR<StarSystemUpdateWithoutTradeRoutesDestinationInput, StarSystemUncheckedUpdateWithoutTradeRoutesDestinationInput>
    create: XOR<StarSystemCreateWithoutTradeRoutesDestinationInput, StarSystemUncheckedCreateWithoutTradeRoutesDestinationInput>
    where?: StarSystemWhereInput
  }

  export type StarSystemUpdateToOneWithWhereWithoutTradeRoutesDestinationInput = {
    where?: StarSystemWhereInput
    data: XOR<StarSystemUpdateWithoutTradeRoutesDestinationInput, StarSystemUncheckedUpdateWithoutTradeRoutesDestinationInput>
  }

  export type StarSystemUpdateWithoutTradeRoutesDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hexLocation?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    subsector?: NullableStringFieldUpdateOperationsInput | string | null
    allegiance?: NullableStringFieldUpdateOperationsInput | string | null
    starType?: NullableStringFieldUpdateOperationsInput | string | null
    gasGiants?: IntFieldUpdateOperationsInput | number
    jumpRoutes?: StarSystemUpdatejumpRoutesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutStarSystemsNestedInput
    planets?: PlanetUpdateManyWithoutStarSystemNestedInput
    tradeRoutes?: TradeRouteUpdateManyWithoutOriginNestedInput
  }

  export type StarSystemUncheckedUpdateWithoutTradeRoutesDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hexLocation?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    subsector?: NullableStringFieldUpdateOperationsInput | string | null
    allegiance?: NullableStringFieldUpdateOperationsInput | string | null
    starType?: NullableStringFieldUpdateOperationsInput | string | null
    gasGiants?: IntFieldUpdateOperationsInput | number
    jumpRoutes?: StarSystemUpdatejumpRoutesInput | string[]
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planets?: PlanetUncheckedUpdateManyWithoutStarSystemNestedInput
    tradeRoutes?: TradeRouteUncheckedUpdateManyWithoutOriginNestedInput
  }

  export type CampaignCreateWithoutSessionsInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    gamemaster: UserCreateNestedOneWithoutOwnedCampaignsInput
    members?: CampaignMemberCreateNestedManyWithoutCampaignInput
    characters?: CharacterCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemCreateNestedManyWithoutCampaignInput
    starships?: StarshipCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleCreateNestedManyWithoutCampaignInput
    handouts?: HandoutCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CampaignMemberUncheckedCreateNestedManyWithoutCampaignInput
    characters?: CharacterUncheckedCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemUncheckedCreateNestedManyWithoutCampaignInput
    starships?: StarshipUncheckedCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentUncheckedCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleUncheckedCreateNestedManyWithoutCampaignInput
    handouts?: HandoutUncheckedCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutSessionsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutSessionsInput, CampaignUncheckedCreateWithoutSessionsInput>
  }

  export type EncounterCreateWithoutSessionInput = {
    id?: string
    name: string
    description?: string | null
    encounterType: string
    difficulty?: number | null
    location?: string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    outcome?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutEncountersInput
    combatSessions?: CombatSessionCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutSessionInput = {
    id?: string
    name: string
    description?: string | null
    encounterType: string
    difficulty?: number | null
    location?: string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    outcome?: string | null
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    combatSessions?: CombatSessionUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutSessionInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutSessionInput, EncounterUncheckedCreateWithoutSessionInput>
  }

  export type EncounterCreateManySessionInputEnvelope = {
    data: EncounterCreateManySessionInput | EncounterCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type CombatSessionCreateWithoutSessionInput = {
    id?: string
    name?: string | null
    round?: number
    phase?: string
    status?: string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter?: EncounterCreateNestedOneWithoutCombatSessionsInput
    actions?: CombatActionCreateNestedManyWithoutCombatSessionInput
  }

  export type CombatSessionUncheckedCreateWithoutSessionInput = {
    id?: string
    name?: string | null
    round?: number
    phase?: string
    status?: string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    encounterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: CombatActionUncheckedCreateNestedManyWithoutCombatSessionInput
  }

  export type CombatSessionCreateOrConnectWithoutSessionInput = {
    where: CombatSessionWhereUniqueInput
    create: XOR<CombatSessionCreateWithoutSessionInput, CombatSessionUncheckedCreateWithoutSessionInput>
  }

  export type CombatSessionCreateManySessionInputEnvelope = {
    data: CombatSessionCreateManySessionInput | CombatSessionCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type SessionNoteCreateWithoutSessionInput = {
    id?: string
    title?: string | null
    content: string
    noteType?: string
    tags?: SessionNoteCreatetagsInput | string[]
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutSessionNotesInput
    campaign: CampaignCreateNestedOneWithoutSessionNotesInput
  }

  export type SessionNoteUncheckedCreateWithoutSessionInput = {
    id?: string
    title?: string | null
    content: string
    noteType?: string
    tags?: SessionNoteCreatetagsInput | string[]
    isPublic?: boolean
    authorId: string
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionNoteCreateOrConnectWithoutSessionInput = {
    where: SessionNoteWhereUniqueInput
    create: XOR<SessionNoteCreateWithoutSessionInput, SessionNoteUncheckedCreateWithoutSessionInput>
  }

  export type SessionNoteCreateManySessionInputEnvelope = {
    data: SessionNoteCreateManySessionInput | SessionNoteCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type CampaignUpsertWithoutSessionsInput = {
    update: XOR<CampaignUpdateWithoutSessionsInput, CampaignUncheckedUpdateWithoutSessionsInput>
    create: XOR<CampaignCreateWithoutSessionsInput, CampaignUncheckedCreateWithoutSessionsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutSessionsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutSessionsInput, CampaignUncheckedUpdateWithoutSessionsInput>
  }

  export type CampaignUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamemaster?: UserUpdateOneRequiredWithoutOwnedCampaignsNestedInput
    members?: CampaignMemberUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CampaignMemberUncheckedUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUncheckedUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUncheckedUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUncheckedUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUncheckedUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUncheckedUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type EncounterUpsertWithWhereUniqueWithoutSessionInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutSessionInput, EncounterUncheckedUpdateWithoutSessionInput>
    create: XOR<EncounterCreateWithoutSessionInput, EncounterUncheckedCreateWithoutSessionInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutSessionInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutSessionInput, EncounterUncheckedUpdateWithoutSessionInput>
  }

  export type EncounterUpdateManyWithWhereWithoutSessionInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutSessionInput>
  }

  export type CombatSessionUpsertWithWhereUniqueWithoutSessionInput = {
    where: CombatSessionWhereUniqueInput
    update: XOR<CombatSessionUpdateWithoutSessionInput, CombatSessionUncheckedUpdateWithoutSessionInput>
    create: XOR<CombatSessionCreateWithoutSessionInput, CombatSessionUncheckedCreateWithoutSessionInput>
  }

  export type CombatSessionUpdateWithWhereUniqueWithoutSessionInput = {
    where: CombatSessionWhereUniqueInput
    data: XOR<CombatSessionUpdateWithoutSessionInput, CombatSessionUncheckedUpdateWithoutSessionInput>
  }

  export type CombatSessionUpdateManyWithWhereWithoutSessionInput = {
    where: CombatSessionScalarWhereInput
    data: XOR<CombatSessionUpdateManyMutationInput, CombatSessionUncheckedUpdateManyWithoutSessionInput>
  }

  export type CombatSessionScalarWhereInput = {
    AND?: CombatSessionScalarWhereInput | CombatSessionScalarWhereInput[]
    OR?: CombatSessionScalarWhereInput[]
    NOT?: CombatSessionScalarWhereInput | CombatSessionScalarWhereInput[]
    id?: StringFilter<"CombatSession"> | string
    name?: StringNullableFilter<"CombatSession"> | string | null
    round?: IntFilter<"CombatSession"> | number
    phase?: StringFilter<"CombatSession"> | string
    status?: StringFilter<"CombatSession"> | string
    initiative?: JsonNullableFilter<"CombatSession">
    encounterId?: StringNullableFilter<"CombatSession"> | string | null
    sessionId?: StringNullableFilter<"CombatSession"> | string | null
    createdAt?: DateTimeFilter<"CombatSession"> | Date | string
    updatedAt?: DateTimeFilter<"CombatSession"> | Date | string
  }

  export type SessionNoteUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionNoteWhereUniqueInput
    update: XOR<SessionNoteUpdateWithoutSessionInput, SessionNoteUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionNoteCreateWithoutSessionInput, SessionNoteUncheckedCreateWithoutSessionInput>
  }

  export type SessionNoteUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionNoteWhereUniqueInput
    data: XOR<SessionNoteUpdateWithoutSessionInput, SessionNoteUncheckedUpdateWithoutSessionInput>
  }

  export type SessionNoteUpdateManyWithWhereWithoutSessionInput = {
    where: SessionNoteScalarWhereInput
    data: XOR<SessionNoteUpdateManyMutationInput, SessionNoteUncheckedUpdateManyWithoutSessionInput>
  }

  export type CampaignCreateWithoutEncountersInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    gamemaster: UserCreateNestedOneWithoutOwnedCampaignsInput
    members?: CampaignMemberCreateNestedManyWithoutCampaignInput
    characters?: CharacterCreateNestedManyWithoutCampaignInput
    sessions?: SessionCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemCreateNestedManyWithoutCampaignInput
    starships?: StarshipCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleCreateNestedManyWithoutCampaignInput
    handouts?: HandoutCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutEncountersInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CampaignMemberUncheckedCreateNestedManyWithoutCampaignInput
    characters?: CharacterUncheckedCreateNestedManyWithoutCampaignInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollUncheckedCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemUncheckedCreateNestedManyWithoutCampaignInput
    starships?: StarshipUncheckedCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentUncheckedCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleUncheckedCreateNestedManyWithoutCampaignInput
    handouts?: HandoutUncheckedCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutEncountersInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutEncountersInput, CampaignUncheckedCreateWithoutEncountersInput>
  }

  export type SessionCreateWithoutEncountersInput = {
    id?: string
    name: string
    scheduledFor?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.SessionStatus
    participants?: SessionCreateparticipantsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutSessionsInput
    combatSessions?: CombatSessionCreateNestedManyWithoutSessionInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutEncountersInput = {
    id?: string
    name: string
    scheduledFor?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.SessionStatus
    campaignId: string
    participants?: SessionCreateparticipantsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    combatSessions?: CombatSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutEncountersInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutEncountersInput, SessionUncheckedCreateWithoutEncountersInput>
  }

  export type CombatSessionCreateWithoutEncounterInput = {
    id?: string
    name?: string | null
    round?: number
    phase?: string
    status?: string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    session?: SessionCreateNestedOneWithoutCombatSessionsInput
    actions?: CombatActionCreateNestedManyWithoutCombatSessionInput
  }

  export type CombatSessionUncheckedCreateWithoutEncounterInput = {
    id?: string
    name?: string | null
    round?: number
    phase?: string
    status?: string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: CombatActionUncheckedCreateNestedManyWithoutCombatSessionInput
  }

  export type CombatSessionCreateOrConnectWithoutEncounterInput = {
    where: CombatSessionWhereUniqueInput
    create: XOR<CombatSessionCreateWithoutEncounterInput, CombatSessionUncheckedCreateWithoutEncounterInput>
  }

  export type CombatSessionCreateManyEncounterInputEnvelope = {
    data: CombatSessionCreateManyEncounterInput | CombatSessionCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type CampaignUpsertWithoutEncountersInput = {
    update: XOR<CampaignUpdateWithoutEncountersInput, CampaignUncheckedUpdateWithoutEncountersInput>
    create: XOR<CampaignCreateWithoutEncountersInput, CampaignUncheckedCreateWithoutEncountersInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutEncountersInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutEncountersInput, CampaignUncheckedUpdateWithoutEncountersInput>
  }

  export type CampaignUpdateWithoutEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamemaster?: UserUpdateOneRequiredWithoutOwnedCampaignsNestedInput
    members?: CampaignMemberUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CampaignMemberUncheckedUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUncheckedUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUncheckedUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUncheckedUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUncheckedUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUncheckedUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUncheckedUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type SessionUpsertWithoutEncountersInput = {
    update: XOR<SessionUpdateWithoutEncountersInput, SessionUncheckedUpdateWithoutEncountersInput>
    create: XOR<SessionCreateWithoutEncountersInput, SessionUncheckedCreateWithoutEncountersInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutEncountersInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutEncountersInput, SessionUncheckedUpdateWithoutEncountersInput>
  }

  export type SessionUpdateWithoutEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    participants?: SessionUpdateparticipantsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutSessionsNestedInput
    combatSessions?: CombatSessionUpdateManyWithoutSessionNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutEncountersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    campaignId?: StringFieldUpdateOperationsInput | string
    participants?: SessionUpdateparticipantsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    combatSessions?: CombatSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CombatSessionUpsertWithWhereUniqueWithoutEncounterInput = {
    where: CombatSessionWhereUniqueInput
    update: XOR<CombatSessionUpdateWithoutEncounterInput, CombatSessionUncheckedUpdateWithoutEncounterInput>
    create: XOR<CombatSessionCreateWithoutEncounterInput, CombatSessionUncheckedCreateWithoutEncounterInput>
  }

  export type CombatSessionUpdateWithWhereUniqueWithoutEncounterInput = {
    where: CombatSessionWhereUniqueInput
    data: XOR<CombatSessionUpdateWithoutEncounterInput, CombatSessionUncheckedUpdateWithoutEncounterInput>
  }

  export type CombatSessionUpdateManyWithWhereWithoutEncounterInput = {
    where: CombatSessionScalarWhereInput
    data: XOR<CombatSessionUpdateManyMutationInput, CombatSessionUncheckedUpdateManyWithoutEncounterInput>
  }

  export type EncounterCreateWithoutCombatSessionsInput = {
    id?: string
    name: string
    description?: string | null
    encounterType: string
    difficulty?: number | null
    location?: string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    outcome?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutEncountersInput
    session?: SessionCreateNestedOneWithoutEncountersInput
  }

  export type EncounterUncheckedCreateWithoutCombatSessionsInput = {
    id?: string
    name: string
    description?: string | null
    encounterType: string
    difficulty?: number | null
    location?: string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    outcome?: string | null
    campaignId: string
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterCreateOrConnectWithoutCombatSessionsInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutCombatSessionsInput, EncounterUncheckedCreateWithoutCombatSessionsInput>
  }

  export type SessionCreateWithoutCombatSessionsInput = {
    id?: string
    name: string
    scheduledFor?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.SessionStatus
    participants?: SessionCreateparticipantsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutSessionsInput
    encounters?: EncounterCreateNestedManyWithoutSessionInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutCombatSessionsInput = {
    id?: string
    name: string
    scheduledFor?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.SessionStatus
    campaignId: string
    participants?: SessionCreateparticipantsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterUncheckedCreateNestedManyWithoutSessionInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutCombatSessionsInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutCombatSessionsInput, SessionUncheckedCreateWithoutCombatSessionsInput>
  }

  export type CombatActionCreateWithoutCombatSessionInput = {
    id?: string
    actionType: string
    description?: string | null
    target?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    diceRolled?: string | null
    rollResult?: number | null
    modifiers?: NullableJsonNullValueInput | InputJsonValue
    round: number
    timestamp?: Date | string
    character?: CharacterCreateNestedOneWithoutCombatActionsInput
  }

  export type CombatActionUncheckedCreateWithoutCombatSessionInput = {
    id?: string
    actionType: string
    description?: string | null
    target?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    diceRolled?: string | null
    rollResult?: number | null
    modifiers?: NullableJsonNullValueInput | InputJsonValue
    characterId?: string | null
    round: number
    timestamp?: Date | string
  }

  export type CombatActionCreateOrConnectWithoutCombatSessionInput = {
    where: CombatActionWhereUniqueInput
    create: XOR<CombatActionCreateWithoutCombatSessionInput, CombatActionUncheckedCreateWithoutCombatSessionInput>
  }

  export type CombatActionCreateManyCombatSessionInputEnvelope = {
    data: CombatActionCreateManyCombatSessionInput | CombatActionCreateManyCombatSessionInput[]
    skipDuplicates?: boolean
  }

  export type EncounterUpsertWithoutCombatSessionsInput = {
    update: XOR<EncounterUpdateWithoutCombatSessionsInput, EncounterUncheckedUpdateWithoutCombatSessionsInput>
    create: XOR<EncounterCreateWithoutCombatSessionsInput, EncounterUncheckedCreateWithoutCombatSessionsInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutCombatSessionsInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutCombatSessionsInput, EncounterUncheckedUpdateWithoutCombatSessionsInput>
  }

  export type EncounterUpdateWithoutCombatSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterType?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutEncountersNestedInput
    session?: SessionUpdateOneWithoutEncountersNestedInput
  }

  export type EncounterUncheckedUpdateWithoutCombatSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterType?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpsertWithoutCombatSessionsInput = {
    update: XOR<SessionUpdateWithoutCombatSessionsInput, SessionUncheckedUpdateWithoutCombatSessionsInput>
    create: XOR<SessionCreateWithoutCombatSessionsInput, SessionUncheckedCreateWithoutCombatSessionsInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutCombatSessionsInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutCombatSessionsInput, SessionUncheckedUpdateWithoutCombatSessionsInput>
  }

  export type SessionUpdateWithoutCombatSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    participants?: SessionUpdateparticipantsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutSessionsNestedInput
    encounters?: EncounterUpdateManyWithoutSessionNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutCombatSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    campaignId?: StringFieldUpdateOperationsInput | string
    participants?: SessionUpdateparticipantsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUncheckedUpdateManyWithoutSessionNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CombatActionUpsertWithWhereUniqueWithoutCombatSessionInput = {
    where: CombatActionWhereUniqueInput
    update: XOR<CombatActionUpdateWithoutCombatSessionInput, CombatActionUncheckedUpdateWithoutCombatSessionInput>
    create: XOR<CombatActionCreateWithoutCombatSessionInput, CombatActionUncheckedCreateWithoutCombatSessionInput>
  }

  export type CombatActionUpdateWithWhereUniqueWithoutCombatSessionInput = {
    where: CombatActionWhereUniqueInput
    data: XOR<CombatActionUpdateWithoutCombatSessionInput, CombatActionUncheckedUpdateWithoutCombatSessionInput>
  }

  export type CombatActionUpdateManyWithWhereWithoutCombatSessionInput = {
    where: CombatActionScalarWhereInput
    data: XOR<CombatActionUpdateManyMutationInput, CombatActionUncheckedUpdateManyWithoutCombatSessionInput>
  }

  export type CharacterCreateWithoutCombatActionsInput = {
    id?: string
    name: string
    credits?: number
    notes?: string | null
    portrait?: string | null
    homeworld?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    player: UserCreateNestedOneWithoutCharactersInput
    campaign: CampaignCreateNestedOneWithoutCharactersInput
    characteristics?: CharacteristicsCreateNestedOneWithoutCharacterInput
    skills?: CharacterSkillCreateNestedManyWithoutCharacterInput
    equipment?: CharacterEquipmentCreateNestedManyWithoutCharacterInput
    lifeEvents?: LifeEventCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutCombatActionsInput = {
    id?: string
    name: string
    credits?: number
    notes?: string | null
    portrait?: string | null
    homeworld?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    playerId: string
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    characteristics?: CharacteristicsUncheckedCreateNestedOneWithoutCharacterInput
    skills?: CharacterSkillUncheckedCreateNestedManyWithoutCharacterInput
    equipment?: CharacterEquipmentUncheckedCreateNestedManyWithoutCharacterInput
    lifeEvents?: LifeEventUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutCombatActionsInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutCombatActionsInput, CharacterUncheckedCreateWithoutCombatActionsInput>
  }

  export type CombatSessionCreateWithoutActionsInput = {
    id?: string
    name?: string | null
    round?: number
    phase?: string
    status?: string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    encounter?: EncounterCreateNestedOneWithoutCombatSessionsInput
    session?: SessionCreateNestedOneWithoutCombatSessionsInput
  }

  export type CombatSessionUncheckedCreateWithoutActionsInput = {
    id?: string
    name?: string | null
    round?: number
    phase?: string
    status?: string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    encounterId?: string | null
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CombatSessionCreateOrConnectWithoutActionsInput = {
    where: CombatSessionWhereUniqueInput
    create: XOR<CombatSessionCreateWithoutActionsInput, CombatSessionUncheckedCreateWithoutActionsInput>
  }

  export type CharacterUpsertWithoutCombatActionsInput = {
    update: XOR<CharacterUpdateWithoutCombatActionsInput, CharacterUncheckedUpdateWithoutCombatActionsInput>
    create: XOR<CharacterCreateWithoutCombatActionsInput, CharacterUncheckedCreateWithoutCombatActionsInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutCombatActionsInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutCombatActionsInput, CharacterUncheckedUpdateWithoutCombatActionsInput>
  }

  export type CharacterUpdateWithoutCombatActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: UserUpdateOneRequiredWithoutCharactersNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutCharactersNestedInput
    characteristics?: CharacteristicsUpdateOneWithoutCharacterNestedInput
    skills?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    equipment?: CharacterEquipmentUpdateManyWithoutCharacterNestedInput
    lifeEvents?: LifeEventUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutCombatActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    playerId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characteristics?: CharacteristicsUncheckedUpdateOneWithoutCharacterNestedInput
    skills?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    equipment?: CharacterEquipmentUncheckedUpdateManyWithoutCharacterNestedInput
    lifeEvents?: LifeEventUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CombatSessionUpsertWithoutActionsInput = {
    update: XOR<CombatSessionUpdateWithoutActionsInput, CombatSessionUncheckedUpdateWithoutActionsInput>
    create: XOR<CombatSessionCreateWithoutActionsInput, CombatSessionUncheckedCreateWithoutActionsInput>
    where?: CombatSessionWhereInput
  }

  export type CombatSessionUpdateToOneWithWhereWithoutActionsInput = {
    where?: CombatSessionWhereInput
    data: XOR<CombatSessionUpdateWithoutActionsInput, CombatSessionUncheckedUpdateWithoutActionsInput>
  }

  export type CombatSessionUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneWithoutCombatSessionsNestedInput
    session?: SessionUpdateOneWithoutCombatSessionsNestedInput
  }

  export type CombatSessionUncheckedUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutDiceRollsInput = {
    id?: string
    email: string
    displayName?: string | null
    avatar?: string | null
    timezone?: string
    subscriptionTier?: $Enums.SubscriptionTier
    cognitoUserId: string
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ownedCampaigns?: CampaignCreateNestedManyWithoutGamemasterInput
    campaignMembers?: CampaignMemberCreateNestedManyWithoutUserInput
    characters?: CharacterCreateNestedManyWithoutPlayerInput
    customContent?: CustomContentCreateNestedManyWithoutAuthorInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutAuthorInput
    handouts?: HandoutCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutDiceRollsInput = {
    id?: string
    email: string
    displayName?: string | null
    avatar?: string | null
    timezone?: string
    subscriptionTier?: $Enums.SubscriptionTier
    cognitoUserId: string
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ownedCampaigns?: CampaignUncheckedCreateNestedManyWithoutGamemasterInput
    campaignMembers?: CampaignMemberUncheckedCreateNestedManyWithoutUserInput
    characters?: CharacterUncheckedCreateNestedManyWithoutPlayerInput
    customContent?: CustomContentUncheckedCreateNestedManyWithoutAuthorInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutAuthorInput
    handouts?: HandoutUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutDiceRollsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDiceRollsInput, UserUncheckedCreateWithoutDiceRollsInput>
  }

  export type CampaignCreateWithoutDiceRollsInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    gamemaster: UserCreateNestedOneWithoutOwnedCampaignsInput
    members?: CampaignMemberCreateNestedManyWithoutCampaignInput
    characters?: CharacterCreateNestedManyWithoutCampaignInput
    sessions?: SessionCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemCreateNestedManyWithoutCampaignInput
    starships?: StarshipCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleCreateNestedManyWithoutCampaignInput
    handouts?: HandoutCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutDiceRollsInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CampaignMemberUncheckedCreateNestedManyWithoutCampaignInput
    characters?: CharacterUncheckedCreateNestedManyWithoutCampaignInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemUncheckedCreateNestedManyWithoutCampaignInput
    starships?: StarshipUncheckedCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentUncheckedCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleUncheckedCreateNestedManyWithoutCampaignInput
    handouts?: HandoutUncheckedCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutDiceRollsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutDiceRollsInput, CampaignUncheckedCreateWithoutDiceRollsInput>
  }

  export type UserUpsertWithoutDiceRollsInput = {
    update: XOR<UserUpdateWithoutDiceRollsInput, UserUncheckedUpdateWithoutDiceRollsInput>
    create: XOR<UserCreateWithoutDiceRollsInput, UserUncheckedCreateWithoutDiceRollsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDiceRollsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDiceRollsInput, UserUncheckedUpdateWithoutDiceRollsInput>
  }

  export type UserUpdateWithoutDiceRollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownedCampaigns?: CampaignUpdateManyWithoutGamemasterNestedInput
    campaignMembers?: CampaignMemberUpdateManyWithoutUserNestedInput
    characters?: CharacterUpdateManyWithoutPlayerNestedInput
    customContent?: CustomContentUpdateManyWithoutAuthorNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutAuthorNestedInput
    handouts?: HandoutUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutDiceRollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownedCampaigns?: CampaignUncheckedUpdateManyWithoutGamemasterNestedInput
    campaignMembers?: CampaignMemberUncheckedUpdateManyWithoutUserNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutPlayerNestedInput
    customContent?: CustomContentUncheckedUpdateManyWithoutAuthorNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutAuthorNestedInput
    handouts?: HandoutUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type CampaignUpsertWithoutDiceRollsInput = {
    update: XOR<CampaignUpdateWithoutDiceRollsInput, CampaignUncheckedUpdateWithoutDiceRollsInput>
    create: XOR<CampaignCreateWithoutDiceRollsInput, CampaignUncheckedCreateWithoutDiceRollsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutDiceRollsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutDiceRollsInput, CampaignUncheckedUpdateWithoutDiceRollsInput>
  }

  export type CampaignUpdateWithoutDiceRollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamemaster?: UserUpdateOneRequiredWithoutOwnedCampaignsNestedInput
    members?: CampaignMemberUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutDiceRollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CampaignMemberUncheckedUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUncheckedUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUncheckedUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUncheckedUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUncheckedUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUncheckedUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type UserCreateWithoutCustomContentInput = {
    id?: string
    email: string
    displayName?: string | null
    avatar?: string | null
    timezone?: string
    subscriptionTier?: $Enums.SubscriptionTier
    cognitoUserId: string
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ownedCampaigns?: CampaignCreateNestedManyWithoutGamemasterInput
    campaignMembers?: CampaignMemberCreateNestedManyWithoutUserInput
    characters?: CharacterCreateNestedManyWithoutPlayerInput
    diceRolls?: DiceRollCreateNestedManyWithoutRollerInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutAuthorInput
    handouts?: HandoutCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutCustomContentInput = {
    id?: string
    email: string
    displayName?: string | null
    avatar?: string | null
    timezone?: string
    subscriptionTier?: $Enums.SubscriptionTier
    cognitoUserId: string
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ownedCampaigns?: CampaignUncheckedCreateNestedManyWithoutGamemasterInput
    campaignMembers?: CampaignMemberUncheckedCreateNestedManyWithoutUserInput
    characters?: CharacterUncheckedCreateNestedManyWithoutPlayerInput
    diceRolls?: DiceRollUncheckedCreateNestedManyWithoutRollerInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutAuthorInput
    handouts?: HandoutUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutCustomContentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomContentInput, UserUncheckedCreateWithoutCustomContentInput>
  }

  export type CampaignCreateWithoutCustomContentInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    gamemaster: UserCreateNestedOneWithoutOwnedCampaignsInput
    members?: CampaignMemberCreateNestedManyWithoutCampaignInput
    characters?: CharacterCreateNestedManyWithoutCampaignInput
    sessions?: SessionCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemCreateNestedManyWithoutCampaignInput
    starships?: StarshipCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleCreateNestedManyWithoutCampaignInput
    handouts?: HandoutCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCustomContentInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CampaignMemberUncheckedCreateNestedManyWithoutCampaignInput
    characters?: CharacterUncheckedCreateNestedManyWithoutCampaignInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemUncheckedCreateNestedManyWithoutCampaignInput
    starships?: StarshipUncheckedCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleUncheckedCreateNestedManyWithoutCampaignInput
    handouts?: HandoutUncheckedCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCustomContentInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCustomContentInput, CampaignUncheckedCreateWithoutCustomContentInput>
  }

  export type UserUpsertWithoutCustomContentInput = {
    update: XOR<UserUpdateWithoutCustomContentInput, UserUncheckedUpdateWithoutCustomContentInput>
    create: XOR<UserCreateWithoutCustomContentInput, UserUncheckedCreateWithoutCustomContentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCustomContentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCustomContentInput, UserUncheckedUpdateWithoutCustomContentInput>
  }

  export type UserUpdateWithoutCustomContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownedCampaigns?: CampaignUpdateManyWithoutGamemasterNestedInput
    campaignMembers?: CampaignMemberUpdateManyWithoutUserNestedInput
    characters?: CharacterUpdateManyWithoutPlayerNestedInput
    diceRolls?: DiceRollUpdateManyWithoutRollerNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutAuthorNestedInput
    handouts?: HandoutUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownedCampaigns?: CampaignUncheckedUpdateManyWithoutGamemasterNestedInput
    campaignMembers?: CampaignMemberUncheckedUpdateManyWithoutUserNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutPlayerNestedInput
    diceRolls?: DiceRollUncheckedUpdateManyWithoutRollerNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutAuthorNestedInput
    handouts?: HandoutUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type CampaignUpsertWithoutCustomContentInput = {
    update: XOR<CampaignUpdateWithoutCustomContentInput, CampaignUncheckedUpdateWithoutCustomContentInput>
    create: XOR<CampaignCreateWithoutCustomContentInput, CampaignUncheckedCreateWithoutCustomContentInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutCustomContentInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutCustomContentInput, CampaignUncheckedUpdateWithoutCustomContentInput>
  }

  export type CampaignUpdateWithoutCustomContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamemaster?: UserUpdateOneRequiredWithoutOwnedCampaignsNestedInput
    members?: CampaignMemberUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCustomContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CampaignMemberUncheckedUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUncheckedUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUncheckedUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUncheckedUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUncheckedUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutHouseRulesDataInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    gamemaster: UserCreateNestedOneWithoutOwnedCampaignsInput
    members?: CampaignMemberCreateNestedManyWithoutCampaignInput
    characters?: CharacterCreateNestedManyWithoutCampaignInput
    sessions?: SessionCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemCreateNestedManyWithoutCampaignInput
    starships?: StarshipCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentCreateNestedManyWithoutCampaignInput
    handouts?: HandoutCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutHouseRulesDataInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CampaignMemberUncheckedCreateNestedManyWithoutCampaignInput
    characters?: CharacterUncheckedCreateNestedManyWithoutCampaignInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemUncheckedCreateNestedManyWithoutCampaignInput
    starships?: StarshipUncheckedCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentUncheckedCreateNestedManyWithoutCampaignInput
    handouts?: HandoutUncheckedCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutHouseRulesDataInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutHouseRulesDataInput, CampaignUncheckedCreateWithoutHouseRulesDataInput>
  }

  export type CampaignUpsertWithoutHouseRulesDataInput = {
    update: XOR<CampaignUpdateWithoutHouseRulesDataInput, CampaignUncheckedUpdateWithoutHouseRulesDataInput>
    create: XOR<CampaignCreateWithoutHouseRulesDataInput, CampaignUncheckedCreateWithoutHouseRulesDataInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutHouseRulesDataInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutHouseRulesDataInput, CampaignUncheckedUpdateWithoutHouseRulesDataInput>
  }

  export type CampaignUpdateWithoutHouseRulesDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamemaster?: UserUpdateOneRequiredWithoutOwnedCampaignsNestedInput
    members?: CampaignMemberUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutHouseRulesDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CampaignMemberUncheckedUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUncheckedUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUncheckedUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUncheckedUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUncheckedUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type UserCreateWithoutHandoutsInput = {
    id?: string
    email: string
    displayName?: string | null
    avatar?: string | null
    timezone?: string
    subscriptionTier?: $Enums.SubscriptionTier
    cognitoUserId: string
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ownedCampaigns?: CampaignCreateNestedManyWithoutGamemasterInput
    campaignMembers?: CampaignMemberCreateNestedManyWithoutUserInput
    characters?: CharacterCreateNestedManyWithoutPlayerInput
    diceRolls?: DiceRollCreateNestedManyWithoutRollerInput
    customContent?: CustomContentCreateNestedManyWithoutAuthorInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutHandoutsInput = {
    id?: string
    email: string
    displayName?: string | null
    avatar?: string | null
    timezone?: string
    subscriptionTier?: $Enums.SubscriptionTier
    cognitoUserId: string
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ownedCampaigns?: CampaignUncheckedCreateNestedManyWithoutGamemasterInput
    campaignMembers?: CampaignMemberUncheckedCreateNestedManyWithoutUserInput
    characters?: CharacterUncheckedCreateNestedManyWithoutPlayerInput
    diceRolls?: DiceRollUncheckedCreateNestedManyWithoutRollerInput
    customContent?: CustomContentUncheckedCreateNestedManyWithoutAuthorInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutHandoutsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHandoutsInput, UserUncheckedCreateWithoutHandoutsInput>
  }

  export type CampaignCreateWithoutHandoutsInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    gamemaster: UserCreateNestedOneWithoutOwnedCampaignsInput
    members?: CampaignMemberCreateNestedManyWithoutCampaignInput
    characters?: CharacterCreateNestedManyWithoutCampaignInput
    sessions?: SessionCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemCreateNestedManyWithoutCampaignInput
    starships?: StarshipCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutHandoutsInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CampaignMemberUncheckedCreateNestedManyWithoutCampaignInput
    characters?: CharacterUncheckedCreateNestedManyWithoutCampaignInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemUncheckedCreateNestedManyWithoutCampaignInput
    starships?: StarshipUncheckedCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentUncheckedCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleUncheckedCreateNestedManyWithoutCampaignInput
    sessionNotes?: SessionNoteUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutHandoutsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutHandoutsInput, CampaignUncheckedCreateWithoutHandoutsInput>
  }

  export type UserUpsertWithoutHandoutsInput = {
    update: XOR<UserUpdateWithoutHandoutsInput, UserUncheckedUpdateWithoutHandoutsInput>
    create: XOR<UserCreateWithoutHandoutsInput, UserUncheckedCreateWithoutHandoutsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHandoutsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHandoutsInput, UserUncheckedUpdateWithoutHandoutsInput>
  }

  export type UserUpdateWithoutHandoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownedCampaigns?: CampaignUpdateManyWithoutGamemasterNestedInput
    campaignMembers?: CampaignMemberUpdateManyWithoutUserNestedInput
    characters?: CharacterUpdateManyWithoutPlayerNestedInput
    diceRolls?: DiceRollUpdateManyWithoutRollerNestedInput
    customContent?: CustomContentUpdateManyWithoutAuthorNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutHandoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownedCampaigns?: CampaignUncheckedUpdateManyWithoutGamemasterNestedInput
    campaignMembers?: CampaignMemberUncheckedUpdateManyWithoutUserNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutPlayerNestedInput
    diceRolls?: DiceRollUncheckedUpdateManyWithoutRollerNestedInput
    customContent?: CustomContentUncheckedUpdateManyWithoutAuthorNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type CampaignUpsertWithoutHandoutsInput = {
    update: XOR<CampaignUpdateWithoutHandoutsInput, CampaignUncheckedUpdateWithoutHandoutsInput>
    create: XOR<CampaignCreateWithoutHandoutsInput, CampaignUncheckedCreateWithoutHandoutsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutHandoutsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutHandoutsInput, CampaignUncheckedUpdateWithoutHandoutsInput>
  }

  export type CampaignUpdateWithoutHandoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamemaster?: UserUpdateOneRequiredWithoutOwnedCampaignsNestedInput
    members?: CampaignMemberUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutHandoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CampaignMemberUncheckedUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUncheckedUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUncheckedUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUncheckedUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUncheckedUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type UserCreateWithoutSessionNotesInput = {
    id?: string
    email: string
    displayName?: string | null
    avatar?: string | null
    timezone?: string
    subscriptionTier?: $Enums.SubscriptionTier
    cognitoUserId: string
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ownedCampaigns?: CampaignCreateNestedManyWithoutGamemasterInput
    campaignMembers?: CampaignMemberCreateNestedManyWithoutUserInput
    characters?: CharacterCreateNestedManyWithoutPlayerInput
    diceRolls?: DiceRollCreateNestedManyWithoutRollerInput
    customContent?: CustomContentCreateNestedManyWithoutAuthorInput
    handouts?: HandoutCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutSessionNotesInput = {
    id?: string
    email: string
    displayName?: string | null
    avatar?: string | null
    timezone?: string
    subscriptionTier?: $Enums.SubscriptionTier
    cognitoUserId: string
    emailVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ownedCampaigns?: CampaignUncheckedCreateNestedManyWithoutGamemasterInput
    campaignMembers?: CampaignMemberUncheckedCreateNestedManyWithoutUserInput
    characters?: CharacterUncheckedCreateNestedManyWithoutPlayerInput
    diceRolls?: DiceRollUncheckedCreateNestedManyWithoutRollerInput
    customContent?: CustomContentUncheckedCreateNestedManyWithoutAuthorInput
    handouts?: HandoutUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutSessionNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionNotesInput, UserUncheckedCreateWithoutSessionNotesInput>
  }

  export type CampaignCreateWithoutSessionNotesInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    gamemaster: UserCreateNestedOneWithoutOwnedCampaignsInput
    members?: CampaignMemberCreateNestedManyWithoutCampaignInput
    characters?: CharacterCreateNestedManyWithoutCampaignInput
    sessions?: SessionCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollCreateNestedManyWithoutCampaignInput
    encounters?: EncounterCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemCreateNestedManyWithoutCampaignInput
    starships?: StarshipCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleCreateNestedManyWithoutCampaignInput
    handouts?: HandoutCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutSessionNotesInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CampaignMemberUncheckedCreateNestedManyWithoutCampaignInput
    characters?: CharacterUncheckedCreateNestedManyWithoutCampaignInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCampaignInput
    diceRolls?: DiceRollUncheckedCreateNestedManyWithoutCampaignInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutCampaignInput
    starSystems?: StarSystemUncheckedCreateNestedManyWithoutCampaignInput
    starships?: StarshipUncheckedCreateNestedManyWithoutCampaignInput
    customContent?: CustomContentUncheckedCreateNestedManyWithoutCampaignInput
    houseRulesData?: HouseRuleUncheckedCreateNestedManyWithoutCampaignInput
    handouts?: HandoutUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutSessionNotesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutSessionNotesInput, CampaignUncheckedCreateWithoutSessionNotesInput>
  }

  export type SessionCreateWithoutSessionNotesInput = {
    id?: string
    name: string
    scheduledFor?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.SessionStatus
    participants?: SessionCreateparticipantsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutSessionsInput
    encounters?: EncounterCreateNestedManyWithoutSessionInput
    combatSessions?: CombatSessionCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutSessionNotesInput = {
    id?: string
    name: string
    scheduledFor?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.SessionStatus
    campaignId: string
    participants?: SessionCreateparticipantsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    encounters?: EncounterUncheckedCreateNestedManyWithoutSessionInput
    combatSessions?: CombatSessionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutSessionNotesInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutSessionNotesInput, SessionUncheckedCreateWithoutSessionNotesInput>
  }

  export type UserUpsertWithoutSessionNotesInput = {
    update: XOR<UserUpdateWithoutSessionNotesInput, UserUncheckedUpdateWithoutSessionNotesInput>
    create: XOR<UserCreateWithoutSessionNotesInput, UserUncheckedCreateWithoutSessionNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionNotesInput, UserUncheckedUpdateWithoutSessionNotesInput>
  }

  export type UserUpdateWithoutSessionNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownedCampaigns?: CampaignUpdateManyWithoutGamemasterNestedInput
    campaignMembers?: CampaignMemberUpdateManyWithoutUserNestedInput
    characters?: CharacterUpdateManyWithoutPlayerNestedInput
    diceRolls?: DiceRollUpdateManyWithoutRollerNestedInput
    customContent?: CustomContentUpdateManyWithoutAuthorNestedInput
    handouts?: HandoutUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    cognitoUserId?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownedCampaigns?: CampaignUncheckedUpdateManyWithoutGamemasterNestedInput
    campaignMembers?: CampaignMemberUncheckedUpdateManyWithoutUserNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutPlayerNestedInput
    diceRolls?: DiceRollUncheckedUpdateManyWithoutRollerNestedInput
    customContent?: CustomContentUncheckedUpdateManyWithoutAuthorNestedInput
    handouts?: HandoutUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type CampaignUpsertWithoutSessionNotesInput = {
    update: XOR<CampaignUpdateWithoutSessionNotesInput, CampaignUncheckedUpdateWithoutSessionNotesInput>
    create: XOR<CampaignCreateWithoutSessionNotesInput, CampaignUncheckedCreateWithoutSessionNotesInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutSessionNotesInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutSessionNotesInput, CampaignUncheckedUpdateWithoutSessionNotesInput>
  }

  export type CampaignUpdateWithoutSessionNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamemaster?: UserUpdateOneRequiredWithoutOwnedCampaignsNestedInput
    members?: CampaignMemberUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutSessionNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    gamemasterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CampaignMemberUncheckedUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUncheckedUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUncheckedUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUncheckedUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUncheckedUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type SessionUpsertWithoutSessionNotesInput = {
    update: XOR<SessionUpdateWithoutSessionNotesInput, SessionUncheckedUpdateWithoutSessionNotesInput>
    create: XOR<SessionCreateWithoutSessionNotesInput, SessionUncheckedCreateWithoutSessionNotesInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutSessionNotesInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutSessionNotesInput, SessionUncheckedUpdateWithoutSessionNotesInput>
  }

  export type SessionUpdateWithoutSessionNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    participants?: SessionUpdateparticipantsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutSessionsNestedInput
    encounters?: EncounterUpdateManyWithoutSessionNestedInput
    combatSessions?: CombatSessionUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutSessionNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    campaignId?: StringFieldUpdateOperationsInput | string
    participants?: SessionUpdateparticipantsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUncheckedUpdateManyWithoutSessionNestedInput
    combatSessions?: CombatSessionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CampaignCreateManyGamemasterInput = {
    id?: string
    name: string
    description?: string | null
    maxPlayers?: number | null
    isPublic?: boolean
    allowedBooks?: CampaignCreateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignMemberCreateManyUserInput = {
    id?: string
    campaignId: string
    role?: $Enums.CampaignRole
    isActive?: boolean
    joinedAt?: Date | string
  }

  export type CharacterCreateManyPlayerInput = {
    id?: string
    name: string
    credits?: number
    notes?: string | null
    portrait?: string | null
    homeworld?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiceRollCreateManyRollerInput = {
    id?: string
    dice: string
    result: number
    individual?: DiceRollCreateindividualInput | number[]
    modifiers?: DiceRollCreatemodifiersInput | string[]
    description?: string | null
    isPublic?: boolean
    isGMOnly?: boolean
    campaignId: string
    character?: string | null
    skill?: string | null
    timestamp?: Date | string
  }

  export type CustomContentCreateManyAuthorInput = {
    id?: string
    title: string
    description?: string | null
    contentType: string
    category?: string | null
    data: JsonNullValueInput | InputJsonValue
    tags?: CustomContentCreatetagsInput | string[]
    isPublic?: boolean
    isOfficial?: boolean
    campaignId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionNoteCreateManyAuthorInput = {
    id?: string
    title?: string | null
    content: string
    noteType?: string
    tags?: SessionNoteCreatetagsInput | string[]
    isPublic?: boolean
    campaignId: string
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HandoutCreateManyAuthorInput = {
    id?: string
    title: string
    description?: string | null
    content?: string | null
    imageUrl?: string | null
    fileUrl?: string | null
    isPlayerVisible?: boolean
    recipients?: HandoutCreaterecipientsInput | string[]
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateWithoutGamemasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CampaignMemberUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutGamemasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CampaignMemberUncheckedUpdateManyWithoutCampaignNestedInput
    characters?: CharacterUncheckedUpdateManyWithoutCampaignNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCampaignNestedInput
    diceRolls?: DiceRollUncheckedUpdateManyWithoutCampaignNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutCampaignNestedInput
    starSystems?: StarSystemUncheckedUpdateManyWithoutCampaignNestedInput
    starships?: StarshipUncheckedUpdateManyWithoutCampaignNestedInput
    customContent?: CustomContentUncheckedUpdateManyWithoutCampaignNestedInput
    houseRulesData?: HouseRuleUncheckedUpdateManyWithoutCampaignNestedInput
    handouts?: HandoutUncheckedUpdateManyWithoutCampaignNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutGamemasterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxPlayers?: NullableIntFieldUpdateOperationsInput | number | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowedBooks?: CampaignUpdateallowedBooksInput | string[]
    houseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumCampaignRoleFieldUpdateOperationsInput | $Enums.CampaignRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutMembersNestedInput
  }

  export type CampaignMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    role?: EnumCampaignRoleFieldUpdateOperationsInput | $Enums.CampaignRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    role?: EnumCampaignRoleFieldUpdateOperationsInput | $Enums.CampaignRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutCharactersNestedInput
    characteristics?: CharacteristicsUpdateOneWithoutCharacterNestedInput
    skills?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    equipment?: CharacterEquipmentUpdateManyWithoutCharacterNestedInput
    lifeEvents?: LifeEventUpdateManyWithoutCharacterNestedInput
    combatActions?: CombatActionUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characteristics?: CharacteristicsUncheckedUpdateOneWithoutCharacterNestedInput
    skills?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    equipment?: CharacterEquipmentUncheckedUpdateManyWithoutCharacterNestedInput
    lifeEvents?: LifeEventUncheckedUpdateManyWithoutCharacterNestedInput
    combatActions?: CombatActionUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiceRollUpdateWithoutRollerInput = {
    id?: StringFieldUpdateOperationsInput | string
    dice?: StringFieldUpdateOperationsInput | string
    result?: IntFieldUpdateOperationsInput | number
    individual?: DiceRollUpdateindividualInput | number[]
    modifiers?: DiceRollUpdatemodifiersInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isGMOnly?: BoolFieldUpdateOperationsInput | boolean
    character?: NullableStringFieldUpdateOperationsInput | string | null
    skill?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutDiceRollsNestedInput
  }

  export type DiceRollUncheckedUpdateWithoutRollerInput = {
    id?: StringFieldUpdateOperationsInput | string
    dice?: StringFieldUpdateOperationsInput | string
    result?: IntFieldUpdateOperationsInput | number
    individual?: DiceRollUpdateindividualInput | number[]
    modifiers?: DiceRollUpdatemodifiersInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isGMOnly?: BoolFieldUpdateOperationsInput | boolean
    campaignId?: StringFieldUpdateOperationsInput | string
    character?: NullableStringFieldUpdateOperationsInput | string | null
    skill?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiceRollUncheckedUpdateManyWithoutRollerInput = {
    id?: StringFieldUpdateOperationsInput | string
    dice?: StringFieldUpdateOperationsInput | string
    result?: IntFieldUpdateOperationsInput | number
    individual?: DiceRollUpdateindividualInput | number[]
    modifiers?: DiceRollUpdatemodifiersInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isGMOnly?: BoolFieldUpdateOperationsInput | boolean
    campaignId?: StringFieldUpdateOperationsInput | string
    character?: NullableStringFieldUpdateOperationsInput | string | null
    skill?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomContentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    tags?: CustomContentUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneWithoutCustomContentNestedInput
  }

  export type CustomContentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    tags?: CustomContentUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomContentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    tags?: CustomContentUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionNoteUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    tags?: SessionNoteUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutSessionNotesNestedInput
    session?: SessionUpdateOneWithoutSessionNotesNestedInput
  }

  export type SessionNoteUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    tags?: SessionNoteUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    campaignId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionNoteUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    tags?: SessionNoteUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    campaignId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HandoutUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPlayerVisible?: BoolFieldUpdateOperationsInput | boolean
    recipients?: HandoutUpdaterecipientsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutHandoutsNestedInput
  }

  export type HandoutUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPlayerVisible?: BoolFieldUpdateOperationsInput | boolean
    recipients?: HandoutUpdaterecipientsInput | string[]
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HandoutUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPlayerVisible?: BoolFieldUpdateOperationsInput | boolean
    recipients?: HandoutUpdaterecipientsInput | string[]
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMemberCreateManyCampaignInput = {
    id?: string
    userId: string
    role?: $Enums.CampaignRole
    isActive?: boolean
    joinedAt?: Date | string
  }

  export type CharacterCreateManyCampaignInput = {
    id?: string
    name: string
    credits?: number
    notes?: string | null
    portrait?: string | null
    homeworld?: string | null
    age?: number | null
    gender?: string | null
    species?: string | null
    playerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyCampaignInput = {
    id?: string
    name: string
    scheduledFor?: Date | string | null
    duration?: number | null
    notes?: string | null
    status?: $Enums.SessionStatus
    participants?: SessionCreateparticipantsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiceRollCreateManyCampaignInput = {
    id?: string
    dice: string
    result: number
    individual?: DiceRollCreateindividualInput | number[]
    modifiers?: DiceRollCreatemodifiersInput | string[]
    description?: string | null
    isPublic?: boolean
    isGMOnly?: boolean
    rollerId: string
    character?: string | null
    skill?: string | null
    timestamp?: Date | string
  }

  export type EncounterCreateManyCampaignInput = {
    id?: string
    name: string
    description?: string | null
    encounterType: string
    difficulty?: number | null
    location?: string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    outcome?: string | null
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StarSystemCreateManyCampaignInput = {
    id?: string
    name: string
    hexLocation: string
    sector: string
    subsector?: string | null
    allegiance?: string | null
    starType?: string | null
    gasGiants?: number
    jumpRoutes?: StarSystemCreatejumpRoutesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StarshipCreateManyCampaignInput = {
    id?: string
    name: string
    class: string
    hullCode?: string | null
    tonnage: number
    jumpDrive?: number
    maneuverDrive?: number
    powerPlant?: number
    crew?: number
    passengers?: number
    cargo?: number
    fuel?: number
    armor?: number
    weapons?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    location?: string | null
    owner?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomContentCreateManyCampaignInput = {
    id?: string
    title: string
    description?: string | null
    contentType: string
    category?: string | null
    data: JsonNullValueInput | InputJsonValue
    tags?: CustomContentCreatetagsInput | string[]
    isPublic?: boolean
    isOfficial?: boolean
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HouseRuleCreateManyCampaignInput = {
    id?: string
    title: string
    description: string
    category: string
    ruleText: string
    pageReference?: string | null
    replaces?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HandoutCreateManyCampaignInput = {
    id?: string
    title: string
    description?: string | null
    content?: string | null
    imageUrl?: string | null
    fileUrl?: string | null
    isPlayerVisible?: boolean
    recipients?: HandoutCreaterecipientsInput | string[]
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionNoteCreateManyCampaignInput = {
    id?: string
    title?: string | null
    content: string
    noteType?: string
    tags?: SessionNoteCreatetagsInput | string[]
    isPublic?: boolean
    authorId: string
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignMemberUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumCampaignRoleFieldUpdateOperationsInput | $Enums.CampaignRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignMembersNestedInput
  }

  export type CampaignMemberUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumCampaignRoleFieldUpdateOperationsInput | $Enums.CampaignRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMemberUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumCampaignRoleFieldUpdateOperationsInput | $Enums.CampaignRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: UserUpdateOneRequiredWithoutCharactersNestedInput
    characteristics?: CharacteristicsUpdateOneWithoutCharacterNestedInput
    skills?: CharacterSkillUpdateManyWithoutCharacterNestedInput
    equipment?: CharacterEquipmentUpdateManyWithoutCharacterNestedInput
    lifeEvents?: LifeEventUpdateManyWithoutCharacterNestedInput
    combatActions?: CombatActionUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    playerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characteristics?: CharacteristicsUncheckedUpdateOneWithoutCharacterNestedInput
    skills?: CharacterSkillUncheckedUpdateManyWithoutCharacterNestedInput
    equipment?: CharacterEquipmentUncheckedUpdateManyWithoutCharacterNestedInput
    lifeEvents?: LifeEventUncheckedUpdateManyWithoutCharacterNestedInput
    combatActions?: CombatActionUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    portrait?: NullableStringFieldUpdateOperationsInput | string | null
    homeworld?: NullableStringFieldUpdateOperationsInput | string | null
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    species?: NullableStringFieldUpdateOperationsInput | string | null
    playerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    participants?: SessionUpdateparticipantsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUpdateManyWithoutSessionNestedInput
    combatSessions?: CombatSessionUpdateManyWithoutSessionNestedInput
    sessionNotes?: SessionNoteUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    participants?: SessionUpdateparticipantsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounters?: EncounterUncheckedUpdateManyWithoutSessionNestedInput
    combatSessions?: CombatSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionNotes?: SessionNoteUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    participants?: SessionUpdateparticipantsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiceRollUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    dice?: StringFieldUpdateOperationsInput | string
    result?: IntFieldUpdateOperationsInput | number
    individual?: DiceRollUpdateindividualInput | number[]
    modifiers?: DiceRollUpdatemodifiersInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isGMOnly?: BoolFieldUpdateOperationsInput | boolean
    character?: NullableStringFieldUpdateOperationsInput | string | null
    skill?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    roller?: UserUpdateOneRequiredWithoutDiceRollsNestedInput
  }

  export type DiceRollUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    dice?: StringFieldUpdateOperationsInput | string
    result?: IntFieldUpdateOperationsInput | number
    individual?: DiceRollUpdateindividualInput | number[]
    modifiers?: DiceRollUpdatemodifiersInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isGMOnly?: BoolFieldUpdateOperationsInput | boolean
    rollerId?: StringFieldUpdateOperationsInput | string
    character?: NullableStringFieldUpdateOperationsInput | string | null
    skill?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiceRollUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    dice?: StringFieldUpdateOperationsInput | string
    result?: IntFieldUpdateOperationsInput | number
    individual?: DiceRollUpdateindividualInput | number[]
    modifiers?: DiceRollUpdatemodifiersInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isGMOnly?: BoolFieldUpdateOperationsInput | boolean
    rollerId?: StringFieldUpdateOperationsInput | string
    character?: NullableStringFieldUpdateOperationsInput | string | null
    skill?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncounterUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterType?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneWithoutEncountersNestedInput
    combatSessions?: CombatSessionUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterType?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    combatSessions?: CombatSessionUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterType?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StarSystemUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hexLocation?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    subsector?: NullableStringFieldUpdateOperationsInput | string | null
    allegiance?: NullableStringFieldUpdateOperationsInput | string | null
    starType?: NullableStringFieldUpdateOperationsInput | string | null
    gasGiants?: IntFieldUpdateOperationsInput | number
    jumpRoutes?: StarSystemUpdatejumpRoutesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planets?: PlanetUpdateManyWithoutStarSystemNestedInput
    tradeRoutes?: TradeRouteUpdateManyWithoutOriginNestedInput
    tradeRoutesDestination?: TradeRouteUpdateManyWithoutDestinationNestedInput
  }

  export type StarSystemUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hexLocation?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    subsector?: NullableStringFieldUpdateOperationsInput | string | null
    allegiance?: NullableStringFieldUpdateOperationsInput | string | null
    starType?: NullableStringFieldUpdateOperationsInput | string | null
    gasGiants?: IntFieldUpdateOperationsInput | number
    jumpRoutes?: StarSystemUpdatejumpRoutesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planets?: PlanetUncheckedUpdateManyWithoutStarSystemNestedInput
    tradeRoutes?: TradeRouteUncheckedUpdateManyWithoutOriginNestedInput
    tradeRoutesDestination?: TradeRouteUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type StarSystemUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hexLocation?: StringFieldUpdateOperationsInput | string
    sector?: StringFieldUpdateOperationsInput | string
    subsector?: NullableStringFieldUpdateOperationsInput | string | null
    allegiance?: NullableStringFieldUpdateOperationsInput | string | null
    starType?: NullableStringFieldUpdateOperationsInput | string | null
    gasGiants?: IntFieldUpdateOperationsInput | number
    jumpRoutes?: StarSystemUpdatejumpRoutesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StarshipUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    hullCode?: NullableStringFieldUpdateOperationsInput | string | null
    tonnage?: IntFieldUpdateOperationsInput | number
    jumpDrive?: IntFieldUpdateOperationsInput | number
    maneuverDrive?: IntFieldUpdateOperationsInput | number
    powerPlant?: IntFieldUpdateOperationsInput | number
    crew?: IntFieldUpdateOperationsInput | number
    passengers?: IntFieldUpdateOperationsInput | number
    cargo?: IntFieldUpdateOperationsInput | number
    fuel?: IntFieldUpdateOperationsInput | number
    armor?: IntFieldUpdateOperationsInput | number
    weapons?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StarshipUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    hullCode?: NullableStringFieldUpdateOperationsInput | string | null
    tonnage?: IntFieldUpdateOperationsInput | number
    jumpDrive?: IntFieldUpdateOperationsInput | number
    maneuverDrive?: IntFieldUpdateOperationsInput | number
    powerPlant?: IntFieldUpdateOperationsInput | number
    crew?: IntFieldUpdateOperationsInput | number
    passengers?: IntFieldUpdateOperationsInput | number
    cargo?: IntFieldUpdateOperationsInput | number
    fuel?: IntFieldUpdateOperationsInput | number
    armor?: IntFieldUpdateOperationsInput | number
    weapons?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StarshipUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    hullCode?: NullableStringFieldUpdateOperationsInput | string | null
    tonnage?: IntFieldUpdateOperationsInput | number
    jumpDrive?: IntFieldUpdateOperationsInput | number
    maneuverDrive?: IntFieldUpdateOperationsInput | number
    powerPlant?: IntFieldUpdateOperationsInput | number
    crew?: IntFieldUpdateOperationsInput | number
    passengers?: IntFieldUpdateOperationsInput | number
    cargo?: IntFieldUpdateOperationsInput | number
    fuel?: IntFieldUpdateOperationsInput | number
    armor?: IntFieldUpdateOperationsInput | number
    weapons?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomContentUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    tags?: CustomContentUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCustomContentNestedInput
  }

  export type CustomContentUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    tags?: CustomContentUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomContentUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    data?: JsonNullValueInput | InputJsonValue
    tags?: CustomContentUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HouseRuleUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    ruleText?: StringFieldUpdateOperationsInput | string
    pageReference?: NullableStringFieldUpdateOperationsInput | string | null
    replaces?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HouseRuleUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    ruleText?: StringFieldUpdateOperationsInput | string
    pageReference?: NullableStringFieldUpdateOperationsInput | string | null
    replaces?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HouseRuleUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    ruleText?: StringFieldUpdateOperationsInput | string
    pageReference?: NullableStringFieldUpdateOperationsInput | string | null
    replaces?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HandoutUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPlayerVisible?: BoolFieldUpdateOperationsInput | boolean
    recipients?: HandoutUpdaterecipientsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutHandoutsNestedInput
  }

  export type HandoutUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPlayerVisible?: BoolFieldUpdateOperationsInput | boolean
    recipients?: HandoutUpdaterecipientsInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HandoutUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPlayerVisible?: BoolFieldUpdateOperationsInput | boolean
    recipients?: HandoutUpdaterecipientsInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionNoteUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    tags?: SessionNoteUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutSessionNotesNestedInput
    session?: SessionUpdateOneWithoutSessionNotesNestedInput
  }

  export type SessionNoteUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    tags?: SessionNoteUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionNoteUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    tags?: SessionNoteUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterSkillCreateManyCharacterInput = {
    id?: string
    name: string
    level?: number
    specialization?: string | null
  }

  export type CharacterEquipmentCreateManyCharacterInput = {
    id?: string
    name: string
    description?: string | null
    weight?: number | null
    cost?: number | null
    quantity?: number
    equipped?: boolean
    category?: string | null
    subcategory?: string | null
    weaponType?: string | null
    damage?: string | null
    range?: string | null
    armorValue?: number | null
    armorType?: string | null
  }

  export type LifeEventCreateManyCharacterInput = {
    id?: string
    age: number
    event: string
    description?: string | null
    effects?: NullableJsonNullValueInput | InputJsonValue
    career?: string | null
    rank?: string | null
    skills?: LifeEventCreateskillsInput | string[]
  }

  export type CombatActionCreateManyCharacterInput = {
    id?: string
    actionType: string
    description?: string | null
    target?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    diceRolled?: string | null
    rollResult?: number | null
    modifiers?: NullableJsonNullValueInput | InputJsonValue
    combatSessionId: string
    round: number
    timestamp?: Date | string
  }

  export type CharacterSkillUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterSkillUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterSkillUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterEquipmentUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    cost?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    equipped?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    damage?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    armorValue?: NullableIntFieldUpdateOperationsInput | number | null
    armorType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterEquipmentUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    cost?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    equipped?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    damage?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    armorValue?: NullableIntFieldUpdateOperationsInput | number | null
    armorType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterEquipmentUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    cost?: NullableIntFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    equipped?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    subcategory?: NullableStringFieldUpdateOperationsInput | string | null
    weaponType?: NullableStringFieldUpdateOperationsInput | string | null
    damage?: NullableStringFieldUpdateOperationsInput | string | null
    range?: NullableStringFieldUpdateOperationsInput | string | null
    armorValue?: NullableIntFieldUpdateOperationsInput | number | null
    armorType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LifeEventUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effects?: NullableJsonNullValueInput | InputJsonValue
    career?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LifeEventUpdateskillsInput | string[]
  }

  export type LifeEventUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effects?: NullableJsonNullValueInput | InputJsonValue
    career?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LifeEventUpdateskillsInput | string[]
  }

  export type LifeEventUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    effects?: NullableJsonNullValueInput | InputJsonValue
    career?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: LifeEventUpdateskillsInput | string[]
  }

  export type CombatActionUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    diceRolled?: NullableStringFieldUpdateOperationsInput | string | null
    rollResult?: NullableIntFieldUpdateOperationsInput | number | null
    modifiers?: NullableJsonNullValueInput | InputJsonValue
    round?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    combatSession?: CombatSessionUpdateOneRequiredWithoutActionsNestedInput
  }

  export type CombatActionUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    diceRolled?: NullableStringFieldUpdateOperationsInput | string | null
    rollResult?: NullableIntFieldUpdateOperationsInput | number | null
    modifiers?: NullableJsonNullValueInput | InputJsonValue
    combatSessionId?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatActionUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    diceRolled?: NullableStringFieldUpdateOperationsInput | string | null
    rollResult?: NullableIntFieldUpdateOperationsInput | number | null
    modifiers?: NullableJsonNullValueInput | InputJsonValue
    combatSessionId?: StringFieldUpdateOperationsInput | string
    round?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanetCreateManyStarSystemInput = {
    id?: string
    name: string
    uwp: string
    size: number
    atmosphere: number
    hydrographics: number
    population: number
    government: number
    lawLevel: number
    techLevel: number
    starport: string
    tradeCodes?: PlanetCreatetradeCodesInput | string[]
    bases?: PlanetCreatebasesInput | string[]
    gasGiant?: boolean
    description?: string | null
    notes?: string | null
  }

  export type TradeRouteCreateManyOriginInput = {
    id?: string
    name: string
    distance: number
    difficulty?: number
    destinationId: string
    cargoTypes?: TradeRouteCreatecargoTypesInput | string[]
    profitMargin?: number | null
  }

  export type TradeRouteCreateManyDestinationInput = {
    id?: string
    name: string
    distance: number
    difficulty?: number
    originId: string
    cargoTypes?: TradeRouteCreatecargoTypesInput | string[]
    profitMargin?: number | null
  }

  export type PlanetUpdateWithoutStarSystemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uwp?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    atmosphere?: IntFieldUpdateOperationsInput | number
    hydrographics?: IntFieldUpdateOperationsInput | number
    population?: IntFieldUpdateOperationsInput | number
    government?: IntFieldUpdateOperationsInput | number
    lawLevel?: IntFieldUpdateOperationsInput | number
    techLevel?: IntFieldUpdateOperationsInput | number
    starport?: StringFieldUpdateOperationsInput | string
    tradeCodes?: PlanetUpdatetradeCodesInput | string[]
    bases?: PlanetUpdatebasesInput | string[]
    gasGiant?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tradeGoods?: TradeGoodUpdateManyWithoutPlanetNestedInput
  }

  export type PlanetUncheckedUpdateWithoutStarSystemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uwp?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    atmosphere?: IntFieldUpdateOperationsInput | number
    hydrographics?: IntFieldUpdateOperationsInput | number
    population?: IntFieldUpdateOperationsInput | number
    government?: IntFieldUpdateOperationsInput | number
    lawLevel?: IntFieldUpdateOperationsInput | number
    techLevel?: IntFieldUpdateOperationsInput | number
    starport?: StringFieldUpdateOperationsInput | string
    tradeCodes?: PlanetUpdatetradeCodesInput | string[]
    bases?: PlanetUpdatebasesInput | string[]
    gasGiant?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tradeGoods?: TradeGoodUncheckedUpdateManyWithoutPlanetNestedInput
  }

  export type PlanetUncheckedUpdateManyWithoutStarSystemInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    uwp?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    atmosphere?: IntFieldUpdateOperationsInput | number
    hydrographics?: IntFieldUpdateOperationsInput | number
    population?: IntFieldUpdateOperationsInput | number
    government?: IntFieldUpdateOperationsInput | number
    lawLevel?: IntFieldUpdateOperationsInput | number
    techLevel?: IntFieldUpdateOperationsInput | number
    starport?: StringFieldUpdateOperationsInput | string
    tradeCodes?: PlanetUpdatetradeCodesInput | string[]
    bases?: PlanetUpdatebasesInput | string[]
    gasGiant?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TradeRouteUpdateWithoutOriginInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    distance?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    cargoTypes?: TradeRouteUpdatecargoTypesInput | string[]
    profitMargin?: NullableFloatFieldUpdateOperationsInput | number | null
    destination?: StarSystemUpdateOneRequiredWithoutTradeRoutesDestinationNestedInput
  }

  export type TradeRouteUncheckedUpdateWithoutOriginInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    distance?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    destinationId?: StringFieldUpdateOperationsInput | string
    cargoTypes?: TradeRouteUpdatecargoTypesInput | string[]
    profitMargin?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TradeRouteUncheckedUpdateManyWithoutOriginInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    distance?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    destinationId?: StringFieldUpdateOperationsInput | string
    cargoTypes?: TradeRouteUpdatecargoTypesInput | string[]
    profitMargin?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TradeRouteUpdateWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    distance?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    cargoTypes?: TradeRouteUpdatecargoTypesInput | string[]
    profitMargin?: NullableFloatFieldUpdateOperationsInput | number | null
    origin?: StarSystemUpdateOneRequiredWithoutTradeRoutesNestedInput
  }

  export type TradeRouteUncheckedUpdateWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    distance?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    originId?: StringFieldUpdateOperationsInput | string
    cargoTypes?: TradeRouteUpdatecargoTypesInput | string[]
    profitMargin?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TradeRouteUncheckedUpdateManyWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    distance?: IntFieldUpdateOperationsInput | number
    difficulty?: IntFieldUpdateOperationsInput | number
    originId?: StringFieldUpdateOperationsInput | string
    cargoTypes?: TradeRouteUpdatecargoTypesInput | string[]
    profitMargin?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TradeGoodCreateManyPlanetInput = {
    id?: string
    name: string
    category: string
    basePrice: number
    availability?: string | null
    legality?: string | null
    dtm?: number
  }

  export type TradeGoodUpdateWithoutPlanetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    legality?: NullableStringFieldUpdateOperationsInput | string | null
    dtm?: IntFieldUpdateOperationsInput | number
  }

  export type TradeGoodUncheckedUpdateWithoutPlanetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    legality?: NullableStringFieldUpdateOperationsInput | string | null
    dtm?: IntFieldUpdateOperationsInput | number
  }

  export type TradeGoodUncheckedUpdateManyWithoutPlanetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    basePrice?: IntFieldUpdateOperationsInput | number
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    legality?: NullableStringFieldUpdateOperationsInput | string | null
    dtm?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterCreateManySessionInput = {
    id?: string
    name: string
    description?: string | null
    encounterType: string
    difficulty?: number | null
    location?: string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    outcome?: string | null
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CombatSessionCreateManySessionInput = {
    id?: string
    name?: string | null
    round?: number
    phase?: string
    status?: string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    encounterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionNoteCreateManySessionInput = {
    id?: string
    title?: string | null
    content: string
    noteType?: string
    tags?: SessionNoteCreatetagsInput | string[]
    isPublic?: boolean
    authorId: string
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncounterUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterType?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutEncountersNestedInput
    combatSessions?: CombatSessionUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterType?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    combatSessions?: CombatSessionUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    encounterType?: StringFieldUpdateOperationsInput | string
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    environment?: NullableJsonNullValueInput | InputJsonValue
    npcs?: NullableJsonNullValueInput | InputJsonValue
    rewards?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatSessionUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    encounter?: EncounterUpdateOneWithoutCombatSessionsNestedInput
    actions?: CombatActionUpdateManyWithoutCombatSessionNestedInput
  }

  export type CombatSessionUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: CombatActionUncheckedUpdateManyWithoutCombatSessionNestedInput
  }

  export type CombatSessionUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    encounterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionNoteUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    tags?: SessionNoteUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutSessionNotesNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutSessionNotesNestedInput
  }

  export type SessionNoteUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    tags?: SessionNoteUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionNoteUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    noteType?: StringFieldUpdateOperationsInput | string
    tags?: SessionNoteUpdatetagsInput | string[]
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    authorId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatSessionCreateManyEncounterInput = {
    id?: string
    name?: string | null
    round?: number
    phase?: string
    status?: string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CombatSessionUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneWithoutCombatSessionsNestedInput
    actions?: CombatActionUpdateManyWithoutCombatSessionNestedInput
  }

  export type CombatSessionUncheckedUpdateWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: CombatActionUncheckedUpdateManyWithoutCombatSessionNestedInput
  }

  export type CombatSessionUncheckedUpdateManyWithoutEncounterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    phase?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    initiative?: NullableJsonNullValueInput | InputJsonValue
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatActionCreateManyCombatSessionInput = {
    id?: string
    actionType: string
    description?: string | null
    target?: string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    diceRolled?: string | null
    rollResult?: number | null
    modifiers?: NullableJsonNullValueInput | InputJsonValue
    characterId?: string | null
    round: number
    timestamp?: Date | string
  }

  export type CombatActionUpdateWithoutCombatSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    diceRolled?: NullableStringFieldUpdateOperationsInput | string | null
    rollResult?: NullableIntFieldUpdateOperationsInput | number | null
    modifiers?: NullableJsonNullValueInput | InputJsonValue
    round?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneWithoutCombatActionsNestedInput
  }

  export type CombatActionUncheckedUpdateWithoutCombatSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    diceRolled?: NullableStringFieldUpdateOperationsInput | string | null
    rollResult?: NullableIntFieldUpdateOperationsInput | number | null
    modifiers?: NullableJsonNullValueInput | InputJsonValue
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CombatActionUncheckedUpdateManyWithoutCombatSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableJsonNullValueInput | InputJsonValue
    diceRolled?: NullableStringFieldUpdateOperationsInput | string | null
    rollResult?: NullableIntFieldUpdateOperationsInput | number | null
    modifiers?: NullableJsonNullValueInput | InputJsonValue
    characterId?: NullableStringFieldUpdateOperationsInput | string | null
    round?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignCountOutputTypeDefaultArgs instead
     */
    export type CampaignCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterCountOutputTypeDefaultArgs instead
     */
    export type CharacterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StarSystemCountOutputTypeDefaultArgs instead
     */
    export type StarSystemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StarSystemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanetCountOutputTypeDefaultArgs instead
     */
    export type PlanetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionCountOutputTypeDefaultArgs instead
     */
    export type SessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterCountOutputTypeDefaultArgs instead
     */
    export type EncounterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CombatSessionCountOutputTypeDefaultArgs instead
     */
    export type CombatSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CombatSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignDefaultArgs instead
     */
    export type CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignMemberDefaultArgs instead
     */
    export type CampaignMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterDefaultArgs instead
     */
    export type CharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacteristicsDefaultArgs instead
     */
    export type CharacteristicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacteristicsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterSkillDefaultArgs instead
     */
    export type CharacterSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterEquipmentDefaultArgs instead
     */
    export type CharacterEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterEquipmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LifeEventDefaultArgs instead
     */
    export type LifeEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LifeEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StarSystemDefaultArgs instead
     */
    export type StarSystemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StarSystemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanetDefaultArgs instead
     */
    export type PlanetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StarshipDefaultArgs instead
     */
    export type StarshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StarshipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TradeGoodDefaultArgs instead
     */
    export type TradeGoodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TradeGoodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TradeRouteDefaultArgs instead
     */
    export type TradeRouteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TradeRouteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EncounterDefaultArgs instead
     */
    export type EncounterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EncounterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CombatSessionDefaultArgs instead
     */
    export type CombatSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CombatSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CombatActionDefaultArgs instead
     */
    export type CombatActionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CombatActionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiceRollDefaultArgs instead
     */
    export type DiceRollArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiceRollDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomContentDefaultArgs instead
     */
    export type CustomContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomContentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HouseRuleDefaultArgs instead
     */
    export type HouseRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HouseRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HandoutDefaultArgs instead
     */
    export type HandoutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HandoutDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionNoteDefaultArgs instead
     */
    export type SessionNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionNoteDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}